{
  "language": "Solidity",
  "sources": {
    ".coverage_contracts/arch/Hashing.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"./Value.sol\";\r\n\r\nlibrary Hashing {\nfunction coverage_0x7724f559(bytes32 c__0x7724f559) public pure {}\n\r\n    using Hashing for Value.Data;\r\n    using Value for Value.CodePoint;\r\n\r\n    function hashInt(uint256 val) internal pure returns (bytes32) {coverage_0x7724f559(0x9eaf3c10121ec2ad900a5ed7b8bdd34a5c958c342389b771e17c434a1ac77e3c); /* function */ \n\r\ncoverage_0x7724f559(0x3f4b0079d0abe39628827497a5787e4d7dfa0b15ee9f4b8d55839318a5440adb); /* line */ \n        coverage_0x7724f559(0x13ba17733fd21a6b9bd2f022881571c1c9ec5b18840b09c1be3108f335af9e75); /* statement */ \nreturn keccak256(abi.encodePacked(val));\r\n    }\r\n\r\n    function hashCodePoint(Value.CodePoint memory cp) internal pure returns (bytes32) {coverage_0x7724f559(0x7c1bc8a3ec822222df570cead1f77b7ab198c4b8af4c18529f140928d916142d); /* function */ \n\r\ncoverage_0x7724f559(0x7e913d0678f72ea9e67eabab3edee606a09f518ca623ded4e21fb55f5f33d8cf); /* line */ \n        coverage_0x7724f559(0xc3b10d992543c1e822ac11f1190ddb389b2fb298a9f01c0e8b7e7eff140af748); /* assertPre */ \ncoverage_0x7724f559(0x02a91c7d5d802f7db54c53d8e1e0563c01caa83ac9a0ccc76337b4bc45a362a7); /* statement */ \nassert(cp.immediate.length < 2);coverage_0x7724f559(0x36adea37782994cf88fbcd2bb5c0b82e1288546688623f7e51ee76cbccd0a1dc); /* assertPost */ \n\r\ncoverage_0x7724f559(0x37ef9297fbae8dd4ff7f4998ec7563481217e9805fe2b8236b9022f0fbb092b2); /* line */ \n        coverage_0x7724f559(0x6c521419fe6d60ad5e20bcae197257b63aa36ac93eec2d1c0faa5686ceb4fcd4); /* statement */ \nif (cp.immediate.length == 0) {coverage_0x7724f559(0x6d1ecdf237b0ddf3168f6bf74d90e3f5e3b6e63f0ef837ee42f71b642b29aac3); /* branch */ \n\r\ncoverage_0x7724f559(0x08776042cda6cc0de12d099adb095c909930c75eb976136c2168d950b411026c); /* line */ \n            coverage_0x7724f559(0x4afdaa3c514233f45f7846ff306a823f473985782902cd6c98f9176dd9be0508); /* statement */ \nreturn\r\n                keccak256(abi.encodePacked(Value.codePointTypeCode(), cp.opcode, cp.nextCodePoint));\r\n        }else { coverage_0x7724f559(0x3d4b4c3b188845d7b102be3970c69a0a024cb0d4ff959112adb8b86ba426af03); /* branch */ \n}\r\ncoverage_0x7724f559(0xe99e779e94a7297ad48654f6e20f54f17103e47753e40470061b31748100057f); /* line */ \n        coverage_0x7724f559(0x6c0d400e9ad1d95cdfd156d3272f1253594865301d7b8c49f2266abdafb022fb); /* statement */ \nreturn\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    Value.codePointTypeCode(),\r\n                    cp.opcode,\r\n                    cp.immediate[0].hash(),\r\n                    cp.nextCodePoint\r\n                )\r\n            );\r\n    }\r\n\r\n    function hashTuplePreImage(bytes32 innerHash, uint256 valueSize)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {coverage_0x7724f559(0x71f5e827fb19072731fcdf08abbcac1e05af848d4f5170ffc1c1abbf63dcd2d8); /* function */ \n\r\ncoverage_0x7724f559(0xfb3db81ac1b57658d8a50e225a2106d85853a535d3b32facf2f56b30191e1116); /* line */ \n        coverage_0x7724f559(0x06c45123bb49303a1c821bfae299f7484804f9ebfe0e970d7688f9ca7a02a9f4); /* statement */ \nreturn keccak256(abi.encodePacked(uint8(Value.tupleTypeCode()), innerHash, valueSize));\r\n    }\r\n\r\n    function hash(Value.Data memory val) internal pure returns (bytes32) {coverage_0x7724f559(0xeecbf3b43e174bfa9d3dc05243ca8f4e02c7fcfcd1ece9679182e0651e0cab55); /* function */ \n\r\ncoverage_0x7724f559(0x052e4464f740c6502cf0fd229fdf67e45f209fb1cbfb19d1c14c5d1a29c07e6a); /* line */ \n        coverage_0x7724f559(0x9f2ec5cb74c85b3dda79d02129b4497f194f44f5c60580708bdaac4f7d19de12); /* statement */ \nif (val.typeCode == Value.intTypeCode()) {coverage_0x7724f559(0x24d3525e18528b0e7b5a22ab780a539f29f70d811ff40d99badfbaaa5b39fd3b); /* branch */ \n\r\ncoverage_0x7724f559(0xa7a7839ed32d6cf00fc1865d538e5e1a402b87a2c4f7b227e0b7b36b888f5808); /* line */ \n            coverage_0x7724f559(0x593ac5c2c5288c1dbb203d27dacac00cede5fcdb7fc9d10a5c305fbb4c73c562); /* statement */ \nreturn hashInt(val.intVal);\r\n        } else {coverage_0x7724f559(0xa30c6083d4e6df3807e31c2442739d4ab4e5647ddecf2480b794193b92413911); /* statement */ \ncoverage_0x7724f559(0x1e36abb78feb0bacc7fe90795af878ba23f3ca1aa0dc9f88b422f9dda0c8ff61); /* branch */ \nif (val.typeCode == Value.codePointTypeCode()) {coverage_0x7724f559(0x77e4c526c606c4e9f5d43cce2740ec9671fd6fb354963233bcb5d7af2a69fd1d); /* branch */ \n\r\ncoverage_0x7724f559(0x2124e9c3abdf6745aaa436519fdfd6c1740fec7208eb945cc032adcb1ab90676); /* line */ \n            coverage_0x7724f559(0x55da3fb306d7c8a9ebef352a4737e112d908e61af1757d65bbcaf5d0393c021d); /* statement */ \nreturn hashCodePoint(val.cpVal);\r\n        } else {coverage_0x7724f559(0xf08847433bfbd8a6e2ee9bc8d78ec986014f36ce065c1d1707a5dd5218f1481b); /* statement */ \ncoverage_0x7724f559(0x04a288f8aad1aeb8c303d69df7789ed0ef77851572b7777fdf1dab24a63d23d4); /* branch */ \nif (val.typeCode == Value.tuplePreImageTypeCode()) {coverage_0x7724f559(0x053f2fc07c5e68d07944c4d8f49a051d37cab82655e08bdbc8116aa04ab3d9d1); /* branch */ \n\r\ncoverage_0x7724f559(0x58b76dc10646fbb4a572d993371ad30d350ad181d2494b5ed7e482ec78d0aa5d); /* line */ \n            coverage_0x7724f559(0x27311cc9a8003541aa5824b056dc38db6ebdd89963517e6bde81efa5f9e07dac); /* statement */ \nreturn hashTuplePreImage(bytes32(val.intVal), val.size);\r\n        } else {coverage_0x7724f559(0xd701feb7b54094b4cd44090f9b08f44fb9674096a49308a022977bb10b2248d2); /* statement */ \ncoverage_0x7724f559(0x7d48c6f363478e43f51853eac0bfda719dee000b51f1104e887e589a8d515bb4); /* branch */ \nif (val.typeCode == Value.tupleTypeCode()) {coverage_0x7724f559(0x29dbd803792a5d60aafc327fd5b8da7a08bdddc61d11c31f31faf731592100a9); /* branch */ \n\r\ncoverage_0x7724f559(0x25a1fb259b08d27dcb8ec8d5727d0254fb27d0c4a1ebdc88a72ea0eb02142018); /* line */ \n            coverage_0x7724f559(0x5315fcf275934a9f39028957597cb1acdfcfe4454039f7332b47785b10dae963); /* statement */ \nValue.Data memory preImage = getTuplePreImage(val.tupleVal);\r\ncoverage_0x7724f559(0x3dcea2332b134590dce160c112e9926fb764b57ca3ae2b4ae3f2e0963976cc00); /* line */ \n            coverage_0x7724f559(0x5ce3440dc0f5e535c12d9f0346a83362afb7f8664e6759090e16c4944983a14e); /* statement */ \nreturn preImage.hash();\r\n        } else {coverage_0x7724f559(0x474026bd48f6a8df713d01eba551deecd2d324a7033ebd72d2d078475cece8a4); /* statement */ \ncoverage_0x7724f559(0x2f7b5184646ba6972b2771a2ffbb63f41896ba7e144e6e3282150132f0d26ee6); /* branch */ \nif (val.typeCode == Value.hashOnlyTypeCode()) {coverage_0x7724f559(0x8319669813af7147de721c4ea1a90094d6746faf17dd26ec0fabb73c4a1e4e61); /* branch */ \n\r\ncoverage_0x7724f559(0x1e8d3ca058b777afa4850a144099cca89bc39e02a6fc113aff71001da0ed371e); /* line */ \n            coverage_0x7724f559(0xd34f13064256441d80ce18e14c0ab4a6a7699701186482696dfb0436a109f022); /* statement */ \nreturn bytes32(val.intVal);\r\n        } else {coverage_0x7724f559(0xe31fedf5f88680c2b66c331607361e5d6bb6291d34bbe9d78071c3210c12e0ab); /* branch */ \n\r\ncoverage_0x7724f559(0x31ef4d60adf5e34c8082ee11956b5b0c4064cd688f44c7df407ff965f4ef98bd); /* line */ \n            coverage_0x7724f559(0x1b483e362aae0ea9f85961ce9c0910441d98844d0d2f53d5878aa0af1aa70a4f); /* assertPre */ \ncoverage_0x7724f559(0x52033be6f627dd77e0a393449591813fa7c413a8929d666a6b76afac2812e435); /* statement */ \nrequire(false, \"Invalid type code\");coverage_0x7724f559(0x39825640e6d04eb7ac2f09ccaba5ae506855553a1c0a499b97fb2b98e50d4172); /* assertPost */ \n\r\n        }}}}}\r\n    }\r\n\r\n    function getTuplePreImage(Value.Data[] memory vals) internal pure returns (Value.Data memory) {coverage_0x7724f559(0xcb96678d2beb82c5c066a67efd2a4113e1426f6e76b5f9659e494939d8d733b5); /* function */ \n\r\ncoverage_0x7724f559(0x5040153078cd839495bdae2c2c6a57d5feac7d74ed6af390135983fd93ef4b1d); /* line */ \n        coverage_0x7724f559(0xc3c879137465a9213cd9c5def168b9f6c3a4bb87c09e49697b0f9d20ca0f1979); /* assertPre */ \ncoverage_0x7724f559(0xdcbf84ff2516663821430592a54b97b8cd5a3fdfc8a4429078e92da78273c535); /* statement */ \nrequire(vals.length <= 8, \"Invalid tuple length\");coverage_0x7724f559(0x11bf2898862dd866510d68dbb932a61c50ee08db75f4a8e14e658132e99192b2); /* assertPost */ \n\r\ncoverage_0x7724f559(0xad48dc3f9c61718bc228450e153b448d7537cf61aeb6e345f4edf0ca8dd2a38a); /* line */ \n        coverage_0x7724f559(0x121addf4891a997bc2f865cda516368a280d038ed199e5bc7b568db34e34fd0e); /* statement */ \nbytes32[] memory hashes = new bytes32[](vals.length);\r\ncoverage_0x7724f559(0xb636cc31c2e1e3f0bd321d5bc435398a3afb7ff145cc2f47006e3241430fc48a); /* line */ \n        coverage_0x7724f559(0x8a946f4539748a3a77b86d2f1c6393e9d590bbaec93f5cd01893159f4162181e); /* statement */ \nuint256 hashCount = hashes.length;\r\ncoverage_0x7724f559(0xe3c7ca3baf9947f243b40507ff9b05fa216259571a10651e6ff528238dbc69d3); /* line */ \n        coverage_0x7724f559(0xee431f5b655a5d26b8ae288fccac479b236e3f73d469ba9ab63434cde1b6803d); /* statement */ \nuint256 size = 1;\r\ncoverage_0x7724f559(0xe5741e295e6ebe6c5854bcc0b96bd1c0c2e6070de202f111beb2afb00a4898a9); /* line */ \n        coverage_0x7724f559(0x3fdcc2b763fa50b1cf3d9876cdc59650334948ab2df2f202e917a2ee5e70f38d); /* statement */ \nfor (uint256 i = 0; i < hashCount; i++) {\r\ncoverage_0x7724f559(0x917c302a6a2e0d5fbb5b0ad650a7a62ff3d0941c51a8ca2d02d0d44072171671); /* line */ \n            coverage_0x7724f559(0xd96e2ac714e529fd9e8d5f735b357523f82d453489609feb389872a25e0ad5ea); /* statement */ \nhashes[i] = vals[i].hash();\r\ncoverage_0x7724f559(0x725bfbdb0b12c58e7c05aa7373c5229818cfe172dee9b6f9e84f0f8bd270f15a); /* line */ \n            coverage_0x7724f559(0x4e337f3ed10df128a8b16d6afbeded8c72ff5b0fbca78cf18073119b4dc93443); /* statement */ \nsize += vals[i].size;\r\n        }\r\ncoverage_0x7724f559(0x093d8b45a8fa77da5c13c708f0bfecfb52e60ad3f3e310a1b62e89bc1c6e67c9); /* line */ \n        coverage_0x7724f559(0x64c51795f86fb95a92461a7498e310d85ef4cc3bba3ea08f5a9d8947d46c7efc); /* statement */ \nbytes32 firstHash = keccak256(abi.encodePacked(uint8(hashes.length), hashes));\r\ncoverage_0x7724f559(0x91d12e7f689f45ac73dd071fb67ca90d18eeb9568c4fe8fa21cd22d8606457e4); /* line */ \n        coverage_0x7724f559(0x16754757e0de1bf52e6e06a59aa2235f0e18edb6290beb7b906735a5943ccfa4); /* statement */ \nreturn Value.newTuplePreImage(firstHash, size);\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/arch/Value.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nlibrary Value {\nfunction coverage_0x04be09c7(bytes32 c__0x04be09c7) public pure {}\n\r\n    uint8 internal constant INT_TYPECODE = 0;\r\n    uint8 internal constant CODE_POINT_TYPECODE = 1;\r\n    uint8 internal constant HASH_PRE_IMAGE_TYPECODE = 2;\r\n    uint8 internal constant TUPLE_TYPECODE = 3;\r\n    // All values received from clients will have type codes less than the VALUE_TYPE_COUNT\r\n    uint8 internal constant VALUE_TYPE_COUNT = TUPLE_TYPECODE + 9;\r\n\r\n    // The following types do not show up in the marshalled format and is\r\n    // only used for internal tracking purposes\r\n    uint8 internal constant HASH_ONLY = 100;\r\n\r\n    struct CodePoint {\r\n        uint8 opcode;\r\n        bytes32 nextCodePoint;\r\n        Data[] immediate;\r\n    }\r\n\r\n    struct Data {\r\n        uint256 intVal;\r\n        CodePoint cpVal;\r\n        Data[] tupleVal;\r\n        uint8 typeCode;\r\n        uint256 size;\r\n    }\r\n\r\n    function tupleTypeCode() internal pure returns (uint8) {coverage_0x04be09c7(0xd7e0589d4c113baf5572348e58bb6ebacce9d2306a1c6100f87b277498e270af); /* function */ \n\r\ncoverage_0x04be09c7(0x8368611b2ed88b90fa5ce45a1ca1f31381b4d1e41eca4947c72a78bb8872e1f1); /* line */ \n        coverage_0x04be09c7(0xfa548d92d5f0fb37157d18fff554355b0f8dbaca80ebd63255ea24985ee25ce5); /* statement */ \nreturn TUPLE_TYPECODE;\r\n    }\r\n\r\n    function tuplePreImageTypeCode() internal pure returns (uint8) {coverage_0x04be09c7(0x3c9a94a0e49d593d9879c0a8ce82843e8f94222ff5bfb7ea6fdd99803f6bb34c); /* function */ \n\r\ncoverage_0x04be09c7(0x2681a132f77c098349a13efe5cbc3f9aba8878d0601fd38c2a040349881a4047); /* line */ \n        coverage_0x04be09c7(0xfb7c0ceb17661e0098f59367b21b1cc29b3dcd7c77a671c9c8f31d4f1134ef48); /* statement */ \nreturn HASH_PRE_IMAGE_TYPECODE;\r\n    }\r\n\r\n    function intTypeCode() internal pure returns (uint8) {coverage_0x04be09c7(0x73275b64c810e4a9580d191cf9ba01b17675f24c8ccd2d6dffa9aa1e7ca9d6ee); /* function */ \n\r\ncoverage_0x04be09c7(0x456a01af384e2214f8d43224af3ce8b11283647a82889a88f74a1ed9f3889654); /* line */ \n        coverage_0x04be09c7(0x5fca3708de856d52944a5320b7e8a0d541267868c894e1494a2418af7ce8c9e9); /* statement */ \nreturn INT_TYPECODE;\r\n    }\r\n\r\n    function codePointTypeCode() internal pure returns (uint8) {coverage_0x04be09c7(0xb341e1b9d450c11c8f5958c236b30a8867749f6cd791629945e05d0be39e7265); /* function */ \n\r\ncoverage_0x04be09c7(0x450c428c6d478cc1994c24b5bbc973539a8d0cfb8708830e6a9d3418e6e2c991); /* line */ \n        coverage_0x04be09c7(0xd0b066fb67fe6bc14667c30a6b0df480d311e889e09073f883e85b6cbea841bf); /* statement */ \nreturn CODE_POINT_TYPECODE;\r\n    }\r\n\r\n    function valueTypeCode() internal pure returns (uint8) {coverage_0x04be09c7(0xafaf072e5be036912341e1e23e6f50063721f347265d6d5b71a519e5f01ba139); /* function */ \n\r\ncoverage_0x04be09c7(0x4ceb93b3b6eacf1bbb2b9cea35b687cfc501b57dab5c10946f038461cdc715a3); /* line */ \n        coverage_0x04be09c7(0xab4ac7a14f738b1a294a620da24c8ea6ff76b724105d3d3115734e4d6880d49c); /* statement */ \nreturn VALUE_TYPE_COUNT;\r\n    }\r\n\r\n    function hashOnlyTypeCode() internal pure returns (uint8) {coverage_0x04be09c7(0x8911de75c878c233098edb1f2fef9ad46182ebed2d960bba36c5b659b516e63b); /* function */ \n\r\ncoverage_0x04be09c7(0x4137ed7ecbc3cc0311d16944567647668e85407e4cc8c6eba9c489d146b81861); /* line */ \n        coverage_0x04be09c7(0x67e2a88fa9bd5c59bd313a45cca4e5e39b6283127247468128212ded26b6a0d5); /* statement */ \nreturn HASH_ONLY;\r\n    }\r\n\r\n    function isValidTupleSize(uint256 size) internal pure returns (bool) {coverage_0x04be09c7(0xbcd7b430a819123c2ef82ee3dd11ca2d735d1d10d65733ec8027962269af21e6); /* function */ \n\r\ncoverage_0x04be09c7(0xaec8833a01caa68d3095160f940347c26a4dc644ef5482a20186fc2ff80cc33e); /* line */ \n        coverage_0x04be09c7(0xd61e7b7864958bb3ddcbb948a931933c12703a09bf0e3472cea9bbda3b2cd086); /* statement */ \nreturn size <= 8;\r\n    }\r\n\r\n    function typeCodeVal(Data memory val) internal pure returns (Data memory) {coverage_0x04be09c7(0x7b085f9112fdec6cce840b16440d76af3e872b5cee739f84b465a2a3c831f319); /* function */ \n\r\ncoverage_0x04be09c7(0xd3c750a83b40e40518e3f1f0fb710f5dcc7098d7f8e747a92f87a3498aef2e62); /* line */ \n        coverage_0x04be09c7(0xc359b5a6766fc48c2d18b81de2cc77a87e6789da7086dcd47f2bbe87c648445e); /* assertPre */ \ncoverage_0x04be09c7(0x002913eb25b1753132d467eebdc99ed9ffc9d3602fdc7fa0c845b175fc5e8e2d); /* statement */ \nrequire(val.typeCode != 2, \"invalid type code\");coverage_0x04be09c7(0x4d90412f08418580da53ccf53f54a11bd70d4954253865bc54e8a552870aab1c); /* assertPost */ \n\r\ncoverage_0x04be09c7(0x750c0a03eabf40a1ee0dbafdd5243b405569a1b35b1af8cb9857ce719183733b); /* line */ \n        coverage_0x04be09c7(0x38fc11b2ad27cfaf22bc547da0de1229be2e0e11ed5b89c07be8ddac71429f8b); /* statement */ \nreturn newInt(val.typeCode);\r\n    }\r\n\r\n    function valLength(Data memory val) internal pure returns (uint8) {coverage_0x04be09c7(0x3e4e6ba65cece25a028f42e735969bc893312066734830735a3646f07b5c8d91); /* function */ \n\r\ncoverage_0x04be09c7(0xa7ee343f1beb2cd0300231a5fcff72a76e1a25b5def5e7c8f792ce5e4c6cdbeb); /* line */ \n        coverage_0x04be09c7(0xc3c92d63cab1f1aa5861ed0b4248734c43d7c7db1724051c912a51be1549af00); /* statement */ \nif (val.typeCode == TUPLE_TYPECODE) {coverage_0x04be09c7(0xeb0e234529b9dd09cfaf7285ca0fa8cf8ca869848b4b810617b84337ffde960b); /* branch */ \n\r\ncoverage_0x04be09c7(0xc9887b5cc25f584f27597c3cd1d8032e849753ad93de7b308494f85d20397601); /* line */ \n            coverage_0x04be09c7(0x09570cd4df5bfb8f2fd25f84cf9a8a2ecd9938d5ccf8fd169d150a102c8647d8); /* statement */ \nreturn uint8(val.tupleVal.length);\r\n        } else {coverage_0x04be09c7(0x1ee8d03b472d4725aea581ad25a2400a077d4f85e774283aaf7fcded28b4b41a); /* branch */ \n\r\ncoverage_0x04be09c7(0x7285ba2dbf3dc52c3ef35243abe461bbfa886136990556d3a5113435124133cb); /* line */ \n            coverage_0x04be09c7(0x89087d5179bbd0259aa1b0253703471ea8e801a010d13f16de5ba8de18d587df); /* statement */ \nreturn 1;\r\n        }\r\n    }\r\n\r\n    function isInt(Data memory val) internal pure returns (bool) {coverage_0x04be09c7(0x51484908f5f963407246d2abd0ff8b37b9540f5d6d4cab1b2b22ae267b603530); /* function */ \n\r\ncoverage_0x04be09c7(0x6dbad77cbe0398496c07dbd3804baa4f24c208f663e4508e6cfea7a537e0d6fe); /* line */ \n        coverage_0x04be09c7(0x90a9d3186371b33475946cca5d21b9610fb9e4f94ff3a1951ac794eb2c7a66f7); /* statement */ \nreturn val.typeCode == INT_TYPECODE;\r\n    }\r\n\r\n    function isCodePoint(Data memory val) internal pure returns (bool) {coverage_0x04be09c7(0xdc958fa5b2372e7653db6cf8faa815d5ca65919e366161a2b54127c111593a21); /* function */ \n\r\ncoverage_0x04be09c7(0xc7abf4584442c799da8dd67fd20ccbc8c91dfc8908d7e6def57b41c7baf320d7); /* line */ \n        coverage_0x04be09c7(0x077f9de0198c916f04294cde6b6616a51393ff185200c55f7adf9fe0a12eca34); /* statement */ \nreturn val.typeCode == CODE_POINT_TYPECODE;\r\n    }\r\n\r\n    function isTuple(Data memory val) internal pure returns (bool) {coverage_0x04be09c7(0x0d6c568df8e096053d6317ecc57d489d79ab524bc2ca1dc672ad5c8ec2ee27b7); /* function */ \n\r\ncoverage_0x04be09c7(0x0965bf1f5442cf4c4eeec175adc781ea59a342547b235d356c06f4c557e2c33f); /* line */ \n        coverage_0x04be09c7(0xaf4187dc872c2863b401f8274c92117629daa900866c15e30c174b7292150201); /* statement */ \nreturn val.typeCode == TUPLE_TYPECODE;\r\n    }\r\n\r\n    function isValidTypeForSend(Data memory val) internal pure returns (bool) {coverage_0x04be09c7(0x2185e34deb4097f9be62cb9406d78786e5f18bc42acb0504f373787166606eb7); /* function */ \n\r\ncoverage_0x04be09c7(0x8c049e5c1f21620e33619480463283db73fe86bfc777878b34737e6c02e79835); /* line */ \n        coverage_0x04be09c7(0x3a87c64614ddc839bb57e56750e878c58c871c3a933df50309afe0852c36061c); /* statement */ \nif (val.typeCode == INT_TYPECODE) {coverage_0x04be09c7(0x3fc082b7ef3c7be250e2ef59ee4940967fbaf498d4a32a5d9e23fb16ff01ca79); /* branch */ \n\r\ncoverage_0x04be09c7(0x7c2ddfbf87fdb955785bcea803f9069afdc7dc64c4742091b5c82958521481f0); /* line */ \n            coverage_0x04be09c7(0x378768b3f6d509e550532eda11aaf0fed4f8f16ea849ab75ab4a57c056841e30); /* statement */ \nreturn true;\r\n        } else {coverage_0x04be09c7(0x400aa719dcf61650f58247c3b88b16452124c8a9dae9d07cd57da401d109c770); /* statement */ \ncoverage_0x04be09c7(0xa7953dca7ca22d0cc613eeb304a212a8cda2f14738c580277e1c7c4b408e2ead); /* branch */ \nif (val.typeCode == CODE_POINT_TYPECODE) {coverage_0x04be09c7(0xbcb63d0837c321678068c50b1155d7d7a568fed5593e20ff771bd75a6b775d8a); /* branch */ \n\r\ncoverage_0x04be09c7(0x02ef990555375a71f4175179c5543b9375954eeace453ad6e3e04c601a7c133b); /* line */ \n            coverage_0x04be09c7(0x383c20bc558d3843ce5e9b0956d1e716b0e7aabebe86ed6739d95045e4a55b2c); /* statement */ \nreturn false;\r\n        } else {coverage_0x04be09c7(0xfcbfa54c7986ef50161e0135ac6e83a57183ca5bd359dd141ecc1ccc07e86f9f); /* statement */ \ncoverage_0x04be09c7(0xe7f401ec65c46d46838c2880d0fce3d9c06cfb559b36210f6f1046db5e9676f7); /* branch */ \nif (val.typeCode == HASH_PRE_IMAGE_TYPECODE) {coverage_0x04be09c7(0x20d223ab4294ae8e30de5cb1bcef4f6bd38d7cca339eb6028f272c93bbe62dbb); /* branch */ \n\r\ncoverage_0x04be09c7(0x598aa3a159748f79399465d5f8a261b1bb2d8e84c8b51643edbe473011929bd1); /* line */ \n            coverage_0x04be09c7(0x64a7c53dafc4db0478700290f778e7d2a201592f273de6974dcc45a2e45d93e5); /* assertPre */ \ncoverage_0x04be09c7(0x558aab1b0ce5057c475ecdc6aa0fdb462364ab2d29d19ab07f5de67723e4ae56); /* statement */ \nrequire(false, \"must have full value\");coverage_0x04be09c7(0x107ccb66c0ca14bfa10ce50772ceda412457a8f2495f88b28a5d74a7b51637b9); /* assertPost */ \n\r\n        } else {coverage_0x04be09c7(0x3f4dea1bbddde49fbd42047c6f6762140a8497875e60459ca9182bf98ec385b2); /* statement */ \ncoverage_0x04be09c7(0xaa8315b94a86554018fd67cd4720c66096ba9df01bf232f7486a558a4d07c3d1); /* branch */ \nif (val.typeCode == TUPLE_TYPECODE) {coverage_0x04be09c7(0x64aed3ca79afa2b5830755f530bbacbf1f4fcf59370ce9a47b43990a0aea7940); /* branch */ \n\r\ncoverage_0x04be09c7(0xdba404a9098e9ad122aaba3c7543bfda0c0a2aa2354c20e2213942ced009e15b); /* line */ \n            coverage_0x04be09c7(0xfeef635427a3428f4329cd169b7ac49dee7c6ebe1a3180b33635d1b57c009c80); /* statement */ \nuint256 valueCount = val.tupleVal.length;\r\ncoverage_0x04be09c7(0xc591b4897ff992a5b6e7b36fd3013a65d7f62738f3d1447b57a2baa1ea6b157c); /* line */ \n            coverage_0x04be09c7(0xea1a2b10c1129b1e2319c4af0ec9770e78b1a1291154faf753cbf6f9a752e0ef); /* statement */ \nfor (uint256 i = 0; i < valueCount; i++) {\r\ncoverage_0x04be09c7(0x9cc14d008a6ef0896e9f9bd120f96355cf9e0dae18d3995f035e6a75b5317838); /* line */ \n                coverage_0x04be09c7(0x54059208a7cf28d3f5c639a9e236c65e4e448ccee042c5478aa177c27072739c); /* statement */ \nif (!isValidTypeForSend(val.tupleVal[i])) {coverage_0x04be09c7(0x6459a6a3fbb776e1500d903ed96ad5a1cee6633a227549320c793133807789a6); /* branch */ \n\r\ncoverage_0x04be09c7(0xd192203c1c21ae1078f093dcd15db6704c1e5266b8733873702df79d588a2757); /* line */ \n                    coverage_0x04be09c7(0xe3f630fa56ad5c276957217916df6b6c48323efc32cbdc96f62a30aff4d8366f); /* statement */ \nreturn false;\r\n                }else { coverage_0x04be09c7(0x0144945288b9fc66ca5e8e58717a024033f880439de3488ea48c346bf56554ec); /* branch */ \n}\r\n            }\r\ncoverage_0x04be09c7(0x52c8bb1350aa170be07eff99f76bf1ef81993e491ee2251832355b9443aa410b); /* line */ \n            coverage_0x04be09c7(0x36bff3abcbf801122fd6e3e24e3f94d0fe7f22e5a711eeda9c574f54c1565807); /* statement */ \nreturn true;\r\n        } else {coverage_0x04be09c7(0xdb938b14ebd24b66084e6117dfa0229456eb0f7f4e596e00f78c9d37c261e9fc); /* statement */ \ncoverage_0x04be09c7(0xcb939a67f70f5f5458d08921a142f68c884e8f34d62a482d7913a088d140d179); /* branch */ \nif (val.typeCode == HASH_ONLY) {coverage_0x04be09c7(0xd724abc4856bb7310450ba1e4e28e65a699e0e36d4b6da8431bcb6c897568fbd); /* branch */ \n\r\ncoverage_0x04be09c7(0x7d2050fb4cc312fdff67886270f190f0a03c96edc563420434412a5ffa72e58c); /* line */ \n            coverage_0x04be09c7(0x744bf149ea3a541d1ef4047b62651ed175b5e270623d7a1fafc4f4238c3bbc22); /* statement */ \nreturn false;\r\n        } else {coverage_0x04be09c7(0xf3e9157b5348e6a146fb1b1c8313746c952589c41c09a42528dc8900f764df60); /* branch */ \n\r\ncoverage_0x04be09c7(0x11fab9150c1f97abdabb0ef3f5929c1da2ead724dcb38fc2c0790ed519f3f5a1); /* line */ \n            coverage_0x04be09c7(0x548cb7f2007ac427bed67b6b5fa7fb59a16c6f86e8be9241d1d0f14e7fb3dded); /* assertPre */ \ncoverage_0x04be09c7(0x30ac642715f7ed49d49859891215647655ab583c271898bf4208c124c070ca82); /* statement */ \nrequire(false, \"Invalid type code\");coverage_0x04be09c7(0x1ce5f43fb89f49eed0a9b4373f3e8138b11dcc54ecb1db30f477778eca19ffdb); /* assertPost */ \n\r\n        }}}}}\r\n    }\r\n\r\n    function newEmptyTuple() internal pure returns (Data memory) {coverage_0x04be09c7(0xdb83ccc9b0e47c209243d8008dbabf0376a1765678e11e03f2d2768b2394382e); /* function */ \n\r\ncoverage_0x04be09c7(0x883487fe06b6f9e86e9b372720bc844e8651d55d7a70fd5e60a74e252e8e5c1b); /* line */ \n        coverage_0x04be09c7(0xebdf76e2b24e81c972d71e2568e15d9855ee6afa90df72e3f6944079e1184592); /* statement */ \nreturn newTuple(new Data[](0));\r\n    }\r\n\r\n    function newBoolean(bool val) internal pure returns (Data memory) {coverage_0x04be09c7(0x6406a5eaa7f4fbb9b5fc1fbc8c052fd1740ae7f155c387f309f1525eed32a2ee); /* function */ \n\r\ncoverage_0x04be09c7(0x9c08342034d15eeb27750df8f505e9805413e0d39b0fbd2fb8029c28f8b614b6); /* line */ \n        coverage_0x04be09c7(0x6a9885083cd14eb24a0c4da40003cc525d73639d6d481d92680bb8564654118c); /* statement */ \nif (val) {coverage_0x04be09c7(0xdb783db42fd3a564dc36ef7298c53e9d29499aa7b9c1e25a665c9b34cbd8a22e); /* branch */ \n\r\ncoverage_0x04be09c7(0x10292eb1cde2fc1566cf6f0f97884d115b44cabb8f21758c57aeb7078a37fb75); /* line */ \n            coverage_0x04be09c7(0x789710f1f54ad7f2ace683f9b2dc52ae8f215cf33745b03e50be3b500f7a5a95); /* statement */ \nreturn newInt(1);\r\n        } else {coverage_0x04be09c7(0xa7e7900898a5c8d265557f386899396ced5f4c26b325d3757122a1d295a23ac7); /* branch */ \n\r\ncoverage_0x04be09c7(0x1ab2ad6878ef9b5bc3f9b8c616364fb17bffa964855c21e23fa2872b3063ec8d); /* line */ \n            coverage_0x04be09c7(0xe0dfb96c2941595991b6ba467e4c3d2c1faecc9237840acbacddd24e27d259d4); /* statement */ \nreturn newInt(0);\r\n        }\r\n    }\r\n\r\n    function newInt(uint256 _val) internal pure returns (Data memory) {coverage_0x04be09c7(0x34863474f175119669da93162f2b1f5e4a057bcbb31e2fcff2c6f901dd1caa6a); /* function */ \n\r\ncoverage_0x04be09c7(0xf19d9e70401fb4f0658435b2e527a7614d4d5eabaaf32afdcd2589bf36fe2552); /* line */ \n        coverage_0x04be09c7(0xb9464b8aede3ba3185a1043f1773c50669e0f0852fd99664cb28c9408832131b); /* statement */ \nreturn Data(_val, CodePoint(0, 0, new Data[](0)), new Data[](0), INT_TYPECODE, uint256(1));\r\n    }\r\n\r\n    function newHashedValue(bytes32 valueHash, uint256 valueSize)\r\n        internal\r\n        pure\r\n        returns (Data memory)\r\n    {coverage_0x04be09c7(0x0f8a3366eae04721a64a833858f491eb31b0cbea62e018ea2bb5b2c797931f68); /* function */ \n\r\ncoverage_0x04be09c7(0x137e2ef1ab8989102bd427643f70bc0d0d8f4b21e54a32d88e4e579c3ab3d22e); /* line */ \n        coverage_0x04be09c7(0x3f135af3e96de3c3ca6a5cbaa7532dc5942fc6d7ad6ea58ef74e59389b256be4); /* statement */ \nreturn\r\n            Data(\r\n                uint256(valueHash),\r\n                CodePoint(0, 0, new Data[](0)),\r\n                new Data[](0),\r\n                HASH_ONLY,\r\n                valueSize\r\n            );\r\n    }\r\n\r\n    function newTuple(Data[] memory _val) internal pure returns (Data memory) {coverage_0x04be09c7(0xdd48495b7d492acd22053e8be09f18eccd8ffc88321d07a85ba6351624b957a5); /* function */ \n\r\ncoverage_0x04be09c7(0xdb916a76a8c5a5e976dc8edd04128a07ab99506bfc130cfe2a9636068eabc9ca); /* line */ \n        coverage_0x04be09c7(0xa02820caa1db7c57672dfce2b8a7415b16f23404c69c8f1043acfaf0936eb12c); /* assertPre */ \ncoverage_0x04be09c7(0x13ecd886a8ff296c9be33669a44e59fda261ff16af7c7ee092a2ea66c0220cf6); /* statement */ \nrequire(isValidTupleSize(_val.length), \"Tuple must have valid size\");coverage_0x04be09c7(0x2a2fff8ed251fa8c9508c63c0207202dd2f0d00ce85214444fe34b4afb136d48); /* assertPost */ \n\r\ncoverage_0x04be09c7(0xe455e827bc639b953beb6b89f5049221f9313d42623790122d91efff58a41138); /* line */ \n        coverage_0x04be09c7(0x8e3e381ff63effcb267de359f227e30f80d08c6704b175a4a0ccac93a0f2c5da); /* statement */ \nuint256 size = 1;\r\n\r\ncoverage_0x04be09c7(0x5ac8f0b0997ac618159239e99ddea873834711844d7de9d539f8bbb6fbb2e8b0); /* line */ \n        coverage_0x04be09c7(0x24c531d7f49fb0fb7d52225d93517f5258f006932cf2b1be9f5f17fa2fb72ed8); /* statement */ \nfor (uint256 i = 0; i < _val.length; i++) {\r\ncoverage_0x04be09c7(0x8238eaf4d35e555d053951e3fa7faae7f5585ca24622e98da081626ed62b20ba); /* line */ \n            coverage_0x04be09c7(0xa4a3dfae7968d308a1faeb9e6811bd7fb80608fa7d984863d8a017b6da5470b4); /* statement */ \nsize += _val[i].size;\r\n        }\r\n\r\ncoverage_0x04be09c7(0x785cb25b20180b2dc6f018caa136d94ca20edf5c2ef59d3d191fd275fecfa76f); /* line */ \n        coverage_0x04be09c7(0xdccad9b47c64278a98b04bdeb13d9d69e61c2b8e2e5950d5a41182dfecc456e3); /* statement */ \nreturn Data(0, CodePoint(0, 0, new Data[](0)), _val, TUPLE_TYPECODE, size);\r\n    }\r\n\r\n    function newTuplePreImage(bytes32 preImageHash, uint256 size)\r\n        internal\r\n        pure\r\n        returns (Data memory)\r\n    {coverage_0x04be09c7(0x4d56ef44a24b83643084a88921e880ab89de646f9802a52bc710412e3be4967f); /* function */ \n\r\ncoverage_0x04be09c7(0x872620c5e00e2371a4f6c02002531a980ad551d1fdc729a1ba52acf1e588bab6); /* line */ \n        coverage_0x04be09c7(0xe00b320ca9a7bbe091bd73ae89eca5ff3f492868e2591a5e4ebf0e86c902f523); /* statement */ \nreturn\r\n            Data(\r\n                uint256(preImageHash),\r\n                CodePoint(0, 0, new Data[](0)),\r\n                new Data[](0),\r\n                HASH_PRE_IMAGE_TYPECODE,\r\n                size\r\n            );\r\n    }\r\n\r\n    function newCodePoint(uint8 opCode, bytes32 nextHash) internal pure returns (Data memory) {coverage_0x04be09c7(0x428374565f7f79dc64b66db69433bdc1d0f4a6c1789935b895a2bdbef04c07be); /* function */ \n\r\ncoverage_0x04be09c7(0x2beb93e32aad63e6a8a10b51c573dba66240c440c9c2701b751ae67208f320fe); /* line */ \n        coverage_0x04be09c7(0xfa99c7631c8c08b84188b1534efee669f72eae169d7ab329059d283828fed079); /* statement */ \nreturn newCodePoint(CodePoint(opCode, nextHash, new Data[](0)));\r\n    }\r\n\r\n    function newCodePoint(\r\n        uint8 opCode,\r\n        bytes32 nextHash,\r\n        Data memory immediate\r\n    ) internal pure returns (Data memory) {coverage_0x04be09c7(0xd5fc9f92deaf42e086a69d586d616b5ae0ef32dac6e6a0dc064e45466ae63968); /* function */ \n\r\ncoverage_0x04be09c7(0xb670070c787d7f067da3725b27e43b9cd6474e5f6b1cc9a0c3405188c4b7b524); /* line */ \n        coverage_0x04be09c7(0x0e789f96fa2b50306efcf732b3dbf1f850a4c128527b3ad97693989610ee6e21); /* statement */ \nData[] memory imm = new Data[](1);\r\ncoverage_0x04be09c7(0x57e92ed2101a4099a494f713530b6059996640d6d765f2467c75e63b79dedd1d); /* line */ \n        coverage_0x04be09c7(0x96ce3a4ebe49503e16757af803748d0c67b1bdf7b65d3a32729f8c8b55e7eba7); /* statement */ \nimm[0] = immediate;\r\ncoverage_0x04be09c7(0x28a6399854eaa441b1a10c94f4260e924122364fd89b33d792bf39a14f8545fd); /* line */ \n        coverage_0x04be09c7(0x00ed17eba585883e935460c052e4662c42d4a0e5a052663bcdaf3abb3ade23ef); /* statement */ \nreturn newCodePoint(CodePoint(opCode, nextHash, imm));\r\n    }\r\n\r\n    function newCodePoint(CodePoint memory _val) private pure returns (Data memory) {coverage_0x04be09c7(0x5a90f3f8386a3f717406a2a27d61854d3cb2fd00e53f8a9638762cda14124ddb); /* function */ \n\r\ncoverage_0x04be09c7(0xcc7f9bc1bbbfd30a28f7e1642f720790b0d56ac69191305b80cabbc3e5622223); /* line */ \n        coverage_0x04be09c7(0xbd3aa6ef14d0009aac411a0f6544bb5db27f0cdeff7322137f55eaa8a307ae6f); /* statement */ \nreturn Data(0, _val, new Data[](0), CODE_POINT_TYPECODE, uint256(1));\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/arch/IOneStepProof.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\ninterface IOneStepProof {\r\n    function executeStep(\r\n        bytes32 inboxAcc,\r\n        bytes32 messagesAcc,\r\n        bytes32 logsAcc,\r\n        bytes calldata proof\r\n    ) external view returns (uint64 gas, bytes32[5] memory fields);\r\n\r\n    function executeStepWithMessage(\r\n        bytes32 inboxAcc,\r\n        bytes32 messagesAcc,\r\n        bytes32 logsAcc,\r\n        bytes calldata proof,\r\n        uint8 _kind,\r\n        uint256 _blockNumber,\r\n        uint256 _timestamp,\r\n        address _sender,\r\n        uint256 _inboxSeqNum,\r\n        bytes calldata _msgData\r\n    ) external view returns (uint64 gas, bytes32[5] memory fields);\r\n}\r\n"
    },
    ".coverage_contracts/arch/Machine.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"./Marshaling.sol\";\r\n\r\nimport \"../libraries/DebugPrint.sol\";\r\n\r\nlibrary Machine {\nfunction coverage_0xeb9aabe7(bytes32 c__0xeb9aabe7) public pure {}\n\r\n    using Hashing for Value.Data;\r\n\r\n    uint256 internal constant MACHINE_EXTENSIVE = 0;\r\n    uint256 internal constant MACHINE_ERRORSTOP = 1;\r\n    uint256 internal constant MACHINE_HALT = 2;\r\n\r\n    function addStackVal(Value.Data memory stackValHash, Value.Data memory valHash)\r\n        internal\r\n        pure\r\n        returns (Value.Data memory)\r\n    {coverage_0xeb9aabe7(0x140bf63545439d52be90129b1ab07cf58a3883a083f6ba72fdfed5a099c7fcb6); /* function */ \n\r\ncoverage_0xeb9aabe7(0x3c91ce565394260e08e8fcb9f66d319ea5fe5f1a7c79e5fce9f8a0e0823331a7); /* line */ \n        coverage_0xeb9aabe7(0x2024a9d923b47af1138cf26048e475a729638aa9c75a345ac6d9435030f64421); /* statement */ \nValue.Data[] memory vals = new Value.Data[](2);\r\ncoverage_0xeb9aabe7(0x0ef3b502b79045a2a19d8e14610b406eeb7d98dedfcbcf2a437067c46e87a733); /* line */ \n        coverage_0xeb9aabe7(0xdb0c0ef7e743759373e51162b8be774ba2c325ed16e2b45ea79917a993eda258); /* statement */ \nvals[0] = valHash;\r\ncoverage_0xeb9aabe7(0x17cbe11d54efcf360ebc1149824e87ff8125b4371fc195ce2e611ca92afa4d7b); /* line */ \n        coverage_0xeb9aabe7(0x68b34c05c157e9664289e2e472f23f0716fa68ff1e17600d1336938ef598ce66); /* statement */ \nvals[1] = stackValHash;\r\n\r\ncoverage_0xeb9aabe7(0x6bcae2ca0bbeacb91215588b10e72626c7a52ae3a7ff2c360138847efcade84f); /* line */ \n        coverage_0xeb9aabe7(0x165f88fa0f8d5573b00b13b1af0b9566a28c54d075257fbb0a676685f9e58a3e); /* statement */ \nreturn Hashing.getTuplePreImage(vals);\r\n    }\r\n\r\n    struct Data {\r\n        bytes32 instructionStackHash;\r\n        Value.Data dataStack;\r\n        Value.Data auxStack;\r\n        Value.Data registerVal;\r\n        Value.Data staticVal;\r\n        uint256 arbGasRemaining;\r\n        bytes32 errHandlerHash;\r\n        Value.Data pendingMessage;\r\n        uint256 status;\r\n    }\r\n\r\n    function toString(Data memory machine) internal pure returns (string memory) {coverage_0xeb9aabe7(0xa6974d32e0c606116e7f65d42830df1c8569970364afb6a9ea06d4e99f4ef6ed); /* function */ \n\r\ncoverage_0xeb9aabe7(0xf3eac890931917fe39142c97ec7d5b1ab5728f6185534ed58a651caf64715cf7); /* line */ \n        coverage_0xeb9aabe7(0x32abd1218e5637ba7ae9bfcf5df85fb5023dacfa9c75bcd43828ef8e32d9be9a); /* statement */ \nreturn\r\n            string(\r\n                abi.encodePacked(\r\n                    \"Machine(\",\r\n                    DebugPrint.bytes32string(machine.instructionStackHash),\r\n                    \", \\n\",\r\n                    DebugPrint.bytes32string(machine.dataStack.hash()),\r\n                    \", \\n\",\r\n                    DebugPrint.bytes32string(machine.auxStack.hash()),\r\n                    \", \\n\",\r\n                    DebugPrint.bytes32string(machine.registerVal.hash()),\r\n                    \", \\n\",\r\n                    DebugPrint.bytes32string(machine.staticVal.hash()),\r\n                    \", \\n\",\r\n                    DebugPrint.uint2str(machine.arbGasRemaining),\r\n                    \", \\n\",\r\n                    DebugPrint.bytes32string(machine.errHandlerHash),\r\n                    \", \\n\",\r\n                    DebugPrint.bytes32string(machine.pendingMessage.hash()),\r\n                    \")\\n\"\r\n                )\r\n            );\r\n    }\r\n\r\n    function setExtensive(Data memory machine) internal pure {coverage_0xeb9aabe7(0x74a968549f49b92e88249e19ad3283d0d2406d082859b4155f9d9b3ff3203af7); /* function */ \n\r\ncoverage_0xeb9aabe7(0x17086b4d8d15f3c13d8a7621cd8e6f3075d4101b395d97b1bd12db5bedf49595); /* line */ \n        coverage_0xeb9aabe7(0x02e599f911d2bea42817128c43e6e5e97b0113c14ee793788fef40fd3dac6b4b); /* statement */ \nmachine.status = MACHINE_EXTENSIVE;\r\n    }\r\n\r\n    function setErrorStop(Data memory machine) internal pure {coverage_0xeb9aabe7(0x525eb06249d8106fd8537b54beecd323b5879321b3227881bcb163ae442e965f); /* function */ \n\r\ncoverage_0xeb9aabe7(0x34f6b5d8143df0004f064000babe625b31d678d6464f28ae716a8ae79bccfc9c); /* line */ \n        coverage_0xeb9aabe7(0x0b278d43019357bd372baffc1cb7761c2fcc4711efe7ee7754bda0d591bc1e5d); /* statement */ \nmachine.status = MACHINE_ERRORSTOP;\r\n    }\r\n\r\n    function setHalt(Data memory machine) internal pure {coverage_0xeb9aabe7(0xcee4361a7382399e536f043f03bda5b6193f551b17bbf6fb23600f63bf257810); /* function */ \n\r\ncoverage_0xeb9aabe7(0xe923e49e2b1e69a7eb8579e80494f90d17741a59881d0865f6d339053ba56e70); /* line */ \n        coverage_0xeb9aabe7(0x75da2dab13d9799ed8f0b34dff21523544098b53c48cd9d90906a98e34b2c52f); /* statement */ \nmachine.status = MACHINE_HALT;\r\n    }\r\n\r\n    function addDataStackValue(Data memory machine, Value.Data memory val) internal pure {coverage_0xeb9aabe7(0xdc7254ff8c7a1cb3a6a7b72bc57bbb286fa1e5140e9f6ae9a534dd6131628da8); /* function */ \n\r\ncoverage_0xeb9aabe7(0x755f560283729e1877c6fd3737426957e3b35ff8e39c9e6290ab299ae664ff27); /* line */ \n        coverage_0xeb9aabe7(0x4a25325a385849c6ea23a7959b458080563a6a7e78eeb4df559b7b50b054ea50); /* statement */ \nmachine.dataStack = addStackVal(machine.dataStack, val);\r\n    }\r\n\r\n    function addAuxStackValue(Data memory machine, Value.Data memory val) internal pure {coverage_0xeb9aabe7(0xe30db6d49819acb14a98b63e1fd6f12f974678055b2928790fe25804b15412fa); /* function */ \n\r\ncoverage_0xeb9aabe7(0x4389261afd27dccafc5bf288f9bb0eafdba48625785f62a01d08a8d90a0e7d8b); /* line */ \n        coverage_0xeb9aabe7(0xb991124d053973c7f3f56cc0ba1094a1a645f954ef3bb153189a08a7b5ce479c); /* statement */ \nmachine.auxStack = addStackVal(machine.auxStack, val);\r\n    }\r\n\r\n    function addDataStackInt(Data memory machine, uint256 val) internal pure {coverage_0xeb9aabe7(0x32b51809cb9caa829afaee1c9b228e72818dbc673fa0d0217fa44049069bb121); /* function */ \n\r\ncoverage_0xeb9aabe7(0x734ffad39223c276d4da7c9144a4bf44b7986fcaf264483914d5ed0f4a3dd8b3); /* line */ \n        coverage_0xeb9aabe7(0x908cea4958a92da25eafb3ffaec1b16f62fc47d78e784286513670489e369fb7); /* statement */ \nmachine.dataStack = addStackVal(machine.dataStack, Value.newInt(val));\r\n    }\r\n\r\n    function machineHash(\r\n        bytes32 instructionStackHash,\r\n        Value.Data memory dataStack,\r\n        Value.Data memory auxStack,\r\n        Value.Data memory registerVal,\r\n        Value.Data memory staticVal,\r\n        uint256 arbGasRemaining,\r\n        bytes32 errHandlerHash,\r\n        Value.Data memory pendingMessage\r\n    ) internal pure returns (bytes32) {coverage_0xeb9aabe7(0x7527c31a57b884ae9285cc8ead0f8d9d437ec14a33881f424e4e2c59661793e1); /* function */ \n\r\ncoverage_0xeb9aabe7(0x276594f97ee4f72cf4709cad9dbfe4c8c8e229488dba1b55b3184b20fcd95cb4); /* line */ \n        coverage_0xeb9aabe7(0xb477cb7decbf9fef45a3e0f8b467a85000f0560c1c64dd886df90ea2f1ffd147); /* statement */ \nreturn\r\n            hash(\r\n                Data(\r\n                    instructionStackHash,\r\n                    dataStack,\r\n                    auxStack,\r\n                    registerVal,\r\n                    staticVal,\r\n                    arbGasRemaining,\r\n                    errHandlerHash,\r\n                    pendingMessage,\r\n                    MACHINE_EXTENSIVE\r\n                )\r\n            );\r\n    }\r\n\r\n    function hash(Data memory machine) internal pure returns (bytes32) {coverage_0xeb9aabe7(0xfaaee930fec70d053fdcb522155b65cb873cf4763fc907cad36a294651aad18e); /* function */ \n\r\ncoverage_0xeb9aabe7(0xa1b941f80d2b64cfea36a7d27c7a446b4236090fad53680ad70d8141f4bf5804); /* line */ \n        coverage_0xeb9aabe7(0x59a33e5580c9510fade7468e96f70b84c4dd2e6d62ef9c0988ebc8ae042b4492); /* statement */ \nif (machine.status == MACHINE_HALT) {coverage_0xeb9aabe7(0x508b303fe7e151e1117fd47e5ee9496e921477fb17836489411190449e679d90); /* branch */ \n\r\ncoverage_0xeb9aabe7(0xae11013e9ec69f4c3f04fcf8bda63d41edbc84704e49faf6fc204d23d1133fc1); /* line */ \n            coverage_0xeb9aabe7(0xaea292104a928d93f2cf910953e600fe2f5629f084e28da82c22e62334ae2280); /* statement */ \nreturn bytes32(uint256(0));\r\n        } else {coverage_0xeb9aabe7(0xb43ef0ceb20cb8e37bd30636683f1bbdd19753ed7fe5a795ad78fdc68932f545); /* statement */ \ncoverage_0xeb9aabe7(0xa2792d82978cd80f2b4b77480d4ef6c6b0faa052eccfd375cafc41611b974be0); /* branch */ \nif (machine.status == MACHINE_ERRORSTOP) {coverage_0xeb9aabe7(0xc2609f3386834e66e37794b35a5c8dee4c2b221abaaf1334eff94b0f493c3d04); /* branch */ \n\r\ncoverage_0xeb9aabe7(0xb1169075adbe834060dd54eb259452e92862b8bd1665b01283dc48de8ac42cb0); /* line */ \n            coverage_0xeb9aabe7(0x659015196ea99caa7f50dc12d8e8cf8ce59f6199590e5ce9410ba82f0964d68c); /* statement */ \nreturn bytes32(uint256(1));\r\n        } else {coverage_0xeb9aabe7(0x4b3db796891d5415e1b2ef167cd7df16b35602a8821395771930abeca2a03d26); /* branch */ \n\r\ncoverage_0xeb9aabe7(0xb5ac16584b43f9d12ded91e2531d52fa74e2a777b0fabd2118e5accc0e5d5fbf); /* line */ \n            coverage_0xeb9aabe7(0xb9bdd713c263ea9e4d76259bbb159162251bf32a580ed78a769fb61822db795c); /* statement */ \nreturn\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        machine.instructionStackHash,\r\n                        machine.dataStack.hash(),\r\n                        machine.auxStack.hash(),\r\n                        machine.registerVal.hash(),\r\n                        machine.staticVal.hash(),\r\n                        machine.arbGasRemaining,\r\n                        machine.errHandlerHash,\r\n                        machine.pendingMessage.hash()\r\n                    )\r\n                );\r\n        }}\r\n    }\r\n\r\n    function clone(Data memory machine) internal pure returns (Data memory) {coverage_0xeb9aabe7(0x376c82f15b4f978ddbfaa52c958c5b66463d46a574e0d9d58914fdadb04920ec); /* function */ \n\r\ncoverage_0xeb9aabe7(0x45a53d7dad9c2200eb75eeeccd22f351fa8088a709d879d9b1773f57ce729ce8); /* line */ \n        coverage_0xeb9aabe7(0x8f20ae819f256e775b3562873b1a190fe0b4c4efc2bdf6bb54a08b6a59df8d23); /* statement */ \nreturn\r\n            Data(\r\n                machine.instructionStackHash,\r\n                machine.dataStack,\r\n                machine.auxStack,\r\n                machine.registerVal,\r\n                machine.staticVal,\r\n                machine.arbGasRemaining,\r\n                machine.errHandlerHash,\r\n                machine.pendingMessage,\r\n                machine.status\r\n            );\r\n    }\r\n\r\n    function deserializeMachine(bytes memory data, uint256 offset)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256, // offset\r\n            Data memory // machine\r\n        )\r\n    {coverage_0xeb9aabe7(0xb6122bae5d304d3d2f70775919476f82ea083bfff32d13d46d52d72dece732b0); /* function */ \n\r\ncoverage_0xeb9aabe7(0x23cb18f7d16feacecef2582e4bd1ce6789b500138eb92f2e9829fe7d87d0c5b5); /* line */ \n        coverage_0xeb9aabe7(0x752fe58c6c45ea793bf4ca3884d09983e0de9da592efb8b41ada8be51d905f07); /* statement */ \nData memory m;\r\ncoverage_0xeb9aabe7(0x71c9433c5f18e447d867e4659ec07efa5d1ec0ade899b1a59d94339123ceea49); /* line */ \n        coverage_0xeb9aabe7(0xb47ed0228a05a3258d396ea2f38ce84b358ae63e7b2b3b3e238565fae9f7d58f); /* statement */ \nm.status = MACHINE_EXTENSIVE;\r\ncoverage_0xeb9aabe7(0x44122bdd1a447824c4ef8c31b3a8d1a9a5be399cad2525996b236205f95a121b); /* line */ \n        coverage_0xeb9aabe7(0x0918cd2bc70ac2d63fd00fe8be94e566ab301c8891aa490a389c502c9f86723c); /* statement */ \nuint256 instructionStack;\r\ncoverage_0xeb9aabe7(0x2cd734b6bd038ce4107db7fe0bd71ae2145d295bc83b1dc5eb57d6be25a77603); /* line */ \n        coverage_0xeb9aabe7(0x161070ff59e571d581dcca6d098922c7760d953e6b0ce4a38e852d08a8c8bb6a); /* statement */ \nuint256 errHandler;\r\ncoverage_0xeb9aabe7(0x5fedc8255c60cdc269a181153bfa3629efa46d765e011578f6a972b21d4a1024); /* line */ \n        coverage_0xeb9aabe7(0x341c7889d01c479c4b2378ec2e74abe5146c6bbd170dcb79c4964a3542c1410e); /* statement */ \n(offset, instructionStack) = Marshaling.deserializeInt(data, offset);\r\n\r\ncoverage_0xeb9aabe7(0xa0bac3eac466e81cfd7a6cef380453a581e6b09b8a2f3cbfffb0d61b3cf08739); /* line */ \n        coverage_0xeb9aabe7(0x52b426c88760b362480ec6e61dee9c9378bedec6ce4a4f974223fceeb8a5106f); /* statement */ \n(offset, m.dataStack) = Marshaling.deserializeHashPreImage(data, offset);\r\ncoverage_0xeb9aabe7(0x4ab091b13e6fb8483ef079cc6e15ec6645309a0844550833ecb004dada4f70fd); /* line */ \n        coverage_0xeb9aabe7(0x50efd1bb3c9f9bc68192f5f82a6f1a7c2d1a1f72f8411ce2223323a404eda04b); /* statement */ \n(offset, m.auxStack) = Marshaling.deserializeHashPreImage(data, offset);\r\ncoverage_0xeb9aabe7(0x7656196aed62dd5f41ec51ad6263a242bcf5fdf143aaaa2afb4847f338a94a6a); /* line */ \n        coverage_0xeb9aabe7(0x89c65c7fe8fe55d042cfcc15cad6c7585a816ff2162b003d4d57baa24e66ba14); /* statement */ \n(offset, m.registerVal) = Marshaling.deserialize(data, offset);\r\ncoverage_0xeb9aabe7(0x551aa4228bc535943f288574a42efa8cbf19c0a532708df31bc65a26925c78f4); /* line */ \n        coverage_0xeb9aabe7(0x6093e0193579f06420e84074376fa1dfaaf002460d57ee482e1d4366142d25b0); /* statement */ \n(offset, m.staticVal) = Marshaling.deserialize(data, offset);\r\ncoverage_0xeb9aabe7(0x49f3143209e5246af3c2b86f452ebaa5abe156820085531eb2c561aa69e12d3a); /* line */ \n        coverage_0xeb9aabe7(0xbf55cf8a0d569e61706f69383e2c3e1923bc66741211a66e5456acfe0d08216d); /* statement */ \n(offset, m.arbGasRemaining) = Marshaling.deserializeInt(data, offset);\r\ncoverage_0xeb9aabe7(0x4114e36c15a03909dab9e27026d066501519a91de3f3ce114edc06f10472472e); /* line */ \n        coverage_0xeb9aabe7(0x8fedd69c1eb76769c2500fb3d17bc15a41e028b4a0da7fc8b772b41562c52f55); /* statement */ \n(offset, errHandler) = Marshaling.deserializeInt(data, offset);\r\ncoverage_0xeb9aabe7(0x776e1649a106d87a42be518d9b83a01ae1522373ce655d3712e9d34d5d4b4723); /* line */ \n        coverage_0xeb9aabe7(0xa2035d48f145d790eae1a1db9fde4fca08f92294f06da623f343c65e0b4a7f8b); /* statement */ \n(offset, m.pendingMessage) = Marshaling.deserialize(data, offset);\r\n\r\ncoverage_0xeb9aabe7(0xdb54e1e38261fbe0d5fdf0b7fbd42542fa72890455a052f050c10f11b0091572); /* line */ \n        coverage_0xeb9aabe7(0x9b755527bcd6ee3ccc6e9d5d21325ae4e5662c7c7ba02494c332a97bcaad52d7); /* statement */ \nm.instructionStackHash = bytes32(instructionStack);\r\ncoverage_0xeb9aabe7(0x0b10b44a50ffd326a9f4f70f7e51215ea1412eda116432ca698df213ae7a3a35); /* line */ \n        coverage_0xeb9aabe7(0x6bc37e12450205e2e0118491fc5425154725d5fc3d85a6ea97a4bfa34b3b01a7); /* statement */ \nm.errHandlerHash = bytes32(errHandler);\r\ncoverage_0xeb9aabe7(0xa42e45f85af03c37ff1136f8eb938ca3021e7c8b2927e100dbfbba82a32b684e); /* line */ \n        coverage_0xeb9aabe7(0x514e3a90a81a75ec92886aca17c5e99da2714ca097dea2023071c2ddf35bef0d); /* statement */ \nreturn (offset, m);\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/arch/Marshaling.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"./Value.sol\";\r\nimport \"./Hashing.sol\";\r\n\r\nimport \"../libraries/BytesLib.sol\";\r\n\r\nlibrary Marshaling {\nfunction coverage_0x914c86c7(bytes32 c__0x914c86c7) public pure {}\n\r\n    using BytesLib for bytes;\r\n    using Value for Value.Data;\r\n\r\n    function deserializeHashPreImage(bytes memory data, uint256 startOffset)\r\n        internal\r\n        pure\r\n        returns (uint256 offset, Value.Data memory value)\r\n    {coverage_0x914c86c7(0x5d2b4ee3ffa2910c97d4f898bb59994098cefbdc0e928a1f656a7c0c466f0bf4); /* function */ \n\r\ncoverage_0x914c86c7(0xfecbf0d01e97079d10547f71f2a6540ceb8fb2b1d86cef71d9cd89fba973dbd8); /* line */ \n        coverage_0x914c86c7(0x4440a6de63f11c694dde7743c9d9fc3d3d322103985ab3ccdf163b4650069491); /* assertPre */ \ncoverage_0x914c86c7(0xeb7996433ed4e54ac06211af7a74c8bb65d5b8bad52694242545a591c2a57362); /* statement */ \nrequire(data.length >= startOffset && data.length - startOffset >= 64, \"to short\");coverage_0x914c86c7(0xa747a04c2c8bc4b340839e92a00de1416c5c789d70294ca37cb564059fb94506); /* assertPost */ \n\r\ncoverage_0x914c86c7(0x87ccf8df13c41d509479c850580d4a43860e882558a41f30786fbd80186c8c67); /* line */ \n        coverage_0x914c86c7(0xf497e3a48441fc2cbf81b696cd9ad1b2111227f59b81faf4cf4b0ad705c8bd50); /* statement */ \nbytes32 hashData;\r\ncoverage_0x914c86c7(0x55d8c92a38a0ba828cfe172593a3faba96c382c8ea3403a964573ac7661e7044); /* line */ \n        coverage_0x914c86c7(0x3293eca8ae075719d9d0dbefe3c1942de0bb6febb1dee97b15e28563e70787f4); /* statement */ \nuint256 size;\r\ncoverage_0x914c86c7(0x882840d9a24888ea8f6aab253d4b97a2c6df1c9a6cc599f06f1bd6e302c0a490); /* line */ \n        coverage_0x914c86c7(0x188a42b8656d09c2296c63dd551d65f75b6986dcafba2276271fbd224d5cbc6c); /* statement */ \n(offset, hashData) = extractBytes32(data, startOffset);\r\ncoverage_0x914c86c7(0xfd515a169f98a83e4398b2f32c91ed11b6c152ce6082d1e50f8ef3030df24190); /* line */ \n        coverage_0x914c86c7(0x28187d7dc6483bbfc142469178202d6f0c3aa0aea9d54cb2c8679f49a5cc174b); /* statement */ \n(offset, size) = deserializeInt(data, offset);\r\ncoverage_0x914c86c7(0x9a14bbd1f86787abde7ac8451780fbc73b235f4c0575b47dd27aad1b89b568b4); /* line */ \n        coverage_0x914c86c7(0x9ae85667b30e01c60a45422ef876b6cbe7896995ecf33121d98241620b9179f7); /* statement */ \nreturn (offset, Value.newTuplePreImage(hashData, size));\r\n    }\r\n\r\n    function deserializeInt(bytes memory data, uint256 startOffset)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256, // offset\r\n            uint256 // val\r\n        )\r\n    {coverage_0x914c86c7(0xbddfafaf8b9ba7e36e7e38ed84eafff38a47473c391a1eebc40b24c81f8b2a0c); /* function */ \n\r\ncoverage_0x914c86c7(0x6440d0ec2673687d6c31e766b50a44e8e9171086d939ebcb77c90860c0184ae6); /* line */ \n        coverage_0x914c86c7(0x53d7444c453f3f1a1cf1ea992ba73a743773e82c7e3e93802a9c1b4f68227121); /* assertPre */ \ncoverage_0x914c86c7(0xa07fe0bfff175e27fd3a2157ff3ff78041c65fc7393a5ced6dc3b0244e6bc597); /* statement */ \nrequire(data.length >= startOffset && data.length - startOffset >= 32, \"too short\");coverage_0x914c86c7(0x6a86693408847729d8c1b5f8e288fc3f1f47204aad669e043dcc145f53bc4da5); /* assertPost */ \n\r\ncoverage_0x914c86c7(0xe88f82c3f2048bcd6e1e57f98ae4d601f15e101efbcbe00b0db9d75e5ba130fb); /* line */ \n        coverage_0x914c86c7(0xc6b343785a0e7441a24650c9d1df18b19841ded4b3c2e61ca886a4577fb11272); /* statement */ \nreturn (startOffset + 32, data.toUint(startOffset));\r\n    }\r\n\r\n    function deserializeCheckedInt(bytes memory data, uint256 startOffset)\r\n        internal\r\n        pure\r\n        returns (\r\n            bool, // valid\r\n            uint256, // offset\r\n            uint256 // val\r\n        )\r\n    {coverage_0x914c86c7(0x3a2e04e44ebd5381d44efa26046a84323484515eefd8e4dbcfbece9743b0ab2a); /* function */ \n\r\ncoverage_0x914c86c7(0xe5ee89f1997df038efa0d29fa75de07c023334084b2258cee1cc20319d31f6f1); /* line */ \n        coverage_0x914c86c7(0x64f46d8ddada96259de3354a307dceb15340fd8efcd4789cf95dea4712bbe518); /* statement */ \nuint256 totalLength = data.length;\r\ncoverage_0x914c86c7(0xf9c870e293bdd7c791d29c26dce9f5095474a6f5436c010d50005041e45f3012); /* line */ \n        coverage_0x914c86c7(0xe974ef8a687baaf61a1e015c949b75eb0aa92377fdd27c0ff93656ccdde046b2); /* statement */ \nif (\r\n            totalLength < startOffset ||\r\n            totalLength - startOffset < 33 ||\r\n            uint8(data[startOffset]) != Value.intTypeCode()\r\n        ) {coverage_0x914c86c7(0x5a2e361b574a80a8daa482d749a9684e66084a4e70a28982de853e65ca18d00a); /* branch */ \n\r\ncoverage_0x914c86c7(0x8967a9262ded1143b0a587d5e74deeeb4340a8c32dc5cf2237c79ec9f7ffd223); /* line */ \n            coverage_0x914c86c7(0x99541a524f32f1645e818c931858245f74a8156a8e23f873fd85216e12fa7b69); /* statement */ \nreturn (false, startOffset, 0);\r\n        }else { coverage_0x914c86c7(0xcd7231e2081806b7527c90abb313e9f444808b93a75e9d0410ac7c55d73a87b1); /* branch */ \n}\r\ncoverage_0x914c86c7(0x4568ff41dec9482b0fa9e135d73909d8edbaad0899682591d5660e9b97b00cd6); /* line */ \n        coverage_0x914c86c7(0x12a00c449da6d140834499ee332ef7e5d3df4cffb83209109bf476039858feab); /* statement */ \nreturn (true, startOffset + 33, data.toUint(startOffset + 1));\r\n    }\r\n\r\n    function deserializeCodePoint(bytes memory data, uint256 startOffset)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256, // offset\r\n            Value.Data memory // val\r\n        )\r\n    {coverage_0x914c86c7(0x4f76f0cfe3adfb4c8b606bfa768ea390f90bbee8167148d17d966c2161b10865); /* function */ \n\r\ncoverage_0x914c86c7(0x9233d5c464e8de56b89126e83d7ef6db44f3dc0d21571cbc70e1a98f99608f9a); /* line */ \n        coverage_0x914c86c7(0x5c51710627e1c0a19058eb37d007a6dacbe1e0fbd616f1858019c77a82152704); /* statement */ \nuint256 offset = startOffset;\r\ncoverage_0x914c86c7(0xcb91e95fffa39ccb2fd21af9c66bad115690ed3de4d3622e784daada53198c3b); /* line */ \n        coverage_0x914c86c7(0xc7f7a5005eeb086875fde8cec191cddef3387b6131cb3efb1fd4c414bc74e53c); /* statement */ \nuint8 immediateType;\r\ncoverage_0x914c86c7(0x6f7cb935f8aeac79f5969dcdd18e07b149104bc31b7aa10ca9ba337942babc56); /* line */ \n        coverage_0x914c86c7(0x9a3bf9a5ed448b45fd182c78a87fd56774753a9fc803b261bd9b3efec4c52804); /* statement */ \nuint8 opCode;\r\ncoverage_0x914c86c7(0x7696000bbcc6e74fa7cff1ba773e9b4a9ecc06ed567f43807766401136770c4c); /* line */ \n        coverage_0x914c86c7(0x7447526b3822e42dc64edf9afdef775545f8f131e22fec0efcd1c3dd044619f5); /* statement */ \nValue.Data memory immediate;\r\ncoverage_0x914c86c7(0x6512b83c5fa7437f3c9f37c331e568faa932ebe35aed13879b199b69d2797dfa); /* line */ \n        coverage_0x914c86c7(0x78355ca423d26b259237ffe28092f2d2871ac480fe5b70a728f2c4cc07882aef); /* statement */ \nbytes32 nextHash;\r\n\r\ncoverage_0x914c86c7(0x3c7c61c25c1ec166f81918622efebd33d8ab803434431f8ee7c12df3ca0d16fb); /* line */ \n        coverage_0x914c86c7(0xcdd5b89c5303765b706ba66f2462d74c36a2147b5d8f0eae201cef6817999e61); /* statement */ \n(offset, immediateType) = extractUint8(data, offset);\r\ncoverage_0x914c86c7(0xfd8ed237acba414bbe8689c3f9045bf1629b716ce801b17b4b1ebda196d27e04); /* line */ \n        coverage_0x914c86c7(0xe02080fd71b61364e8f291b4486c9e395cce17f6c6c44fd0e847f69007e27aa8); /* statement */ \n(offset, opCode) = extractUint8(data, offset);\r\ncoverage_0x914c86c7(0xdf50ceef217f9fd84529724a48591eb2f6e4cb442bc761f1240ee284f0f6b485); /* line */ \n        coverage_0x914c86c7(0xdc8adc19219c47ed2fddae6e8b9ef5a557a43769f24489487253abd06b92da93); /* statement */ \nif (immediateType == 1) {coverage_0x914c86c7(0x2226b245ab689f50f9e9a8fe7a873ad22e7be41f627b0dfd17eb1b69c9597766); /* branch */ \n\r\ncoverage_0x914c86c7(0x6026c1297b4159ecc523d590f5c35495a0b085d7ca4ea5d55e8b6aa98079613b); /* line */ \n            coverage_0x914c86c7(0x6c05f31b70c36c58cdb715c22e226b7623e9f5bdb13c6970972fc43ff5ceed08); /* statement */ \n(offset, immediate) = deserialize(data, offset);\r\n        }else { coverage_0x914c86c7(0x7ee0b8238b3090f2e551b9fa95d37efbc7f5c05bbfb8b2e50096137984543f2a); /* branch */ \n}\r\ncoverage_0x914c86c7(0x26eb012445f60e9379695b1dd16ca7f2480b809e32dfec6f737d78bf47415abc); /* line */ \n        coverage_0x914c86c7(0xe609241b1d6ea1bfdbf1b9bd858c08f6df302ccc95103168dd9ab2063b02d5f9); /* statement */ \n(offset, nextHash) = extractBytes32(data, offset);\r\ncoverage_0x914c86c7(0xda02fd8a8913d187998aaf395af8dd42bb167c915921f403d2b07cd2e1956244); /* line */ \n        coverage_0x914c86c7(0x04a68661db18a7e841052693b1b57af3f266c0010cf4f3f3491dba35a4928652); /* statement */ \nif (immediateType == 1) {coverage_0x914c86c7(0xb7f522b51d9528ad04984bd1514298c8db192f17f669a16fe5a619243dc20eaf); /* branch */ \n\r\ncoverage_0x914c86c7(0x5a4c801b845882db7cd7eefc99408b84b08885470cda3c897b0a9c43ccb5de2a); /* line */ \n            coverage_0x914c86c7(0x320f3fe264e7f14462be98b1f4c8a7c7ee539ab21fc529514bd4c93253b55e6d); /* statement */ \nreturn (offset, Value.newCodePoint(opCode, nextHash, immediate));\r\n        }else { coverage_0x914c86c7(0xa5cd5213e69844f9a169a09ab2b8180749f3344d9c2aede8f913879c505cdb4b); /* branch */ \n}\r\ncoverage_0x914c86c7(0x5cc0f7738dfe45c85185d2d4af185946e482dbf821b71237e03a191c4031e532); /* line */ \n        coverage_0x914c86c7(0x1da9f07a9c6e59428afba9321b9fedb4771aecc41da7ad0f27eb743e2af8a8c1); /* statement */ \nreturn (offset, Value.newCodePoint(opCode, nextHash));\r\n    }\r\n\r\n    function deserializeTuple(\r\n        uint8 memberCount,\r\n        bytes memory data,\r\n        uint256 startOffset\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256, // offset\r\n            Value.Data[] memory // val\r\n        )\r\n    {coverage_0x914c86c7(0xda107d784de9d15d215de3e719758fae5c8dc092adfa2612e00b389fa9cc2fbf); /* function */ \n\r\ncoverage_0x914c86c7(0x27c73ddbffd6edf5cee79195dc04bf44c1d079e04041dfbb494b7da6c95c6535); /* line */ \n        coverage_0x914c86c7(0x5559a3c974acecd48a121832b7d422916a11ce344653597630dd9b52028fd933); /* statement */ \nuint256 offset = startOffset;\r\ncoverage_0x914c86c7(0x8158719e781040ba0e50b9e13a8add9c21e8dcb8ae72de829d519f47e6fdc85c); /* line */ \n        coverage_0x914c86c7(0x647bff00bbe1a122287ac1a91e86f69d8b199bc82866662414279e6ab78028fe); /* statement */ \nValue.Data[] memory members = new Value.Data[](memberCount);\r\ncoverage_0x914c86c7(0xc8894b19b3eade0157ef9eaefd4e4d2082f571162aa09c2350f14523f3eb217d); /* line */ \n        coverage_0x914c86c7(0x82db8aa567ec5c86994eb4365ec775d069398610f92e0e1e71eb7e591b61c30e); /* statement */ \nfor (uint8 i = 0; i < memberCount; i++) {\r\ncoverage_0x914c86c7(0x5136485d3dc29af555c628020cfda3f735c4d6bf256aa3c2124816fb40221207); /* line */ \n            coverage_0x914c86c7(0xe090720a41ce9477ac3051d8844225f53ad68749f28d0012ba32b8adf34bdad3); /* statement */ \n(offset, members[i]) = deserialize(data, offset);\r\n        }\r\ncoverage_0x914c86c7(0xe7233e32da4178664547e94da3cc1ed3f4881eeec353ecedd3c76034188f08f6); /* line */ \n        coverage_0x914c86c7(0x1ba6e9069e847ec9b793e8edcbbd1170095925e72a649569f0dd973f9841122a); /* statement */ \nreturn (offset, members);\r\n    }\r\n\r\n    function deserialize(bytes memory data, uint256 startOffset)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256, // offset\r\n            Value.Data memory // val\r\n        )\r\n    {coverage_0x914c86c7(0x96134c7e48ce3e62c435668d8ad04c23130780df705d7ed4519278f3c811c48e); /* function */ \n\r\ncoverage_0x914c86c7(0x2f4c3ae9e69092d0ba7b9b72bdef744b9002161c486a5a7a2571d034279233a5); /* line */ \n        coverage_0x914c86c7(0x3632d3e92e0c4daba33345c014aa7c1de8fa88ec6dbcaf5be9dad453741ef88c); /* assertPre */ \ncoverage_0x914c86c7(0xb7dc5602341d0b1e0c6cf69f2bceb0f9d2d86552590eded3469b7dafed51b166); /* statement */ \nrequire(startOffset < data.length, \"invalid offset\");coverage_0x914c86c7(0x88cc66f035214764f9cab3dab4aaf7f3304d158aaf3635ab0e4f26fb3454f498); /* assertPost */ \n\r\ncoverage_0x914c86c7(0x44c7b43ff3ee090b190951671b2b8fc4efb601f13b3f8c3d33ec9472fc00069d); /* line */ \n        coverage_0x914c86c7(0xe2871aa626289f44da1d3d453e93e0dd2217ec19e87f28f10112f8a26183bd09); /* statement */ \n(uint256 offset, uint8 valType) = extractUint8(data, startOffset);\r\ncoverage_0x914c86c7(0x00266620a02615cdf87ee31f5e2eaa702024233e571a25f4f7a8b54918480d11); /* line */ \n        coverage_0x914c86c7(0xee8bb414d21551777d8fcd9f79d59d2506f5be91173ea20526257dbd863d1162); /* statement */ \nif (valType == Value.intTypeCode()) {coverage_0x914c86c7(0x32456a43f97fef296b15df6c07520fcd7223a6b6bdf0914a8f37725c7224c3ee); /* branch */ \n\r\ncoverage_0x914c86c7(0x97f4f19f0042d6ac91e2987e29c8b23c8293bf908b285b9b1c9ff99877d72892); /* line */ \n            coverage_0x914c86c7(0x5942264c1ae37f53dd213de79ebebaf83af850c285df2316543d1e36d321f4b8); /* statement */ \nuint256 intVal;\r\ncoverage_0x914c86c7(0xdcf62e0b14dbd4363c258ec28b109e47d85b48811f9402a31b7fb593863d8fe9); /* line */ \n            coverage_0x914c86c7(0x22484701a188885193b18847e67eb46f6dfcf5b2793a178fecad7813b3369a58); /* statement */ \n(offset, intVal) = deserializeInt(data, offset);\r\ncoverage_0x914c86c7(0x2bd59c3a29d3915183d9dc9e255038fe5eb8e3d77b3f9c95b40f64a7c26262a3); /* line */ \n            coverage_0x914c86c7(0x90f179ed815978084dfe0f11c1c8ca0ecc5c4f9434ce17b7072959ff947abb9e); /* statement */ \nreturn (offset, Value.newInt(intVal));\r\n        } else {coverage_0x914c86c7(0xc1b6ccbc7322174004014c758230cfc27129483efb6ce446c3af4ddb72fd9a22); /* statement */ \ncoverage_0x914c86c7(0x863cc60f50964caa3e71112e5683b9dd38d357175ae44eda9c56b0c4cb2cf689); /* branch */ \nif (valType == Value.codePointTypeCode()) {coverage_0x914c86c7(0x9b978f53ef27ed6178059b3c57a7211c9829f93d60315d75e99ca620aab1ef14); /* branch */ \n\r\ncoverage_0x914c86c7(0xe23a319cc6ad18807e7d1070c3ad871c76d74fb19e570ae8fa385260e2bd60e6); /* line */ \n            coverage_0x914c86c7(0xff41ff8605d22a4d3172367b0b0bdc44581adf60984ed7087eba9a2d09d56e6f); /* statement */ \nreturn deserializeCodePoint(data, offset);\r\n        } else {coverage_0x914c86c7(0x6b7456e63eb69c165305ddfdb88d81518921490bb3ccf248fb64dea2f0cb1ce5); /* statement */ \ncoverage_0x914c86c7(0x75dbfaf76c3c86fb6055eae337a27734e4e1d963089b354fde80bb7509b07094); /* branch */ \nif (valType == Value.tuplePreImageTypeCode()) {coverage_0x914c86c7(0x4ba8fae7d31e1f02e5a5de6ac30c1bff57a6633ca9a31c01db05c94012248fa2); /* branch */ \n\r\ncoverage_0x914c86c7(0x3f43aee141443da4fcf87f57548df3464b95f5f6322662fb15bb9b85c174b13d); /* line */ \n            coverage_0x914c86c7(0xda7d6c62e6360993f19ccce1f0ccbed0e773b1e61e20d76f5ba6d6ad6f44a367); /* statement */ \nreturn deserializeHashPreImage(data, offset);\r\n        } else {coverage_0x914c86c7(0x7738528c42cc68a0fe0a4533f2a5bf236c9018e697dcf8aa5c473ca099d19f39); /* statement */ \ncoverage_0x914c86c7(0x0be2b9275d74ef2a482fbf40ad4f001bf19ef22e9f669be2fbdef911e8d51f22); /* branch */ \nif (valType >= Value.tupleTypeCode() && valType < Value.valueTypeCode()) {coverage_0x914c86c7(0x7228cdf958d6261cf7e806fae9b5f1b53d57482024e045ee6974f18e0cb34173); /* branch */ \n\r\ncoverage_0x914c86c7(0xeb6198b1baad5b63b6a3592eeb0e32263dad3ba9da894c1f8ef225691d0fc663); /* line */ \n            coverage_0x914c86c7(0x87329f988ae80c5afe4cb4967e5d09313d455da4efc0eb69e063c7478fd259d2); /* statement */ \nuint8 tupLength = uint8(valType - Value.tupleTypeCode());\r\ncoverage_0x914c86c7(0xc2753279413e3636ff623524c8d36fde806150db1d1ed1f32f95a91a4eb3205d); /* line */ \n            coverage_0x914c86c7(0xd0e00a606c2a56ededf8f38579e2a99be518b17d2cc13e95165fcf72d1cf428e); /* statement */ \nValue.Data[] memory tupleVal;\r\ncoverage_0x914c86c7(0x0894e72758509fb01570e4f21c9a9facc30309a2810534444ffe4ca370cf0423); /* line */ \n            coverage_0x914c86c7(0x117512ba6ce556a71f73ffe9e3f92b3064e0e317525a064dd3e7154d0569c02a); /* statement */ \n(offset, tupleVal) = deserializeTuple(tupLength, data, offset);\r\ncoverage_0x914c86c7(0xc23cdfc31692117b6861d0f0c3244eda6067d6eb71e9116de1607b4be267d580); /* line */ \n            coverage_0x914c86c7(0x3c98aae324b94155b70f5737b57faa5d85deae3f24cc6b48f07906d6e67b19a9); /* statement */ \nreturn (offset, Value.newTuple(tupleVal));\r\n        }else { coverage_0x914c86c7(0xed57e7898d8e68d2bdbf8e7a5d84cafdf4235e6d002853c971cb394225b11d83); /* branch */ \n}}}}\r\ncoverage_0x914c86c7(0xe259fc2b8fbd128dcef61a5121b90191e61f5f53ee9e52b55715c583345ca1a1); /* line */ \n        coverage_0x914c86c7(0x77c9781fe1dab40ed666cc7f95e008707372702458dc0188e806026303ce060a); /* assertPre */ \ncoverage_0x914c86c7(0xa3b99741d5c22702a382eee1c03bc84f542f6b9718b5d1efe98b6e0bdcf04172); /* statement */ \nrequire(false, \"invalid typecode\");coverage_0x914c86c7(0xbe5008904313c5608b52765e817ce854a336004d725f1575dfb8e5a3cde473e8); /* assertPost */ \n\r\n    }\r\n\r\n    /**\r\n     * @notice Convert data[startOffset:startOffset + dataLength] into an Arbitrum bytestack value\r\n     * @dev The bytestack object is a series of nested 2 tuples terminating in an empty tuple, ex. (size, (data1, (data2, (data3, ()))))\r\n     * @param data Data object containing a superset of the data we want to serialize\r\n     * @param startOffset Offset in data where the data we want to convert beings\r\n     * @param dataLength Number of bytes that we want to include in the bytestack result\r\n     */\r\n    function bytesToBytestack(\r\n        bytes memory data,\r\n        uint256 startOffset,\r\n        uint256 dataLength\r\n    ) internal pure returns (Value.Data memory) {coverage_0x914c86c7(0x8a8f52173bd5286763ea1bbfc1fd6fea99255d81e5e580e8520c220b6bde1039); /* function */ \n\r\ncoverage_0x914c86c7(0x1ca4c5811e487718c0b6caf71b2fcf81fc507640be26dd3453194b6a56adc2fc); /* line */ \n        coverage_0x914c86c7(0x47a492c13c30dc610f672d4a4ce5270723d076a01baf0520d5016f519815e27c); /* statement */ \nuint256 wholeChunkCount = dataLength / 32;\r\n\r\n        // tuple code + size + (for each chunk tuple code + chunk val) + empty tuple code\r\ncoverage_0x914c86c7(0xd9a46018e14e854fe1f2dc9587058e935780bca0d1a686459221b6b5d7126fc6); /* line */ \n        coverage_0x914c86c7(0xbcc364b127f7b13da2548ccdf67998de73cdc87ab814efcfe4f7856384b93ab4); /* statement */ \nValue.Data memory stack = Value.newEmptyTuple();\r\ncoverage_0x914c86c7(0x56ecbcc8e1f5f1662bdfdae78945baa2b556ef88e009e2e7777ac7b6860212e9); /* line */ \n        coverage_0x914c86c7(0x5fd3af32da396b159ead7e1a64307d73e3c708da1a7c155e20c8a7786299f357); /* statement */ \nValue.Data[] memory vals = new Value.Data[](2);\r\n\r\n        // Break each full chunk of the data into 32 byte ints an interatively construct nested tuples including the data\r\ncoverage_0x914c86c7(0x554b87eb98ecf13e58c1328b483532aa28cd1aafdeb45529e8394eba23905a0d); /* line */ \n        coverage_0x914c86c7(0xbbfe6fbd98e22d5baa41459fdf7998ac3ca8e2a8e06e948f56b1c5c651d08b1f); /* statement */ \nfor (uint256 i = 0; i < wholeChunkCount; i++) {\r\ncoverage_0x914c86c7(0xfd081966bf4a5fa8495791ffe5abd0035be07228fd442d44bf364c318c21acca); /* line */ \n            coverage_0x914c86c7(0x34762dd3a83daef68870cfc639aaa91123e66538f391f99efe457dbc71713e7b); /* statement */ \nvals[0] = Value.newInt(data.toUint(startOffset + i * 32));\r\ncoverage_0x914c86c7(0x7f92c2d5498e7f526d1870e1df130de3a31f8601cded2c4fa8fa2b946c9a0d28); /* line */ \n            coverage_0x914c86c7(0x5b8628f3c8183a99b7acb1083fc8fe999b7b25921c61c73c4811487f4f28fc50); /* statement */ \nvals[1] = stack;\r\ncoverage_0x914c86c7(0x480d1cf33e398dbb448e5ae2ed1169598876061a83affdfd34b332fbf28c6399); /* line */ \n            coverage_0x914c86c7(0x3b6d8b0784e6bcd0b7f77e7c81aa0ea36f4f9a10d56adb820bc024996cc96644); /* statement */ \nstack = Hashing.getTuplePreImage(vals);\r\n        }\r\n\r\n        // If the data didn't evenly divide into chunks. We take the remaining data and add it to the bytestack\r\ncoverage_0x914c86c7(0x3fbb456d2ac508b4da378bb36faa06860344a6ccf33b8afad804e8bbe9730ff5); /* line */ \n        coverage_0x914c86c7(0x70bb6ae5dce72beb52b3eb5ebac6d3f4acf01443d55d422ce20db04f5e64ec49); /* statement */ \nif (dataLength % 32 != 0) {coverage_0x914c86c7(0x3d9d5ac85efa45a7646041366fb147ae759401e0de864432fd57032a84c4f2b4); /* branch */ \n\r\n            // Grab the last 32 byte of the data and then shift it over to get only the relevent value. This way we avoid reading beyond the end of the data\r\ncoverage_0x914c86c7(0x3484a58f1f40e0cd9396acf92a9c287ac19eb132c461e447e8ce51a29ce9bb91); /* line */ \n            coverage_0x914c86c7(0x31f7d1c0518a23f7f85894bd46f4d488ca2cb1f2512bbad3f2e762376ebc3c4a); /* statement */ \nuint256 lastVal = data.toUint(startOffset + dataLength - 32);\r\ncoverage_0x914c86c7(0x09bff45ac2296d38991d9e4974db77e79b4f3dc86b831d41d2f8357d4d6a5737); /* line */ \n            coverage_0x914c86c7(0x1d21019858fd2c09602b2554d523289b1b742452b8e6a0535c0cd696b90eeea9); /* statement */ \nlastVal <<= (32 - (dataLength % 32)) * 8;\r\ncoverage_0x914c86c7(0x2fc6242d82424df453cf4690934b5570e2c8dd11dde5025c838e1dcac4d6aaa0); /* line */ \n            coverage_0x914c86c7(0xccba459313d7dcc1de39c63051a681a2bf918be77e622fa3c1a496c7b0c47684); /* statement */ \nvals[0] = Value.newInt(lastVal);\r\ncoverage_0x914c86c7(0x450e428c695d48fc476b333db373723ac636b81d0775c1e84daea42b6a5d8001); /* line */ \n            coverage_0x914c86c7(0xd6f816daea48d1ef91031b88d9ec06167373096722cbc5f8e323de536fc9bab6); /* statement */ \nvals[1] = stack;\r\ncoverage_0x914c86c7(0x31e31a2a562172811f1665647333ea0059783a28d939813a1c4312fd69cd00ec); /* line */ \n            coverage_0x914c86c7(0x8be0c9c78b5e3e75826560015375ec25c22bd6570ad054511eb2844fd45a97c5); /* statement */ \nstack = Hashing.getTuplePreImage(vals);\r\n        }else { coverage_0x914c86c7(0x4dbe327ecd0c5ddf553e03d6fd6e8a51b6f4fc71b13d1f878256b1741706253d); /* branch */ \n}\r\n\r\n        // Include the length of the included data at the top level of the tuple stack\r\ncoverage_0x914c86c7(0x4323539f93064befefd45b018060f72479aa592353f3839b4725edb49896df4b); /* line */ \n        coverage_0x914c86c7(0x0bd0f53f94c8714654bb3f1a13dcf001f689f0f1f186a92e19ef75a1d27c6797); /* statement */ \nvals[0] = Value.newInt(dataLength);\r\ncoverage_0x914c86c7(0xfd22cd6ebbe91d49f13564943e788f99a82a1d1ae30155bbefc7a74d2f8c6875); /* line */ \n        coverage_0x914c86c7(0xd664a05eaf72cd425f6f46d8efb70dfda3d064fdce29987bf95b109a63452482); /* statement */ \nvals[1] = stack;\r\n\r\ncoverage_0x914c86c7(0x6864c0fd2a1bdaaad8e9ec5c09e50aa1f30ff2182ea073541e0e0f4c7794cd28); /* line */ \n        coverage_0x914c86c7(0x2bd956a019c07ae7fafda8c1ce4e0fecaa0bdc4503c1e652004646dc5d621afc); /* statement */ \nreturn Hashing.getTuplePreImage(vals);\r\n    }\r\n\r\n    /**\r\n     * @notice If the data passed to this function is a valid bytestack object, return the convertion of it to raw bytes form. Otherwise return that it was invalid.\r\n     * @dev The bytestack format is described in the documentation of bytesToBytestack\r\n     * @param data Data object containing the potential serialized bytestack value\r\n     * @param startOffset Offset in data where the bytestack is claimed to begin\r\n     */\r\n    function bytestackToBytes(bytes memory data, uint256 startOffset)\r\n        internal\r\n        pure\r\n        returns (\r\n            bool valid,\r\n            uint256 offset,\r\n            bytes memory byteData\r\n        )\r\n    {coverage_0x914c86c7(0x446a35cb973ee13e8e9da4c4df8a3078cba8c839aa5e7a38418f7f9d9457dba0); /* function */ \n\r\n        // Bytestack should start with the size in bytes of the contained data\r\ncoverage_0x914c86c7(0x320e5e5c29ec8ddc674865dc9edc205fab85bdda34f259ef42e68ad57fe7a1fd); /* line */ \n        coverage_0x914c86c7(0xb5bb903a3d2dc8bd3b0b24ee94c1f964fe1fd852c2932bbfcd95b0b1f635d70b); /* statement */ \nuint256 byteCount;\r\ncoverage_0x914c86c7(0xbf679a482c0555fddaebfc6e34745ec53a5059f9b9d3c0acfe35582ee04bcc52); /* line */ \n        coverage_0x914c86c7(0x466ed379ca91e99f3dd5040349c67bee56f0af497392a9afc2f22c1b7d2ba20b); /* statement */ \n(valid, offset, byteCount) = parseBytestackChunk(data, startOffset);\r\ncoverage_0x914c86c7(0xf271ea38159d953d13fc8b45126269ec180384823433787c59bbebad92b0c200); /* line */ \n        coverage_0x914c86c7(0x6356035e08bbf452827774ffb372e0c23a6b21901682eabde54f505307651847); /* statement */ \nif (!valid) {coverage_0x914c86c7(0x9766869db33814532115439f5e6804d005c4acd0d56aafc3f3b876b55847499a); /* branch */ \n\r\ncoverage_0x914c86c7(0x08c256ab5c09ce782572e5363284bcc7d60be792df1cd50e3f5f002084cc73d6); /* line */ \n            coverage_0x914c86c7(0x9ffb3227530d0f9e2cffdeff0b688f9026585ade120eb689e661a735f8e86e9b); /* statement */ \nreturn (false, offset, byteData);\r\n        }else { coverage_0x914c86c7(0x9558c808202f86f594f927628d3dc4f7e2a3c0955f677a38b1600d837739ffc1); /* branch */ \n}\r\n\r\n        // If byteCount % 32 != 0, the last chunk will have byteCount % 32 bytes of data in it and the rest should be ignored\r\ncoverage_0x914c86c7(0xc4e21e51265e7fb36b5f9c43d8956748145e417afa9a4564b75293b40bce1dde); /* line */ \n        coverage_0x914c86c7(0x5418ed47ec8b64fef558b363c03ccd558119590e667cfd799ab25485256afcce); /* statement */ \nuint256 fullChunkCount = byteCount / 32;\r\ncoverage_0x914c86c7(0x023aee3983e9afeb633fb338b359ef3e973d76659b0eca6f46f10de1256c1e08); /* line */ \n        coverage_0x914c86c7(0x732a88efc9f40e121c9f2b51ada43411a24a843935696b970938f47ead416250); /* statement */ \nuint256 partialChunkSize = byteCount % 32;\r\ncoverage_0x914c86c7(0x6a1c44aee00f31dadb0ef1188f1529d32d0e6e30da1c97387448f98dd7eb0302); /* line */ \n        coverage_0x914c86c7(0x61ce050fb157069fe4d5164dcf7420c1c977dc5eaeeacafb50e18e33cd7c93a9); /* statement */ \nuint256 totalChunkCount = fullChunkCount + (partialChunkSize > 0 ? 1 : 0);\r\n\r\ncoverage_0x914c86c7(0x4f78c352e49fa6da928dd2c38ae6e5b8e8f88682186b47242bdecaabbf9c2ad3); /* line */ \n        coverage_0x914c86c7(0x4a8d3c0aba2e358ef3e03c79ee208026032897d870adfcc555d621b43d1e9c84); /* statement */ \nbytes32[] memory fullChunks = new bytes32[](fullChunkCount);\r\ncoverage_0x914c86c7(0x3400a61b98eaa7dc9e2ed1622b648817e4b27e1b01ea33d24cdeeff95ab77f52); /* line */ \n        coverage_0x914c86c7(0xa17cb98530c128495c8746e8e5f23626010d84069ee36fd7fe30ad622ec4f826); /* statement */ \nbytes memory partialChunk = new bytes(partialChunkSize);\r\n\r\ncoverage_0x914c86c7(0x4a502904ae990fd666ea7b8e1bcf55c94f18cc1734a81d60a071fdcb2c13a3fd); /* line */ \n        coverage_0x914c86c7(0xad76729bd251bcade7943f6bdf9f0b3f12c6778c65139085e38165f41e4ebc5c); /* statement */ \nuint256 fullChunkIndex = 0;\r\n\r\ncoverage_0x914c86c7(0xd0f9274ffb22cad95e74fc32aba86cfc0e3ca49268847426ab4bfe7081708317); /* line */ \n        coverage_0x914c86c7(0x21338df0c5d7c2a91a1505d17308d65fa936e584e6c40c3b4165ee85a10200ce); /* statement */ \nfor (uint256 i = 0; i < totalChunkCount; i++) {\r\ncoverage_0x914c86c7(0xbb4e3c25833bf14b77fc0d957dfa63d44c26c7d51603c96e20978ee1551cb722); /* line */ \n            coverage_0x914c86c7(0x7bac88f71347a4f7e174bd679a0a3ccd7f34e53ca537b4798b38ccb60710e2cb); /* statement */ \nuint256 nextChunk;\r\ncoverage_0x914c86c7(0x80451e4dd6df2bd32fe8fbcfd566acce70906d2344678f26f87730b4bfeb60c4); /* line */ \n            coverage_0x914c86c7(0x071ba8ba09a19ad8344814640e9c9e90839401a3a41a71c5521c20221b9674cd); /* statement */ \n(valid, offset, nextChunk) = parseBytestackChunk(data, offset);\r\ncoverage_0x914c86c7(0xbd821dcb4d416fd010b90dd620d4ab4d5abc1727b8da18ad0c7ea1be61e57163); /* line */ \n            coverage_0x914c86c7(0x784b0ab7605600e65581d59a043f6a3da14190ed5e5e43ebcfa77fefecb4ea70); /* statement */ \nif (!valid) {coverage_0x914c86c7(0xfa3f90ebc7cfcea4577ec941ef20970afe8fc09b373b0aa90055b23e7d929c56); /* branch */ \n\r\ncoverage_0x914c86c7(0xa782220c673db4612b96407e08a2b209e75d6f3465e23664d4b53b714bc545da); /* line */ \n                coverage_0x914c86c7(0xf8b3811fb2bc5aa24833d3a4db04a0ea7eea0153b9ebfdabe8e61a21912e7894); /* statement */ \nreturn (false, offset, byteData);\r\n            }else { coverage_0x914c86c7(0xf5f96ec8332e581f364513ecad11da23872e4851f6df67e06d6ae7fba8df4de3); /* branch */ \n}\r\n\r\n            // The chunks appear backwards in the serialization so we reverse their order there\r\n            // Therefore the first chunk is the one which may be partial\r\ncoverage_0x914c86c7(0x19be18fb8ba70dd2f770a20e35cf83f108850ffcb4d6c2e385278f4a792ea3b7); /* line */ \n            coverage_0x914c86c7(0x1cfc72bffbba889c8005ccd0b6c51f3adea92f675df0a25d9f8f6fe1b694a0ae); /* statement */ \nif (i == 0 && partialChunkSize > 0) {coverage_0x914c86c7(0x1f247c5a82a2ad2079166bd16d33d1cc18ad65eff6dad34704a222d12491319e); /* branch */ \n\r\n                // Copy only partialChunkSize bytes over into partialChunk\r\ncoverage_0x914c86c7(0x45c716c08f8d3a5d9bc625b9d4a50cd1a8019c2e8764125e700ccf91f3f4e9ab); /* line */ \n                coverage_0x914c86c7(0xf1097f2e6cc50429605f89edeec91a6b9708cfcf4d511f594e6ba45827b2fc73); /* statement */ \nbytes32 chunkBytes = bytes32(nextChunk);\r\ncoverage_0x914c86c7(0xb5214d85ff947def7ff0e20d430bd09f8a2bcf1d13d233ff2026d59f0f212dc5); /* line */ \n                coverage_0x914c86c7(0xfa869fe8bd88293c2bc828ff451b74cb0e638ce489b49565cc4c5faf60214b85); /* statement */ \nfor (uint256 j = 0; j < partialChunkSize; j++) {\r\ncoverage_0x914c86c7(0xa80d4c06479a24f857b51ff0ded248a333be6d6ccd97dba3ca0a898d67c9e86f); /* line */ \n                    coverage_0x914c86c7(0xa2c3f0f4ee7a6ebbd10300edb6fcdb309896f84dda31ed0d9233a0dfdb94765a); /* statement */ \npartialChunk[j] = chunkBytes[j];\r\n                }\r\n            } else {coverage_0x914c86c7(0xb83e7c9bc4ede863b7624b4852e8d69e696320afc68dd900f6df4852eb0741df); /* branch */ \n\r\n                // Put the chunks into fullChunks in reverse order\r\n                // We use a separate index fullChunkIndex since we may or may not have included a partial chunk\r\ncoverage_0x914c86c7(0xf09dcc2b7597529e5c273c8eaf568a8f1d96fffa490fd4eb95eae9ea0d8b2e57); /* line */ \n                coverage_0x914c86c7(0x4f89c82066db2de0a665c524a20e2a1ca083b2996bd38aeb5bd92be421f18eaa); /* statement */ \nfullChunks[fullChunkCount - 1 - fullChunkIndex] = bytes32(nextChunk);\r\ncoverage_0x914c86c7(0xdf19bbd93f88a634c8f428df951b081520907f4e605813e232a65760460fceeb); /* line */ \n                fullChunkIndex++;\r\n            }\r\n        }\r\n        // The bytestack should end with an empty tuple\r\ncoverage_0x914c86c7(0x84f62a638ea694558eea07b99a2d1ce42694f7511a1dd1959eae4c29aff52bcd); /* line */ \n        coverage_0x914c86c7(0xdced77cc2730bea1c74a667f5cab0cb26509800a9d2a6ec04c683df7f77d8f98); /* statement */ \nuint8 valType;\r\ncoverage_0x914c86c7(0xca0fb62c8ec1e0718545b6c766b2eaedddeeca33a853991199a36ffb92e9932e); /* line */ \n        coverage_0x914c86c7(0xaa611e6367fbaf33002bc5e7a03525662fec886d9129e547d8cb7a1fa2785b1f); /* statement */ \n(offset, valType) = extractUint8(data, offset);\r\ncoverage_0x914c86c7(0x26c7072c060111f2d72677b604d0c997e4b9d1d684885267002ca9c1063455e5); /* line */ \n        coverage_0x914c86c7(0x349f072d31198af6f4fc88c14b65809b7cfbe0066ddb8a7528bdac2a007c7044); /* statement */ \nif (valType != Value.tupleTypeCode()) {coverage_0x914c86c7(0xd9e4a50b5f10df7947b7f22ab93da3883438398b267c3df8243d052048abae7f); /* branch */ \n\r\ncoverage_0x914c86c7(0x858f8d9a3227da846ab9076389b7ee020197188fc8bad71ca3b5474627e91bba); /* line */ \n            coverage_0x914c86c7(0xd0fd28fd2f4f36184d5cb8bbb516eb4e9d7f5542e7fcce78b22869e55deb9bc2); /* statement */ \nreturn (false, offset, byteData);\r\n        }else { coverage_0x914c86c7(0xfc7a14b0113b6419307343a2616cfaa8b90ba44063e285b1fdbed7ed25d70a50); /* branch */ \n}\r\ncoverage_0x914c86c7(0x7231c479d503ec2a06798f665da8fabd95c0639430d4ff1b9389c76d04558c73); /* line */ \n        coverage_0x914c86c7(0x3c30cebfc7396b15d757cdf5c6feb1472ccdea31f28faba1e83264b233aca9e7); /* statement */ \nreturn (true, offset, abi.encodePacked(fullChunks, partialChunk));\r\n    }\r\n\r\n    function parseBytestackChunk(bytes memory data, uint256 startOffset)\r\n        private\r\n        pure\r\n        returns (\r\n            bool valid,\r\n            uint256 offset,\r\n            uint256 nextChunk\r\n        )\r\n    {coverage_0x914c86c7(0x29a199c23361094c0d9a7db10105bece747dabb9e0c287d84eb30179e7171184); /* function */ \n\r\ncoverage_0x914c86c7(0xf967f144e77856ca065961aee9b590f16e453b214ac5875c7160121d47cff126); /* line */ \n        coverage_0x914c86c7(0x247673fa0992320c8669e59cd1ecccc9bdaa2fb2123926c011a00ced2e3d49da); /* statement */ \nuint8 valType;\r\ncoverage_0x914c86c7(0x1c50e007493f5939e85d28583d025d0dbe5e466a724e2f030fca5f857c9e9844); /* line */ \n        coverage_0x914c86c7(0xcde4647ee7ccf0b5245b3ab661b141f316fc21af861b30fea1d86c044418cdd2); /* statement */ \n(offset, valType) = extractUint8(data, startOffset);\r\ncoverage_0x914c86c7(0xc49daeef6de7b715076722bef15f55f133c4079a6e50ccdd2806636ab8ed7303); /* line */ \n        coverage_0x914c86c7(0x4caf68f2d164e2996a1399d5a5c3d5de8223bec2a759ce499a641331bc4087a2); /* statement */ \nif (valType != Value.tupleTypeCode() + 2) {coverage_0x914c86c7(0x12c7bdd26dda371a0c0da95a5fa3c97881250531877119a24ae7e3432878bdf5); /* branch */ \n\r\ncoverage_0x914c86c7(0xd68fff9bc7c6725da35251c418e650463b083da485ac0fe2980224b3904f1c3e); /* line */ \n            coverage_0x914c86c7(0x476d19c9fccd74742087f5516a0acf5d4e7a1f86118c37db3be1755be9b218dd); /* statement */ \nreturn (false, offset, nextChunk);\r\n        }else { coverage_0x914c86c7(0xb2931caa1199829377846ef5852c2c2400cfb27dbe704222c9bfd36d71d49077); /* branch */ \n}\r\ncoverage_0x914c86c7(0x20aa835e1092f1bebdb0e7b16a86ef898b22c8f9a996b914c45ca0e71bd53609); /* line */ \n        coverage_0x914c86c7(0xf68c1132c40cb2058f4f83f60454d05fd3219567e68047b1a5d608aa1989e7f8); /* statement */ \n(valid, offset, nextChunk) = deserializeCheckedInt(data, offset);\r\ncoverage_0x914c86c7(0x5331519f46e970dc60eb91c0e40fa4117b79799c076f48677395cf9ab37fcdd8); /* line */ \n        coverage_0x914c86c7(0xf5a5212eb175cd6737a4c845b27869dd85a843419175fd4c98fb4b6d01491d37); /* statement */ \nif (!valid) {coverage_0x914c86c7(0x5df98389ee4c4013fa304e2194e8983e8c243f0490034b7d88652a6adc0e3b23); /* branch */ \n\r\ncoverage_0x914c86c7(0xfeed337b78cbe9a38184bf7747b7cdc571ca83b38d3af0833643d33637a63f48); /* line */ \n            coverage_0x914c86c7(0x3f9dce3f5e1b55f665260f7f9e6f1a57057b7a924be5872640383e25e31fa1b6); /* statement */ \nreturn (false, offset, nextChunk);\r\n        }else { coverage_0x914c86c7(0x52cc2b2063ba9a04eae6112581cf298f5cc8e3e12ca44a930967700d93539864); /* branch */ \n}\r\ncoverage_0x914c86c7(0x79bbfecf6ebea556f280d580091d1bdce34102eed477409e06d0fd150dba3270); /* line */ \n        coverage_0x914c86c7(0x41549cf2bbe2c91320ede0a06d654dacdb8cbb0d1bdb80004a7969c5fa609671); /* statement */ \nreturn (true, offset, nextChunk);\r\n    }\r\n\r\n    function extractUint8(bytes memory data, uint256 startOffset)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256, // offset\r\n            uint8 // val\r\n        )\r\n    {coverage_0x914c86c7(0xe81f12877fa810f5f0c864b3325b9aa43c844990ae512821aa9bbbfb6b4d948d); /* function */ \n\r\ncoverage_0x914c86c7(0x54c5a2a6b333612238cb29378a8a3f6ebe4cbd56b84fe33a0232461811837ffe); /* line */ \n        coverage_0x914c86c7(0x8ece4ccd8f66ab0d8578effd9dd70578c364966762138a904865ea8ea037f50f); /* statement */ \nreturn (startOffset + 1, uint8(data[startOffset]));\r\n    }\r\n\r\n    function extractBytes32(bytes memory data, uint256 startOffset)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256, // offset\r\n            bytes32 // val\r\n        )\r\n    {coverage_0x914c86c7(0x9aaa030a0e5a76958835e37cd508259973ba0026703648644c3d4637a8283f54); /* function */ \n\r\ncoverage_0x914c86c7(0x5fdfb1a1091c3bac5a57f7531a1dbdbc9cc921f4da4aa27bb132608eeb2ce5aa); /* line */ \n        coverage_0x914c86c7(0x10f796229050ac9daa3bba409760e78304e8111b20bc1c5094d9cecf6019b0f3); /* statement */ \nreturn (startOffset + 32, data.toBytes32(startOffset));\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\n/* solhint-disable no-inline-assembly */\r\nlibrary BytesLib {\nfunction coverage_0xe48d970b(bytes32 c__0xe48d970b) public pure {}\n\r\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {coverage_0xe48d970b(0xe6cd9adf2f466f7fb562f98847c7658775c47cf76e7546dc285217144a7656c9); /* function */ \n\r\ncoverage_0xe48d970b(0x69667aa9d49bf6ac40b25e0e61ebb2a87cf9ccb5f56b1f4c4d786b306df70ec6); /* line */ \n        coverage_0xe48d970b(0x0f83044db2af23efed8aba54a3cb1c403588778e217411b77a4916ae82d285d5); /* assertPre */ \ncoverage_0xe48d970b(0x3b7300cbcf317a4af6a27e6d8a36dee61c9f1f88acb411a52bf80bc74e4bf71d); /* statement */ \nrequire(_bytes.length >= (_start + 20), \"Read out of bounds\");coverage_0xe48d970b(0xa5b27ee9748e3f35745927649363e4c859f3090ceb788258f266488b94f822c8); /* assertPost */ \n\r\ncoverage_0xe48d970b(0x27f39c481124566ad08ad1fada64987c71178849cf2d606c477c2390f60e7438); /* line */ \n        coverage_0xe48d970b(0x3f0eb1bf182bea964786a017009d9d0af76431c1aa4e8d22e359a05f9850c8f0); /* statement */ \naddress tempAddress;\r\n\r\ncoverage_0xe48d970b(0xa9329e12119c9b4aa53512fdc43d1effe7309ef1ae93d3394e5ff1eebedfcae6); /* line */ \n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\ncoverage_0xe48d970b(0xc4b257a19f0947be2464aaa538d2a9e40a4e800bdd3a2d7455137fce8082a3ce); /* line */ \n        coverage_0xe48d970b(0x6d42a2a5f7dde765efa599037fb7d6cd013601c56b6796a0e34da6c1d2f2f4a2); /* statement */ \nreturn tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {coverage_0xe48d970b(0xa5a5997d70c59e7aa04d93e217ac2edf2de56b12dad977b648be89dbda761cd1); /* function */ \n\r\ncoverage_0xe48d970b(0xd52457f2c5f1fb633f699e15b8f7ebd194ecd4adf095c06ced69d63bee2aa9af); /* line */ \n        coverage_0xe48d970b(0x774a029019ca4864309165714e0d45ae69f35f06c77322e4b55e18409fcc4105); /* assertPre */ \ncoverage_0xe48d970b(0xab8fc681c338d2e977eaebad5ed45ef990c9b046e226917197ce43c463e73653); /* statement */ \nrequire(_bytes.length >= (_start + 1), \"Read out of bounds\");coverage_0xe48d970b(0x161aaed1f24f8759bd3231e4e02232eb5771e6255bce24f7cbdd0fdc9083d2cd); /* assertPost */ \n\r\ncoverage_0xe48d970b(0xddd72280a066dbb4fae14433908b15278f3ec56aa29437a76606a56424a1a33c); /* line */ \n        coverage_0xe48d970b(0x57df1c5f08401e07a86e0ca8e13c22dc283429483a519ea4d05e982d03a160e9); /* statement */ \nuint8 tempUint;\r\n\r\ncoverage_0xe48d970b(0xf34f582836e3339eb0c2475175eb24dd2450ab8943c6a4bd47fcb8b18cf03086); /* line */ \n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\ncoverage_0xe48d970b(0x2aa256e42c055a1180220842f77681341ca19f7c5583d6a385c35f2ac380fa35); /* line */ \n        coverage_0xe48d970b(0xa41885341ed6d985f2cf13085ef2e627024fb5ed46eeb6b744bf8f439084f130); /* statement */ \nreturn tempUint;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {coverage_0xe48d970b(0x490a9bdd133bec70aeffc62856144c7b222d0da597953b804ba47aec4289dfb0); /* function */ \n\r\ncoverage_0xe48d970b(0x3c5a33595bde34fddf8502b8a4092d36fee8808c1aeeeb152d8b36acf4123a37); /* line */ \n        coverage_0xe48d970b(0xfac570fa18d365db584d8bb7d0c4a3c82535bf18330aa486f22e1a61d212f136); /* assertPre */ \ncoverage_0xe48d970b(0x69f5866ff9c9a1c6cb7d586c98b4564acb2e137cb29630a24777a296ac836376); /* statement */ \nrequire(_bytes.length >= (_start + 32), \"Read out of bounds\");coverage_0xe48d970b(0xb1d941dab94a5ba09e02f8130ebb6148cea86ff06bbda821234be4bbce8de936); /* assertPost */ \n\r\ncoverage_0xe48d970b(0x962b24f7c7ca4a5a33eddd365f233d08fa10e3ef0f6fae1b58297141cd4f47d5); /* line */ \n        coverage_0xe48d970b(0x2b7f27347fb4dd01b7f83f7bf889048560dc7126ea7d10d87d0c4a8c9f5cc915); /* statement */ \nuint256 tempUint;\r\n\r\ncoverage_0xe48d970b(0xc5ed98b4fdb593c01ed5490d37822ca37915e6890788cf388e5d69b2cb3e0825); /* line */ \n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\ncoverage_0xe48d970b(0x2b51aa46a7ddcd035b549090a6861bd6456e3410f7b7b184f812e0cc11f477cc); /* line */ \n        coverage_0xe48d970b(0xc1dbf442bdfa1dc08723d94554a63ff00f2ffa872a5fd359f678d6a1cc1a216d); /* statement */ \nreturn tempUint;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {coverage_0xe48d970b(0x2a500ec35a1ea52a0d60b95f632de5b1d308f927b5b51a70832b0e69c5f52cd0); /* function */ \n\r\ncoverage_0xe48d970b(0x1cef7ddb833b44e2ef3366ce21631a7ae98084420dc6143a16091bb1f3d3dc53); /* line */ \n        coverage_0xe48d970b(0x68f7b3ee8cc31a44ae8d84f7699c3c98ee134ac1ce25109c0295b8fb50a1dab2); /* assertPre */ \ncoverage_0xe48d970b(0xa138676a56dc046512b4747359b3b5ea962ed585a118b89517524aede487e955); /* statement */ \nrequire(_bytes.length >= (_start + 32), \"Read out of bounds\");coverage_0xe48d970b(0xe095e87129d02dc6fe87dc553f21125d337df52711dc625b6ecfa242996afca7); /* assertPost */ \n\r\ncoverage_0xe48d970b(0x91bf80d31af0e3b5f307dd8f5142784bd3d899ec198f9e48736f61004ac1e9e2); /* line */ \n        coverage_0xe48d970b(0x2412e3d4f9fae3bd279a09175c7415893667e21b43a5b7d5748447f8884a65b4); /* statement */ \nbytes32 tempBytes32;\r\n\r\ncoverage_0xe48d970b(0x1cb746f3254429decc187ee0b1c621dbfc5078e22e2cd2cc8919e703928e851c); /* line */ \n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\ncoverage_0xe48d970b(0x0fabb8efcd46ae6722c3afc207ab5761fb17ea3357e9250370c94d3fe6578906); /* line */ \n        coverage_0xe48d970b(0x5aa154f5c6bb3858df42a2a2e592035d800057068a39df5878098f8cbb3f3e6f); /* statement */ \nreturn tempBytes32;\r\n    }\r\n}\r\n/* solhint-enable no-inline-assembly */\r\n"
    },
    ".coverage_contracts/libraries/DebugPrint.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nlibrary DebugPrint {\nfunction coverage_0x125558b5(bytes32 c__0x125558b5) public pure {}\n\r\n    function char(bytes1 b) private pure returns (bytes1 c) {coverage_0x125558b5(0xefb7cd841344530d2d14ae604e70c4e5b60aff30a986881246a8ea4e80d34032); /* function */ \n\r\ncoverage_0x125558b5(0x7157d7327bdbbcce7b46ebda31ca5336cf781355695f89336805064409a4475d); /* line */ \n        coverage_0x125558b5(0x93e73a1cb9065115e5017d5b6aa928a82fa9f9b02cbe6d354678fafb6d6acf97); /* statement */ \nif (uint8(b) < 10) {coverage_0x125558b5(0xd79abfc7d18e3ff387c808263c5f2fd6ecb10e77fc9c0d1330bb5c067cc77cfc); /* branch */ \n\r\ncoverage_0x125558b5(0xc8577162ec8ed8cfb1b4de3d7798f5adc738314aea5157c6e3112a45584176b9); /* line */ \n            coverage_0x125558b5(0x76a8208d45d03e8e18874069f11982d52c7790a08b4acadb8431855d1573079f); /* statement */ \nreturn bytes1(uint8(b) + 0x30);\r\n        } else {coverage_0x125558b5(0xc4107c4520460490809767012ee01148959bbd7af4b6b4357fe06688e7fa2945); /* branch */ \n\r\ncoverage_0x125558b5(0x34efd54bdeac07fe75d54ad52429c09ee848602dcfc4448948ca7ace507ed6b5); /* line */ \n            coverage_0x125558b5(0x790ce4d2604612fb35e8b20a3633886708a0c7cad7c79c3b577567a4824ffa20); /* statement */ \nreturn bytes1(uint8(b) + 0x57);\r\n        }\r\n    }\r\n\r\n    function bytes32string(bytes32 b32) internal pure returns (string memory out) {coverage_0x125558b5(0x8d6cc271d500c808558ae06c760b213f4b96593452f22cebbb7cef36d8adf480); /* function */ \n\r\ncoverage_0x125558b5(0x40f53aca1f1feedd4c5c13c36fb204113e92c359857f90088f5437e0a21dbbd6); /* line */ \n        coverage_0x125558b5(0x7a5928e8f6d4982bba8eaa9ef4fafd7ef7009e72cce61f4b8e1608e8359c1cf0); /* statement */ \nbytes memory s = new bytes(64);\r\n\r\ncoverage_0x125558b5(0x3cad5efa882af82ce809660370333d814f263e4160e0de879816dd19169c5614); /* line */ \n        coverage_0x125558b5(0xe3e937c1366fff4c17b11bccbcd87dd9e7031afa2c2e7424b65ffa5f72ebc66b); /* statement */ \nfor (uint256 i = 0; i < 32; i++) {\r\ncoverage_0x125558b5(0x135292a3a595d1af4fc9f0a3c14345029556ccf858f5762667fb95cbda89aac1); /* line */ \n            coverage_0x125558b5(0x731a22088130cecd1e53a7324e90b143580e99c0029ae60698dd8442cabdcde1); /* statement */ \nbytes1 b = bytes1(b32[i]);\r\ncoverage_0x125558b5(0x9f2224868e8e0becaa91f3a8dbff572b1c6435dafb202364b269dce586ce592b); /* line */ \n            coverage_0x125558b5(0xd780a5632ac3e9bf25c99e056109ecac06b60dc284cfb41ed375d6e31b74f8f8); /* statement */ \nbytes1 hi = bytes1(uint8(b) / 16);\r\ncoverage_0x125558b5(0xc376b5826ece8c8450382a8d0347d6f1b262c39d86c010679031ddafbccc6973); /* line */ \n            coverage_0x125558b5(0x98e7c7b29e032c7183a29528228685a88b217ef5427665fc7e1365ed5319fed5); /* statement */ \nbytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\r\ncoverage_0x125558b5(0xe3c8dd93c1f206b86e52efc7b598d2eddb46378fb9c09b7adfa773fbaf456fb5); /* line */ \n            coverage_0x125558b5(0xbba0a308e0beacdea37485d2b93b324746ca7f5a1ff3b1605c7a199a9228d0a9); /* statement */ \ns[i * 2] = char(hi);\r\ncoverage_0x125558b5(0x9f0a432f1f1c0ae34df3a74c643df63f337d99384244672f5aebf522e9832319); /* line */ \n            coverage_0x125558b5(0x0bed7aa4943b63771923fdc06560a87c5f436b00484965d6a66b4fd921062c78); /* statement */ \ns[i * 2 + 1] = char(lo);\r\n        }\r\n\r\ncoverage_0x125558b5(0x79a572636abfe04b7d3d84d5661887b605bb119309f853e878bdb5327014da6a); /* line */ \n        coverage_0x125558b5(0x6bdf7f5542cf55c1d99c7d61cdb42e9e2d27b025e506efd4be429c4f95460079); /* statement */ \nout = string(s);\r\n    }\r\n\r\n    // Taken from https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\r\n    function uint2str(uint256 _iParam) internal pure returns (string memory _uintAsString) {coverage_0x125558b5(0xa7cecabfdcc67d38a25c06d1698e21c0b6a438a07a31657a2deb9611a5cb935e); /* function */ \n\r\ncoverage_0x125558b5(0xaf7e987c2a05022e2e2bbbe30aa65a706fd67c04574c620378cd00ac4d6ebb78); /* line */ \n        coverage_0x125558b5(0xf9c9bc27fe2c48d601fc2127a2e632bbfde901c945154423f42cb918544f1f0b); /* statement */ \nuint256 _i = _iParam;\r\ncoverage_0x125558b5(0x8e0949e290cd3e89877e2d8125f54bb7a67ce44e14da13ca182a75dabfe6249f); /* line */ \n        coverage_0x125558b5(0xda5d673f3f4b00319df92ecce52ecf033c5dda02907d27f9cc6ca7cf1a867971); /* statement */ \nif (_i == 0) {coverage_0x125558b5(0x7335a94c818701e65af637e56507323d6e0cbc74ae965d4f31a157b1fabd69f7); /* branch */ \n\r\ncoverage_0x125558b5(0x9f3388e17ae168d113ae12edeaa5e3ef8b96aae76441827990f4275091d660a4); /* line */ \n            coverage_0x125558b5(0xa5223583b00007aca0fbfa156f0283ff19066fba9704f6181eeca2fe88aaa91f); /* statement */ \nreturn \"0\";\r\n        }else { coverage_0x125558b5(0x9d8303396b6a6b900bbe78b9b1c1f20c05e6ab7392969afd945b55dbe89fca72); /* branch */ \n}\r\ncoverage_0x125558b5(0x1a47e25ea0b014c11ba4f63491a828c36384cde4f5875eeb1d2ce71147de6f58); /* line */ \n        coverage_0x125558b5(0x29f5435d8ad5360d4d319ff426bc636f61ad1b1d307f2449ef4365705510555d); /* statement */ \nuint256 j = _i;\r\ncoverage_0x125558b5(0x4e5a28a7d57f9d434d31b02c67332f106fbf56e1cd92847110d7f42be281a41b); /* line */ \n        coverage_0x125558b5(0x2b93a77d0f07c30df0575f896fd6c502211a1177bf93da9584c994a318b3c562); /* statement */ \nuint256 len;\r\ncoverage_0x125558b5(0x83e9b6465fb9bfa08346fa7ba7204152a28125b64bd10d7d25b4f7f7befe8d23); /* line */ \n        coverage_0x125558b5(0x00482a211a499ad9398315529f3b13d3fc73d960ce57ff7d86835890154de120); /* statement */ \nwhile (j != 0) {\r\ncoverage_0x125558b5(0x98ad8df7f4b1ad1f80b572b0ea60c765d851696fd3451fa36b1d5717681271c6); /* line */ \n            len++;\r\ncoverage_0x125558b5(0xb2265e561769cf179e7a32fc07c3b4dd1a74f2ae4ee04934dc41da15be4aa820); /* line */ \n            coverage_0x125558b5(0x44c438fc5d832e9ee9d0a10e242ac2f4e681b471f21b9c9f7d1077b4561d97bc); /* statement */ \nj /= 10;\r\n        }\r\ncoverage_0x125558b5(0x847cbf2edd6619c047c0e79f6befbeff044ee01d507ea0232b299a0278d541c0); /* line */ \n        coverage_0x125558b5(0x0cb205529ff13bf7a3f4e4570462a0d46c1c7d61194a0dc55e9b4904d5864019); /* statement */ \nbytes memory bstr = new bytes(len);\r\ncoverage_0x125558b5(0xf03546a2f2d563b637daa1658d747ba3caac5c95b90cc9220969c5e60313010b); /* line */ \n        coverage_0x125558b5(0x6a952cfb6d28471b1b07dbe9fc2d7595420abac2f12791cdd681b85080716adf); /* statement */ \nuint256 k = len - 1;\r\ncoverage_0x125558b5(0x56f22121e3588db93894d7c356d003f5ea8dfb2d4e61b39797a01ae4b1d727ac); /* line */ \n        coverage_0x125558b5(0x980df055f29ba1e59d79bfeca8119c7426bdba6ceeedac18dbefb2aa2e8d735b); /* statement */ \nwhile (_i != 0) {\r\ncoverage_0x125558b5(0xafa12ccd62eab621a6961112d7e9233a2d9b5c72f3f1d2c640043482d519c649); /* line */ \n            coverage_0x125558b5(0xc05058b3cd522764b9e62ba13f94428476cc12a710388ae89135ab5d16279a5e); /* statement */ \nbstr[k--] = bytes1(uint8(48 + (_i % 10)));\r\ncoverage_0x125558b5(0x77d254764cabb2a017063ee97ee6b35ec7070bbbf96095131cfa3c3bb666b4d5); /* line */ \n            coverage_0x125558b5(0xd7b4dbf24359e701eda1fb0776caeb452cd5b9cbaeac0378029e8efd4008e8a4); /* statement */ \n_i /= 10;\r\n        }\r\ncoverage_0x125558b5(0xf75ffa67ea7b07748294b247757be91e9ae458cf785f607038df9d9b836dafb0); /* line */ \n        coverage_0x125558b5(0x48a85cde9ee07a5a302ad6b839c097b9bf8839466bfbd057f562f6d358efe6a8); /* statement */ \nreturn string(bstr);\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/arch/OneStepProof.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"./IOneStepProof.sol\";\r\nimport \"./Value.sol\";\r\nimport \"./Machine.sol\";\r\nimport \"../inbox/Messages.sol\";\r\nimport \"../libraries/Precompiles.sol\";\r\n\r\n// Originally forked from https://github.com/leapdao/solEVM-enforcer/tree/master\r\n\r\ncontract OneStepProof is IOneStepProof {\nfunction coverage_0x0dbb89fa(bytes32 c__0x0dbb89fa) public pure {}\n\r\n    using Machine for Machine.Data;\r\n    using Hashing for Value.Data;\r\n    using Value for Value.Data;\r\n\r\n    uint256 private constant SEND_SIZE_LIMIT = 10000;\r\n\r\n    uint256 private constant MAX_UINT256 = ((1 << 128) + 1) * ((1 << 128) - 1);\r\n    uint256 private constant MAX_PAIRING_COUNT = 30;\r\n\r\n    string private constant BAD_IMM_TYP = \"BAD_IMM_TYP\";\r\n    string private constant NO_IMM = \"NO_IMM\";\r\n    string private constant STACK_MISSING = \"STACK_MISSING\";\r\n    string private constant AUX_MISSING = \"AUX_MISSING\";\r\n    string private constant STACK_MANY = \"STACK_MANY\";\r\n    string private constant AUX_MANY = \"AUX_MANY\";\r\n    string private constant INBOX_VAL = \"INBOX_VAL\";\r\n\r\n    function executeStep(\r\n        bytes32 inboxAcc,\r\n        bytes32 messagesAcc,\r\n        bytes32 logsAcc,\r\n        bytes calldata proof\r\n    ) external view returns (uint64 gas, bytes32[5] memory fields) {coverage_0x0dbb89fa(0xd9252c666037fae79282cc1bb16928f9e3c4f6aaa5eb364b6773cb87c070b9c9); /* function */ \n\r\ncoverage_0x0dbb89fa(0x2af394f6fe0541c6288a39921c576c99c7b79de2cce840f91d7b685fa2040929); /* line */ \n        coverage_0x0dbb89fa(0x63f4af9a26dbf2ad9aa65dffdef7a39c50bacac5478dc58aff1f212648e85f58); /* statement */ \nAssertionContext memory context = initializeExecutionContext(\r\n            inboxAcc,\r\n            messagesAcc,\r\n            logsAcc,\r\n            proof\r\n        );\r\n\r\ncoverage_0x0dbb89fa(0x5554199226b9324156a7232608b7d60c459829e553090beae6599e6b9b89922a); /* line */ \n        coverage_0x0dbb89fa(0x370b9a552b4da943e8297105f5a49c64b970a45f194d30c1a67e9149d2168fe1); /* statement */ \nexecuteOp(context);\r\n\r\ncoverage_0x0dbb89fa(0x0484233d3be097b155a49697fe9011f4508e6d78b99fc1f70d3c8146798351a0); /* line */ \n        coverage_0x0dbb89fa(0xba23da8b92aa5d75bb1b89e20f0206a833c28eb2b7344f8de6363bbbb7de070b); /* statement */ \nreturn returnContext(context);\r\n    }\r\n\r\n    function executeStepWithMessage(\r\n        bytes32 inboxAcc,\r\n        bytes32 messagesAcc,\r\n        bytes32 logsAcc,\r\n        bytes calldata proof,\r\n        uint8 _kind,\r\n        uint256 _blockNumber,\r\n        uint256 _timestamp,\r\n        address _sender,\r\n        uint256 _inboxSeqNum,\r\n        bytes calldata _msgData\r\n    ) external view returns (uint64 gas, bytes32[5] memory fields) {coverage_0x0dbb89fa(0x194a5db7bdc639f70fd59b5bd8260bcc907fb222a522ab4d4bc95b458c7e0d65); /* function */ \n\r\ncoverage_0x0dbb89fa(0xad3024283a50e0ec64881caa063a5a0f3ffebc76b380483e3684b2425c999d6b); /* line */ \n        coverage_0x0dbb89fa(0xafba6e41476b331e43ba58fe00afa576dc9d55400169d099180144017c531115); /* statement */ \nAssertionContext memory context = initializeExecutionContext(\r\n            inboxAcc,\r\n            messagesAcc,\r\n            logsAcc,\r\n            proof\r\n        );\r\n\r\ncoverage_0x0dbb89fa(0x80fd75bbe80c9c6ba5341659283462ec09e9de6d97254ac1b99c2d364c53819f); /* line */ \n        coverage_0x0dbb89fa(0xfa911a0c2dd42e0e1689532a7735113f46b1f1eeb93c345d02f747c547e11b95); /* statement */ \ncontext.inboxMessageHash = Messages.messageHash(\r\n            _kind,\r\n            _sender,\r\n            _blockNumber,\r\n            _timestamp,\r\n            _inboxSeqNum,\r\n            keccak256(_msgData)\r\n        );\r\n\r\ncoverage_0x0dbb89fa(0xb1f2413b4248feb0e13b0a6a5d0794238c150bac5dba18f57d49afb861c092a0); /* line */ \n        coverage_0x0dbb89fa(0x89d7b16ec512ccf527a25bcef0d6b7af57278292e240484ccf2a1a7f9a375d34); /* statement */ \ncontext.inboxMessage = Messages.messageValue(\r\n            _kind,\r\n            _blockNumber,\r\n            _timestamp,\r\n            _sender,\r\n            _inboxSeqNum,\r\n            _msgData\r\n        );\r\ncoverage_0x0dbb89fa(0x12645001adbfc6d79365a8e1b141be96596ac36d043364826fdb7a69e51f6ea2); /* line */ \n        coverage_0x0dbb89fa(0x01ec743e977adb23983a0c2d83aab767b37fd03f2284fbc64c8fabfd14e8cf89); /* statement */ \nexecuteOp(context);\r\ncoverage_0x0dbb89fa(0x5bb1bc46caf995fe61ee8af2d558cb9e92bf703d7c4a3362885c80a1145942f4); /* line */ \n        coverage_0x0dbb89fa(0xa744717efdf0fde06cdc4f2fb79173ad2ad6be1d7ce8ece8ada3745a7a5be437); /* statement */ \nreturn returnContext(context);\r\n    }\r\n\r\n    // fields\r\n    // startMachineHash,\r\n    // endMachineHash,\r\n    // afterInboxHash,\r\n    // afterMessagesHash,\r\n    // afterLogsHash\r\n\r\n    function returnContext(AssertionContext memory context)\r\n        private\r\n        pure\r\n        returns (uint64 gas, bytes32[5] memory fields)\r\n    {coverage_0x0dbb89fa(0xf00f1baa90b98a60036dfadb109f23a7824e64a7aab159aa9986ab0e8669eeff); /* function */ \n\r\ncoverage_0x0dbb89fa(0xf777a580fe39eb0e82140fde8876f9d90d917093a852c8c869128cb7de42e224); /* line */ \n        coverage_0x0dbb89fa(0xad0f8f6ed5ef5ab322cb3896f43d602febb8fe3f185cb4c41f99fd8cec4b13f8); /* statement */ \nreturn (\r\n            context.gas,\r\n            [\r\n                Machine.hash(context.startMachine),\r\n                Machine.hash(context.afterMachine),\r\n                context.inboxAcc,\r\n                context.messageAcc,\r\n                context.logAcc\r\n            ]\r\n        );\r\n    }\r\n\r\n    struct ValueStack {\r\n        uint256 length;\r\n        Value.Data[] values;\r\n    }\r\n\r\n    function popVal(ValueStack memory stack) private pure returns (Value.Data memory) {coverage_0x0dbb89fa(0x22e57e688476760bf048a004212d298e8c9745aca0c97d5188388f7c5586ecc4); /* function */ \n\r\ncoverage_0x0dbb89fa(0x40c9419851baa7da4b034b206ffbea14206203388dbd7fa8a596db58c7ee2602); /* line */ \n        coverage_0x0dbb89fa(0x95ee4b55d42b65510439c57fee0ab6e5d992f27d0b2edcd8e2828ae52baceb4d); /* statement */ \nValue.Data memory val = stack.values[stack.length - 1];\r\ncoverage_0x0dbb89fa(0xb4e2396c31fde8c514f667d56a773c2838868b71516d1e0bf4aab3684240c0de); /* line */ \n        stack.length--;\r\ncoverage_0x0dbb89fa(0x4022b1c8e486249f267f6e62db4cc806aa273123067ca86f7532737882995a38); /* line */ \n        coverage_0x0dbb89fa(0xef9d4343e8b0b7e1444bd9a0407a298340c16095b5ea223a13ce1853bbcb1d09); /* statement */ \nreturn val;\r\n    }\r\n\r\n    function pushVal(ValueStack memory stack, Value.Data memory val) private pure {coverage_0x0dbb89fa(0x7cb58d4f9d2039ef71f81d40bebd196296f4887e8d328f28ea6c9572e0f277af); /* function */ \n\r\ncoverage_0x0dbb89fa(0x868e137be6e331d1429c9d49028d03189314618137bf9e1d43a2059c3e3ed609); /* line */ \n        coverage_0x0dbb89fa(0x8f2938cd1a8a751cbfe425cf2cf4c90580aea5c60e1339b122111ee19ec57c7c); /* statement */ \nstack.values[stack.length] = val;\r\ncoverage_0x0dbb89fa(0xe80ae0661eeb9f3f6f3051c9722507ffa6d129042afba2c05f885712e631e6a5); /* line */ \n        stack.length++;\r\n    }\r\n\r\n    struct AssertionContext {\r\n        Machine.Data startMachine;\r\n        Machine.Data afterMachine;\r\n        bytes32 inboxAcc;\r\n        bytes32 messageAcc;\r\n        bytes32 logAcc;\r\n        uint64 gas;\r\n        Value.Data inboxMessage;\r\n        bytes32 inboxMessageHash;\r\n        ValueStack stack;\r\n        ValueStack auxstack;\r\n        bool hadImmediate;\r\n        uint8 opcode;\r\n        bytes proof;\r\n        uint256 offset;\r\n    }\r\n\r\n    function handleError(AssertionContext memory context) private pure {coverage_0x0dbb89fa(0x4e7298bda719656eee7fd197910432705623fc161a1dfd2d37c3c75e7de4566c); /* function */ \n\r\ncoverage_0x0dbb89fa(0x8320ed2b14b13f770251635a3d03306339fc0b739acd93b11c1a825365dc3ece); /* line */ \n        coverage_0x0dbb89fa(0x0e6c863cdf63e4c125e125b0687c4e5e13022e3ea317730983b7651de90d039d); /* statement */ \nif (context.afterMachine.errHandlerHash == CODE_POINT_ERROR) {coverage_0x0dbb89fa(0x42cec730457544ad7f40518c09e445baaf0da9f66e6982d95bef837bbb9f0ee4); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x876c9ecd93c2c294d909d743746651e798c8bb048b4b6a02ac0de996471f5d46); /* line */ \n            coverage_0x0dbb89fa(0xefa52fed81938eceb3902fab89170fbe3936e29c57445750d6d0d861439b0517); /* statement */ \ncontext.afterMachine.setErrorStop();\r\n        } else {coverage_0x0dbb89fa(0x1714d190787a48f44f4e8066557d22206a17b61f192a412cb328ea1e35dadbed); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x0f2c16be568f395a3f253d193e0bb5d81d5ed1b6564bec612adabe4950145a2c); /* line */ \n            coverage_0x0dbb89fa(0x2a571727dc31db9fac115b826e252659f14e74e7b18a1ad2dc51f18365e439e5); /* statement */ \ncontext.afterMachine.instructionStackHash = context.afterMachine.errHandlerHash;\r\n        }\r\n    }\r\n\r\n    function deductGas(AssertionContext memory context, uint64 amount) private pure returns (bool) {coverage_0x0dbb89fa(0x9b5fce6d2182eedf47283e2e9f12214cafe5439e00c6a1c03945f8a62198f140); /* function */ \n\r\ncoverage_0x0dbb89fa(0xbc2ef32010219a1a41d467dffe0e043ba63fdc670476dee671c087d566b9a748); /* line */ \n        coverage_0x0dbb89fa(0xca9b5d0c2e979b1d60325113aa4c8a6ec5812fffcaa61bfe18001476e4b8525a); /* statement */ \ncontext.gas += amount;\r\ncoverage_0x0dbb89fa(0x312b6b9d6b3b7f40efb03e827ed525f11b049ff77d7fb199465b33b0a9af3f93); /* line */ \n        coverage_0x0dbb89fa(0x4d5fa66301e591f5b8a02c2298c68cfc982dd0d48545d9e953aae5f5679efbd5); /* statement */ \nif (context.afterMachine.arbGasRemaining < amount) {coverage_0x0dbb89fa(0x2dad5dc294a2c13199e5e8ab8954668ce6cb22c3edf8e5714acb06eca6e175e4); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xbae78b608f4a6fa4823580caaaedceea2623c5e3009e188acae7af53951d97ab); /* line */ \n            coverage_0x0dbb89fa(0xaf640ffbe3832c5d9f2e12607f23f18ac1947d9fe99ffc95b98afdcf102f4a65); /* statement */ \ncontext.afterMachine.arbGasRemaining = MAX_UINT256;\r\ncoverage_0x0dbb89fa(0xdd4b22456567cc68b1024067f6aa0ee730660f4d71d4b3daa394a62ee41701e2); /* line */ \n            coverage_0x0dbb89fa(0x006cebab8c158ae473cc379ee885913bcbe3906d0bdfd796ff7bf1c29cf0110d); /* statement */ \nhandleError(context);\r\ncoverage_0x0dbb89fa(0xe9f81d99f51b14ee64eaf3a0e711579ac659f545b1086d94a0fd0f984348b060); /* line */ \n            coverage_0x0dbb89fa(0x38fdac45d5c4fd98c7308f93786b8ec49fe7dcc424a5aaeb684a4f701f52899b); /* statement */ \nreturn true;\r\n        } else {coverage_0x0dbb89fa(0xb38f1445efed94e619a41c9a72e817c9182eca87fba45148934ffcc3b652bcce); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xaf0ef45789e469d3b53094e0a3643bb38d4f08d41cde97437455fcd48133f8b4); /* line */ \n            coverage_0x0dbb89fa(0xe169ce7ac37c524f815ea1ddaf272a5b7078b5b8b7f12255116b2cc72b8a4b6f); /* statement */ \ncontext.afterMachine.arbGasRemaining -= amount;\r\ncoverage_0x0dbb89fa(0x7db6601fb69fbfa1e09716eba7c85ffe873db51abac938a17958462b26aad8e5); /* line */ \n            coverage_0x0dbb89fa(0x04e02bc06a291c28120ca7fd96c714c77f6696163aa0e9e1916a626d166c08da); /* statement */ \nreturn false;\r\n        }\r\n    }\r\n\r\n    function handleOpcodeError(AssertionContext memory context) private pure {coverage_0x0dbb89fa(0xd466cbffc565836a0a809db329d44610712429d825dd6bb55e503dedf8309e27); /* function */ \n\r\ncoverage_0x0dbb89fa(0x85d8a8bed175470cee1db59deaa525367331e580e652d9e4fdce2437b68a35e9); /* line */ \n        coverage_0x0dbb89fa(0x7f8387d27cd7a6f6666238e6d707ed0064607120bf3bf376270720ab37e15b69); /* statement */ \nhandleError(context);\r\n        // Also clear the stack and auxstack\r\ncoverage_0x0dbb89fa(0x72c80bfbe103e0ca37375727291517ab56bd8a2d6c918e1417f5ebb16ddc8e9d); /* line */ \n        coverage_0x0dbb89fa(0x3231e94535833bea32a998fefc6d03ed82f4842e4fde22e3430d312a9c07eb96); /* statement */ \ncontext.stack.length = 0;\r\ncoverage_0x0dbb89fa(0xe7830bf841192cb352c5b8cd0ea9d62c44a7486ffa49e265c7d0ebf947a31683); /* line */ \n        coverage_0x0dbb89fa(0x6973a0b76d1e4532ef67030123496d1e59de4129fb3c1c9eca13cc87cc7443c8); /* statement */ \ncontext.auxstack.length = 0;\r\n    }\r\n\r\n    function initializeExecutionContext(\r\n        bytes32 inboxAcc,\r\n        bytes32 messagesAcc,\r\n        bytes32 logsAcc,\r\n        bytes memory proof\r\n    ) internal pure returns (AssertionContext memory) {coverage_0x0dbb89fa(0x30ef52aefd5987e5a0bfbc7f495b32ab6d2c53fb2e69d5a26490005788f5fb81); /* function */ \n\r\ncoverage_0x0dbb89fa(0xa340810bbbe34149a4ae7b152c76a9a71f0ccc0a1be92a322f89f5985e51d692); /* line */ \n        coverage_0x0dbb89fa(0xd3ad0bc508a964d911c46bab154a65d7ca545ca891f6900ef6efb4ac4493e490); /* statement */ \nuint8 stackCount = uint8(proof[0]);\r\ncoverage_0x0dbb89fa(0x4b3c7a16753c7c7ae6a30998fcc9b5e9b126d27024f30cb5dd29c67c938aac88); /* line */ \n        coverage_0x0dbb89fa(0x011af525b824256042e688004d6a662639bf456beb357469cf7d6291517ea400); /* statement */ \nuint8 auxstackCount = uint8(proof[1]);\r\ncoverage_0x0dbb89fa(0x126a62dbdf28166c39296c8492f32b556369d5298b78a06fba02f60f15918cd6); /* line */ \n        coverage_0x0dbb89fa(0xae1ff5a501b924e6c8e5c658e8cb9db563ca393302839a613fc6301a52db3d54); /* statement */ \nuint256 offset = 2;\r\n\r\n        // Leave some extra space for values pushed on the stack in the proofs\r\ncoverage_0x0dbb89fa(0x9f0abd70e683f8cc1d91c596c155e8fb190f9faa953f99e2c59509a6aa258bc7); /* line */ \n        coverage_0x0dbb89fa(0x0106dc20595994b969a0f9857cab3b8cd06099c058a495fbc5e9ae05212c8a54); /* statement */ \nValue.Data[] memory stackVals = new Value.Data[](stackCount + 4);\r\ncoverage_0x0dbb89fa(0x7715aff3cafd3c05e0a050bd87fe98ec63c31592bf625bbba88e6206a8c6c015); /* line */ \n        coverage_0x0dbb89fa(0xdaf75b77f508284fe5ad26818592d81d4d0d9befab7d38063bc7839219e0cc95); /* statement */ \nValue.Data[] memory auxstackVals = new Value.Data[](auxstackCount + 4);\r\ncoverage_0x0dbb89fa(0x45d5243b8b4a07e628cddf5fbe34dedaf7631f76bfdc2a05ef08bff488f2db54); /* line */ \n        coverage_0x0dbb89fa(0xcf20b0d1fb43b42290bf86e72326db6b1f22214f43a225d2308820c1ebe6a9e9); /* statement */ \nfor (uint256 i = 0; i < stackCount; i++) {\r\ncoverage_0x0dbb89fa(0x08b4b76f2bb6a6ba70cafe4ce36e4d4b3c6a1e6b06484b152c6f911d7d9b1e25); /* line */ \n            coverage_0x0dbb89fa(0x2ea8120ca7aac4276d6507fb182381d2462e5f62afd2e8a3d3c8137310953f67); /* statement */ \n(offset, stackVals[i]) = Marshaling.deserialize(proof, offset);\r\n        }\r\ncoverage_0x0dbb89fa(0x29845f4e7581285b72fd2e3a07548297c3348769dd4e775ac97e88d809f4bf60); /* line */ \n        coverage_0x0dbb89fa(0x00569a34d078d941ec46f78fa38b0d39e20eca8d3621c9293c5f28f2404dd578); /* statement */ \nfor (uint256 i = 0; i < auxstackCount; i++) {\r\ncoverage_0x0dbb89fa(0xf4b952b7d53a75c2e690cc29358961a77c5f7e29a40c320c67229e1f609f1c49); /* line */ \n            coverage_0x0dbb89fa(0xd98641b681b6a592c5032fac933e90540882ff4d0da5280b7a5d0a5c3cd16052); /* statement */ \n(offset, auxstackVals[i]) = Marshaling.deserialize(proof, offset);\r\n        }\r\ncoverage_0x0dbb89fa(0xff8109aae38b8d90ae74010279bda76ca891c5af3fc8b1d740d6602f3d6cf3b5); /* line */ \n        coverage_0x0dbb89fa(0x04d69e02ff507792b391baec5294bd2717f791519ec4999a2c21a6df13041499); /* statement */ \nMachine.Data memory mach;\r\ncoverage_0x0dbb89fa(0xead90c14fa71212b2401f8ef1188cbe8b0a42d2c8f81936b947cb1b911d47272); /* line */ \n        coverage_0x0dbb89fa(0xac77a2d4791bb1d3e120a669773ef85ed75dc7a30bf1b8af16fdc612139988b3); /* statement */ \n(offset, mach) = Machine.deserializeMachine(proof, offset);\r\n\r\ncoverage_0x0dbb89fa(0xe90ad5431fe82ffe534c7fdb05e7cd7bae3c719537201c6ef68b4ea63adbed68); /* line */ \n        coverage_0x0dbb89fa(0x9c0d68daeabaa12abb449f410d46f7126e34806cbc468cb05ff1574ec5da1c1f); /* statement */ \nuint8 immediate = uint8(proof[offset]);\r\ncoverage_0x0dbb89fa(0xa71b4cafbefc32ee5c092869b12223fd76bb8761f8207e96c4a83fb867f63201); /* line */ \n        coverage_0x0dbb89fa(0xfe95b98d0b4ab9ae2fd8f59f12c5d7c7ca3353c82926046d9ac027df8287e54b); /* statement */ \nuint8 opCode = uint8(proof[offset + 1]);\r\ncoverage_0x0dbb89fa(0xad7517e4adb8fcf6e81635fc90cba8b0181c81eb52fc6bbee4b0c7929d3e2151); /* line */ \n        coverage_0x0dbb89fa(0x706938b519dbd7be8a4f0d5719354ce3b50733a48fa27fd9bc5898adc123955b); /* statement */ \noffset += 2;\r\ncoverage_0x0dbb89fa(0x39b80a4507a0115a0ad4ab697d3dcd02da9d539d0ff00010203d05a332b25f38); /* line */ \n        coverage_0x0dbb89fa(0x6259e3eec9d78dbf48203936f202dddbe096d797fa61acf6ef1d6898e67a4bea); /* statement */ \nAssertionContext memory context = AssertionContext(\r\n            mach,\r\n            mach.clone(),\r\n            inboxAcc,\r\n            messagesAcc,\r\n            logsAcc,\r\n            0,\r\n            Value.newEmptyTuple(),\r\n            0,\r\n            ValueStack(stackCount, stackVals),\r\n            ValueStack(auxstackCount, auxstackVals),\r\n            immediate == 1,\r\n            opCode,\r\n            proof,\r\n            offset\r\n        );\r\n\r\ncoverage_0x0dbb89fa(0xe0148c7e365e0f27893429050da5f487fe69500bf58dd72c759e3aab045b5a65); /* line */ \n        coverage_0x0dbb89fa(0x421b2dc9a27bce4cfe395d879d8846da5392ef9aeeea5a0fb903044b1c5a9f49); /* assertPre */ \ncoverage_0x0dbb89fa(0xe10dd035fb1fe890307000883e5baa1109aaeadec39d10a0621d74b8018ad308); /* statement */ \nrequire(immediate == 0 || immediate == 1, BAD_IMM_TYP);coverage_0x0dbb89fa(0x187030b6040ed22de4a06dc7cfc97d86f870adecc17cf07a27dcad8633015e38); /* assertPost */ \n\r\ncoverage_0x0dbb89fa(0xba12c1f6b65c6049f78329c41662ffa10889441d3c1a359da6c765017b97827e); /* line */ \n        coverage_0x0dbb89fa(0xea844c7aca64c6ffca8de4e9f684a9fd103d4a5def4b7c7aad430bfa492a63df); /* statement */ \nValue.Data memory cp;\r\ncoverage_0x0dbb89fa(0xcd5c26e1af0e2504c26603b8dee6407a56be064879bb70d8b4de3f6b7d877e82); /* line */ \n        coverage_0x0dbb89fa(0x18235725b305c62ccc148857bd3a603d4dd66ea8c856dfc6c854463558d52671); /* statement */ \nif (immediate == 0) {coverage_0x0dbb89fa(0xdd1329c70c08f71d519b5a83cc9279a9f9899de6181018a6b826f3f2546298dc); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xd5a33c5baddbd2de25a6303317fc36e7846e4e8314c99a582704f344cf4ae1cb); /* line */ \n            coverage_0x0dbb89fa(0x1e8f899750ce4074cf42bcf0fa7402d420677075a57000e05f8b17e8728ab1fd); /* statement */ \ncp = Value.newCodePoint(uint8(opCode), context.startMachine.instructionStackHash);\r\n        } else {coverage_0x0dbb89fa(0x600d71654999fc38efa2d02e353ab4dd71a5dd7b4aab193e70a1397f3ca9db62); /* branch */ \n\r\n            // If we have an immediate, there must be at least one stack value\r\ncoverage_0x0dbb89fa(0xd7b5e33995169b41bb08fd4d43470e0fbb38afd347203accd630ce2a5878731e); /* line */ \n            coverage_0x0dbb89fa(0x1196bec8263b14827f30aa140a49025832e6dc816c87dcbe57af6ddc338659dc); /* assertPre */ \ncoverage_0x0dbb89fa(0x256c017a25e5be040833ed5bf6fab34d880220b2275bc0e17efa7c24e9e4062b); /* statement */ \nrequire(stackVals.length > 0, NO_IMM);coverage_0x0dbb89fa(0x172c10c0ba0e7a22b4248c7712e880f60276d8122ee820dd692b1bc2761d94a6); /* assertPost */ \n\r\ncoverage_0x0dbb89fa(0x929c21a92e3142fdb0302ab788a4dcb9405a76eb483591cfeaab11de515f4fdd); /* line */ \n            coverage_0x0dbb89fa(0x64ff3fd095b5cd7aa650f091fe5e25f13355cc1c9bd0e05a61a08c075e18bd32); /* statement */ \ncp = Value.newCodePoint(\r\n                uint8(opCode),\r\n                context.startMachine.instructionStackHash,\r\n                stackVals[stackCount - 1]\r\n            );\r\n        }\r\ncoverage_0x0dbb89fa(0xc878df4efb4a8ea3f34b65f0a3886b61a8adee83a5d7478a51292b9918fab877); /* line */ \n        coverage_0x0dbb89fa(0xe8325587c15ec363fed4a25f5273ba272b591c1f5294887d04118b32f5cfe61c); /* statement */ \ncontext.startMachine.instructionStackHash = cp.hash();\r\n\r\n        // Add the stack and auxstack values to the start machine\r\ncoverage_0x0dbb89fa(0xacbfb726933fbb55f65e04f927520d1803ce7e9b05295faf4f1423883ab51aac); /* line */ \n        coverage_0x0dbb89fa(0xa4261226e2cd56936f45fec850468195c8579d21f6e1537cc7833436f7487012); /* statement */ \nuint256 i = 0;\r\ncoverage_0x0dbb89fa(0xde4c3535b844fca5f3cfd141aa70844febc75782705f4990c1c222602b0e5356); /* line */ \n        coverage_0x0dbb89fa(0xc23fe3459526e9503a784a7ff373c20c9e1abe9985d7fe7e2d75d780256df948); /* statement */ \nfor (i = 0; i < stackCount - immediate; i++) {\r\ncoverage_0x0dbb89fa(0xe847c63107d9a6f42bf77ed1317427607384ed9d37b345111a71577a77a5f4f8); /* line */ \n            coverage_0x0dbb89fa(0x4b54b1a7e460d4cecff98f5fea12c33be727ced0e00984615d77952cccc65b53); /* statement */ \ncontext.startMachine.addDataStackValue(stackVals[i]);\r\n        }\r\ncoverage_0x0dbb89fa(0x5f41dece5c1251c4f85b54db4edc3d76f6870b11429c22cf0fc433105ecd2ea8); /* line */ \n        coverage_0x0dbb89fa(0xd225cfc9e93cab7d0d997ee32f0f63460ef568444c31d9845783cf60859cd15e); /* statement */ \nfor (i = 0; i < auxstackCount; i++) {\r\ncoverage_0x0dbb89fa(0x4b4a735e5aa3e23862f5a209a0a19c6abb8fc982aea1795231197723f67183aa); /* line */ \n            coverage_0x0dbb89fa(0xa1a588daca5813b70016d36d7375b886b7648324fca58ffd63d91d58f877abe8); /* statement */ \ncontext.startMachine.addAuxStackValue(auxstackVals[i]);\r\n        }\r\n\r\ncoverage_0x0dbb89fa(0xe864eeb2e24b54eff3d33b681882ae0d50d5d27213717cde393bae61fc3d4a58); /* line */ \n        coverage_0x0dbb89fa(0xbfcce250cec227b03db4efe8c1af8f1d8f8f29411b6cd85947b00fc8dc9949ee); /* statement */ \nreturn context;\r\n    }\r\n\r\n    function executeOp(AssertionContext memory context) internal view {coverage_0x0dbb89fa(0x7f254297724620c83ff3153905718edf1fecb776324051e29f6f69c65ec1461a); /* function */ \n\r\ncoverage_0x0dbb89fa(0x61df26372d09bb86df67dff2f8a4777720ab9435dc19b5c752e764e71e12329d); /* line */ \n        coverage_0x0dbb89fa(0x383955538573f8d544e586e0494aff620e886a7f904535a9fb78dfb0f6fd5295); /* statement */ \n(\r\n            uint256 dataPopCount,\r\n            uint256 auxPopCount,\r\n            uint64 gasCost,\r\n            function(AssertionContext memory) internal view impl\r\n        ) = opInfo(context.opcode);\r\n\r\n        // Update end machine gas remaining before running opcode\r\ncoverage_0x0dbb89fa(0xe1ba62d42620652f46e67f2fb213294ddaeeddc74cedc8d3e0eafc498a018bc0); /* line */ \n        coverage_0x0dbb89fa(0x6296916bf0c9817e2e03e04dd11c6fba3923e4948efe5026eb42ede45f11052a); /* statement */ \nif (deductGas(context, gasCost)) {coverage_0x0dbb89fa(0x012536335d069ab8b4b7b3e81f32a187b4abccc9659c9049d7ee7def0f96f6ec); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xccd9aa5a6a8d40c287ae2045053564dba8e96e8a463b6d6a0da13e337109f0c1); /* line */ \n            coverage_0x0dbb89fa(0xc1913986c9da0d41b5822fa9df7df008ae127024054f92f115433f257710204c); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0xddf7254b70cfd503708b6cfeb225216430a8b21cde4e15ce48e42d9371b15ad5); /* branch */ \n}\r\n\r\ncoverage_0x0dbb89fa(0x4929eb4e5951b38bc2fa1f3df2999116d4a361d6584347773a93ce7cb06831f1); /* line */ \n        coverage_0x0dbb89fa(0x345548107729cada5b9b801611f67828530ed226d14992f8ed89fc441f3aaa06); /* statement */ \nif (context.stack.length < dataPopCount) {coverage_0x0dbb89fa(0x9609de8934878cd9ff3b538d45c84f085d6fe2b4fda9342c76b769473d6314b6); /* branch */ \n\r\n            // If we have insufficient values, reject the proof unless the stack has been fully exhausted\r\ncoverage_0x0dbb89fa(0xbe6b03fb1196f49c454b5406d791613cf157328055e7ae78c90276f42360a1c7); /* line */ \n            coverage_0x0dbb89fa(0xcf4dd7797016fb5eb6491199f0136ab18e68728e05d61a4e079c9f35c968b5a4); /* assertPre */ \ncoverage_0x0dbb89fa(0xc81f1b1c0b2fb57015a27538fb4062c6469900590f22dcac7b85fa48b94bc8a8); /* statement */ \nrequire(\r\n                context.afterMachine.dataStack.hash() == Value.newEmptyTuple().hash(),\r\n                STACK_MISSING\r\n            );coverage_0x0dbb89fa(0xf80627c0158f02a9768b3cea1c3d926ed402434794504f0d16bb6e1b030a23e9); /* assertPost */ \n\r\n            // If the stack is empty, the instruction underflowed so we have hit an error\r\ncoverage_0x0dbb89fa(0x8d0d2bd105fc86bb6c141c17351481f06e0ab807a450a98348ab311321320596); /* line */ \n            coverage_0x0dbb89fa(0xe58167149fbf8f73716628865ff3ff35323ba4c7517a8ccaa5541f3a83967367); /* statement */ \nhandleError(context);\r\ncoverage_0x0dbb89fa(0x916f8434b8f5d4296733419cdeb752375969dd9321acfe1eb14036a9ac040d01); /* line */ \n            coverage_0x0dbb89fa(0x72fe31e7819fbb6cb96cc012c1fe76c9fbf30c29372b281244014fb47fefc747); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x82c91bd1ed34370f6c444672ab4bb9f5b25bc3ce7c26093ce29f9e3427148717); /* branch */ \n}\r\n\r\ncoverage_0x0dbb89fa(0x1f2d866ec8a5734733666d3b5be7f0b9ca7f410258b1ff633b5ec264050fb554); /* line */ \n        coverage_0x0dbb89fa(0x110927f906688e01b05adb93eccd1e8a3703010818392bb110c3d7a662487945); /* statement */ \nif (context.auxstack.length < auxPopCount) {coverage_0x0dbb89fa(0xb7022f9701d01760da80fbe5818160fd1cc85e0b38f24c097ce8c3ecba8afdec); /* branch */ \n\r\n            // If we have insufficient values, reject the proof unless the auxstack has been fully exhausted\r\ncoverage_0x0dbb89fa(0x2bf97e562fb55c0fe84882f960e3f5fad64368fa8c623d166adc94b64c04ef47); /* line */ \n            coverage_0x0dbb89fa(0x7fd4a506a4c0f0fb6a58317bf5c96c677780049c0cfbd2381f425190d0514af3); /* assertPre */ \ncoverage_0x0dbb89fa(0x8a3fbac30e1d7f9d338d42ed1b9a342363c652d3ea41e10427cfc7bfe4738da9); /* statement */ \nrequire(\r\n                context.afterMachine.auxStack.hash() == Value.newEmptyTuple().hash(),\r\n                AUX_MISSING\r\n            );coverage_0x0dbb89fa(0xaa8b8390707ddb60f16c9bcf47ab887f961f921717d3db7a80f49faa36064f40); /* assertPost */ \n\r\n            // If the auxstack is empty, the instruction underflowed so we have hit an error\r\ncoverage_0x0dbb89fa(0x5981ee70568a9c716f2e8a1ce59a4d9af3182e29382f4ba2148447bb8d48de14); /* line */ \n            coverage_0x0dbb89fa(0xf0c3a092f51883710e46416df22bdedf3af8fcb1d122f7df09a27f8d5c3a0d04); /* statement */ \nhandleError(context);\r\ncoverage_0x0dbb89fa(0xe5119f0e614c178e96fc27f45e8828f35051d21722278e2a73ff796878a1cca9); /* line */ \n            coverage_0x0dbb89fa(0xc49635691b0d2a71e801a5c3b48aaf689dbb83079bbca770f395beeab235216d); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x8f85cc295853f5f8b2fe3344e55185bc5ce87e446e1a0bcca98391479aae36ca); /* branch */ \n}\r\n\r\n        // Require the prover to submit the minimal number of stack items\r\ncoverage_0x0dbb89fa(0x4ab9e7c9bc291b23d2a41d3d3f9df872e14e9c5d704faf4b867641030755e961); /* line */ \n        coverage_0x0dbb89fa(0x3a50c9a6d7822783f72d11e57523477710d4885f8bd870544128fe71a2574784); /* assertPre */ \ncoverage_0x0dbb89fa(0xfa9a830bd0507650abe67b9b8cb739bf69d89387d8c4d9df8965ff48930d5479); /* statement */ \nrequire(\r\n            ((dataPopCount > 0 || !context.hadImmediate) && context.stack.length == dataPopCount) ||\r\n                (context.hadImmediate && dataPopCount == 0 && context.stack.length == 1),\r\n            STACK_MANY\r\n        );coverage_0x0dbb89fa(0x7c5bb35f91f9f9562573e87eb23bec7bca1a4facdec92aa41a6dc616fc354328); /* assertPost */ \n\r\ncoverage_0x0dbb89fa(0x6bb94f5ba31be53a9f97a54ac1efa66fa4b0490cb7de0817dc8bd4049b40513a); /* line */ \n        coverage_0x0dbb89fa(0xb66927c8c30a672caed3482b3c857f5d67599bc9ada2ea1f637da4cda11c3c01); /* assertPre */ \ncoverage_0x0dbb89fa(0x63da5142cc2c7f70634c17fcdbd1ee97d97a2ea721c153abfd07064583f1abb8); /* statement */ \nrequire(context.auxstack.length == auxPopCount, AUX_MANY);coverage_0x0dbb89fa(0x2251f114a7e0f2c8959cc470b2bc117a8047f595c0fdc81d352476c0fab36622); /* assertPost */ \n\r\n\r\ncoverage_0x0dbb89fa(0x59d2400d4923570eeb26b9de4aa65903e15da880c8707e17d76c044337b1210e); /* line */ \n        coverage_0x0dbb89fa(0xfd44a96611abf3a342d05b03a66d44f3b7fbec028e4ccedc34391c76269e72d9); /* statement */ \nimpl(context);\r\n\r\n        // Add the stack and auxstack values to the start machine\r\ncoverage_0x0dbb89fa(0x46728719c8eff3a804cb3897c681e0f5c711a5be81d182d2abb510c846489e60); /* line */ \n        coverage_0x0dbb89fa(0x2c3f8c0b1367a44423917738a17166510fe4d53a9090a26b207aef472828f937); /* statement */ \nuint256 i = 0;\r\n\r\ncoverage_0x0dbb89fa(0x8580413623cb4f127db4d550f1cd7b2c4a9d0a5f9e15c666e4e9dd0e4863f497); /* line */ \n        coverage_0x0dbb89fa(0x635b543304eddfc9e016496d6b54252e91984bc361406adc8a1a61a9e6d2e682); /* statement */ \nfor (i = 0; i < context.stack.length; i++) {\r\ncoverage_0x0dbb89fa(0x73d2b1ff867bbaacfd0c025f5ceece5eba755bf2292d493ec02c33bbd9c3edd2); /* line */ \n            coverage_0x0dbb89fa(0x04db0f46225b6dcc55edab396bd1e81ada9192b0c2744183f883160143533699); /* statement */ \ncontext.afterMachine.addDataStackValue(context.stack.values[i]);\r\n        }\r\n\r\ncoverage_0x0dbb89fa(0x629ebf5fe16d37f632d1cac99d2daed257878c434218043d90f83f30b42ce856); /* line */ \n        coverage_0x0dbb89fa(0xa17bdc3fe4901ee64b0280522568576051f61dc44c4f3f28631bd0f0a89ff9e3); /* statement */ \nfor (i = 0; i < context.auxstack.length; i++) {\r\ncoverage_0x0dbb89fa(0xe3712c39df78d8f0c5957087b50a20ff00be654ca1467de8f68d07e363fa9154); /* line */ \n            coverage_0x0dbb89fa(0x4c093043129921c0ef9037d3de4a9531115975ea291a308e524379c3795b35b5); /* statement */ \ncontext.afterMachine.addAuxStackValue(context.auxstack.values[i]);\r\n        }\r\n    }\r\n\r\n    /* solhint-disable no-inline-assembly */\r\n\r\n    // Arithmetic\r\n\r\n    function binaryMathOp(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xfffbc81e0b49f5889dfffae5aef19d66d6c723ac49f73ad75599a52c17dfb997); /* function */ \n\r\ncoverage_0x0dbb89fa(0x562b13b9f873e6d3a9a728698e40c0112d32de95381a5677adcf21bb7d4694ae); /* line */ \n        coverage_0x0dbb89fa(0xcc9920d67521567053958ff1b08bc59cbee6b2e743bd3e5c4e77e836702bcb1d); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xcf61ee9d81cc053fa04fda864497ea321c82457e1507d6f2e7659a6d5c03dfcd); /* line */ \n        coverage_0x0dbb89fa(0xfee16e6fcabd5f4801f65946835b1e1a8c5f9b7469414d6aa6aac7d9638cca9e); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x1e469de6d01cf2f468bcf8b94b9244a91740e352ceaf42a1fcc8302cb8676ee2); /* line */ \n        coverage_0x0dbb89fa(0x02fd822273301498f4d15931805f543a1c0946f471420bdaeedcf994a7828c46); /* statement */ \nif (!val1.isInt() || !val2.isInt()) {coverage_0x0dbb89fa(0x84585d3b3e5b00904b9bb19dd621067089877ca085d1de951d328d20afa81510); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x2713f1e8c5b06a4e9cebdc56ad529ae9a4bbf946d67dfdc7e5a0eab2d09f3091); /* line */ \n            coverage_0x0dbb89fa(0x8611bbea6e14c10df845ec05799ed900979e35296ace90ebcf5e5e29bd4063ee); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x041062c8b905dfa9b3962d5943ea1f8b05a420fb818cbd0150a50f5450048ddf); /* line */ \n            coverage_0x0dbb89fa(0xc8bc6fdcb0eee9dfc6bd3b0c17251caf8d1dc0f742980d6112126cc057151f7e); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0xc0e246df463c1db7948b539fc45309064826d0d998674d815bebf2318b63f345); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x057378b51c290522559d66551bcc880921ed7a2b6484ef6a31dfa883f89951e6); /* line */ \n        coverage_0x0dbb89fa(0x5b99e5a8132fe3d274c3e615d4381ab77752cb2a5053e69a6f85185f72705907); /* statement */ \nuint256 a = val1.intVal;\r\ncoverage_0x0dbb89fa(0x501010855978fecf201c95f79fa3d6895fe0011e61830432cfe28df7a7cce91d); /* line */ \n        coverage_0x0dbb89fa(0x96ed9d6673506a25a283ff2a3a379327a90193145259a318188ed99576c4f34d); /* statement */ \nuint256 b = val2.intVal;\r\n\r\ncoverage_0x0dbb89fa(0x6d09eb4ffc26d12e7787c11c36e713d222692d82cdb6d74dca07e97d0136020e); /* line */ \n        coverage_0x0dbb89fa(0x4be95d028a90244b8246fe27ca45944016f7890819e9939e7b4fd9791c9937f6); /* statement */ \nuint256 c;\r\ncoverage_0x0dbb89fa(0xc827e0313864f056b92be899b8f5acb1c2b41a62eb3504bc8301dcb0374635b7); /* line */ \n        coverage_0x0dbb89fa(0xb5c1d9d9b8eed4924914128f67b3642d0c6be15bfbc46ccbb71a32a803b2653f); /* statement */ \nif (context.opcode == OP_ADD) {coverage_0x0dbb89fa(0xce6c0e3298f2751e8dd3452ec07c00e7d9101f90c733db7f60b26ae009508995); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x1288ca189bb95957a3ffdafb3e6c59a4e8468188bbb422ab147067d9b03ae55d); /* line */ \n            assembly {\r\n                c := add(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x1c25888ee2b5e450bb7796440e6a56c24d59b5c744722365fadab53d8d9cc53a); /* statement */ \ncoverage_0x0dbb89fa(0x4d55a4c0bd345cd32436b0a49121d2409335bf13ef3186860120f9915106dcd6); /* branch */ \nif (context.opcode == OP_MUL) {coverage_0x0dbb89fa(0x4bde41dc6241d0692f6ac882de2240db91854754a27fa4189fb7700eeae57f20); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xf164ea22889eae6e70356054b88b4d9f6ccd7cd04d1fdcb06deec3ace1c3c5c3); /* line */ \n            assembly {\r\n                c := mul(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x2220d179c284ad6afe6ae652abe308b2f214ad68f4d8473a66e8a9a1575fb8d9); /* statement */ \ncoverage_0x0dbb89fa(0x93fcefcc476c4f5615fd7480eebce8627241786a73bd684310f68734019d8a61); /* branch */ \nif (context.opcode == OP_SUB) {coverage_0x0dbb89fa(0x52880c712e7c56ba61ed833d1a1d800be53789d03d762d694cdee2888ac7791b); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x59afeccf093c2cb1922448f77ca2bd9c375e7d964b57b1e5b51f8441056fbc8c); /* line */ \n            assembly {\r\n                c := sub(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x4db4bf816116a9edbdc534a7c323765bac50984df8e78abf9f3be634d8e98a0d); /* statement */ \ncoverage_0x0dbb89fa(0x6ad083594aa804769e7abfdf808a666dfbb78eb7f00a543ba4713ca41514217b); /* branch */ \nif (context.opcode == OP_EXP) {coverage_0x0dbb89fa(0x0f18900ed9808546c4cab9224b02bbfef1f031aa021fb0088ae9bad44b668286); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x4e0b2cafbccce3b1a40f1b95ed61a8626803ac4c4b4d072fc32f01f78fbd0500); /* line */ \n            assembly {\r\n                c := exp(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x7b3ec2904035bde7eafc3ce32036c2f657f0842151d63ab75dde9669836c11f7); /* statement */ \ncoverage_0x0dbb89fa(0x5bc48b278e28e77489874b55cd0bc5b1b7fcfdf8cace32a364d95f06b1a253aa); /* branch */ \nif (context.opcode == OP_SIGNEXTEND) {coverage_0x0dbb89fa(0xd1251e05f73a544f59de2b02bde9902e8db2192de01134cd3c5ce096a86a6956); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x1250791a9f93da0e130acde336a0fa142b2dfe456c8ebabf98240439f66b02ce); /* line */ \n            assembly {\r\n                c := signextend(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0xf71e2b8a376531446650ee9dff020f9a88fbff1b2797886bc99e9631a049e76a); /* statement */ \ncoverage_0x0dbb89fa(0xd79d2efacd6995d05559c717c9eabcaa62711115753d1b4cd1b3cf737fad16ed); /* branch */ \nif (context.opcode == OP_LT) {coverage_0x0dbb89fa(0xa6bed60d59b0e8bae648ef4fd8aeb27619bf21907b8cf2399d8d9ee07e79b1e0); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x2d02fb9ccb90d65416776bc1acb02465fbde2ccd408e5f530e82ca8c707409e6); /* line */ \n            assembly {\r\n                c := lt(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x99180d19322d41a9d3db789fb3d9edf7d4861616df510a23e7020f325b0d0c9c); /* statement */ \ncoverage_0x0dbb89fa(0xd2aafc03289414fea7b9cfc86fc71bb39c40275bfd36554495e4f2d29c8dea33); /* branch */ \nif (context.opcode == OP_GT) {coverage_0x0dbb89fa(0x1cd6658886b9f484ebef5c2fa05d8e307751427ac9392cb9711b0f42fadb9a1b); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xb927ebe66f4f198472ae33b97d75e81fd5035aaad1460f98fc9d191a9d99f8cd); /* line */ \n            assembly {\r\n                c := gt(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x85ced4a9505587b76687b7d86df95d64537e839277fc6d17c3203f99b892bf38); /* statement */ \ncoverage_0x0dbb89fa(0x1327ca0ad909109028700b5f5d24f0a859b0a10b00ccbf70117cd970928fdd85); /* branch */ \nif (context.opcode == OP_SLT) {coverage_0x0dbb89fa(0x954429637ab847c31048434040307bfc16d80f1c456db9700678bc9374599c68); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xb024b6327fb0819b669b113dd100c963a2b260d5d6198676d9b467e2d73b3280); /* line */ \n            assembly {\r\n                c := slt(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x664d1db36d3ed1e68f0bbc9968a965232d0adaf82a4faa0e8e87211ceb53f774); /* statement */ \ncoverage_0x0dbb89fa(0x669e8745c7b514677b577664f41db4ae0a4968449fde7b1ce8a7dde54a3b060f); /* branch */ \nif (context.opcode == OP_SGT) {coverage_0x0dbb89fa(0x603eb29465d70d71e07afe57ceb3e8d1e71d05cb19505ea74d8e4aac01ab7aa7); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x99f72f603c97d5541ab9861f1c0c5529dcc452effdbfd50c16a271eea978abca); /* line */ \n            assembly {\r\n                c := sgt(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0xb9e101cee5594cf0476775e2acd5b4865d50bc99e3db2476a0d04de3ef9c91de); /* statement */ \ncoverage_0x0dbb89fa(0xd28e92993af19e97fef443aed60de0ff3804b656db971a5679b30201b79ac3dd); /* branch */ \nif (context.opcode == OP_AND) {coverage_0x0dbb89fa(0x63177bdf843dc47b0513416857d67cdc2e4ff75400810936b5e2f77ef77296af); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x2655c320c829050ae400c60271bfe42f51f40749081d95fe9a0ee1a9f3995fb2); /* line */ \n            assembly {\r\n                c := and(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x4c0df0c5eeb7279f64e789aebeadd6ba24edf3304dc22b63550c18d12294ed84); /* statement */ \ncoverage_0x0dbb89fa(0x9316ffa04ef0132eb3ad3ab84471c41edc45bc49574d9562f23d4f9b4c7a9905); /* branch */ \nif (context.opcode == OP_OR) {coverage_0x0dbb89fa(0x429d064e95c5140c1c817465e1e6efd9bdb2ecd4f164d9856ae2eb582f2ab654); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xf29c71421538c662490195a840ceb3abfde6bcc934d6b821bcfbe22473847e9e); /* line */ \n            assembly {\r\n                c := or(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0xc8dbeefef7ceeeb0f8edbd42e5eaf68a32a52a0e862dacb7a82935b2f29533a0); /* statement */ \ncoverage_0x0dbb89fa(0x687789a58c8afc1cb0afe6169d1d6b1f6b09b5364ac0e756101db2ed2e1c1171); /* branch */ \nif (context.opcode == OP_XOR) {coverage_0x0dbb89fa(0xa490a1f4a545b9fd3aa285b8399f22abce3fa123597537844d1420e5a20e95c2); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xc502a8ee581fc48ef8021d9cb192268312df7fc3d3a19dee76c4793810af2fac); /* line */ \n            assembly {\r\n                c := xor(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0xc52f7624c646db7773eedb001e544365691bee3b9ff77aff86eef1b3fa72c939); /* statement */ \ncoverage_0x0dbb89fa(0x14f19f2b14b627f259e23df7aab5fdfb6c933d754de3ea795b8a1aca68f70fde); /* branch */ \nif (context.opcode == OP_BYTE) {coverage_0x0dbb89fa(0xfc2acae67513fc12cbc5606eceed9d62aa3b218d6d01a852cd4926c81ed151da); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x738a6cfd7c3ffc789a495fa996300327d66b89f83b593a8710ef20d5c1b08ebc); /* line */ \n            assembly {\r\n                c := byte(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x2b130b479e4feda247366432757b73f22cd784b6c812b5b851914521a322cac7); /* statement */ \ncoverage_0x0dbb89fa(0x957bedd305bcbc1d13f670a2f66b214e4107cc2aa5b278fb71fe98e77b005177); /* branch */ \nif (context.opcode == OP_SHL) {coverage_0x0dbb89fa(0xaada3a2ec15fcea66478cd669fc1f9dd4f45cf8891daaa1b551acff6b6d9c437); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x00ff8c5a58735c581c5ef7bfea83400cb104865a2689616cef2f9154e378d818); /* line */ \n            assembly {\r\n                c := shl(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0xcb888498b3d47f2a768b0d5e28be7b65991b127cf0d960729aeb672cb146dce9); /* statement */ \ncoverage_0x0dbb89fa(0xae44105af61ed08173ff4fa2548c5347fffb0968dd3b84b4c6f1704b7f9dc211); /* branch */ \nif (context.opcode == OP_SHR) {coverage_0x0dbb89fa(0xfd015b564aca48d29087d39893ca8c247e28fd40fdf2242958a969642f2349ed); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x210cacbb70a460a96b121ade459b7a463bef6b59a54dccff459bd0f4b7f69a54); /* line */ \n            assembly {\r\n                c := shr(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x1ff014ee6f3ec03286b602b543252d851265d32259682bb6f1dcac8c0848aa8c); /* statement */ \ncoverage_0x0dbb89fa(0x382fdc0d6b8dd44d153cd06c4a393ae183e07c9ed1c0c2523f012884d34d1d64); /* branch */ \nif (context.opcode == OP_SAR) {coverage_0x0dbb89fa(0x82de5c0020297b306733897dc912732fa877a78291c58d68b975a3663fcd2563); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xe5931ffcc46b6c62afad5e01ee818dcd78c1214f7ebed55d4a1a392f916e30fe); /* line */ \n            assembly {\r\n                c := sar(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x6c4a6c3bb068e92c3cfe67d1233c0c4f39b89e34505eee369cb5f8449e0b4e3b); /* statement */ \ncoverage_0x0dbb89fa(0xf6f694266f5af31d5ad94730c422e219525fa404c2e894064a4f2f14a3d676f7); /* branch */ \nif (context.opcode == OP_ETHHASH2) {coverage_0x0dbb89fa(0x3516f769ddcce42fc3d3aa63bfc01301dd99c66448bfe743a632d330be41dfd1); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x60286d65f262e7e7162354b889d309ee8bc370361bb9fceb3de2b4ae1b640574); /* line */ \n            coverage_0x0dbb89fa(0x0b6ace95b9bb983c52a6026945667b02010963b3a5e7aae6142eddbaad1c3a03); /* statement */ \nc = uint256(keccak256(abi.encodePacked(a, b)));\r\n        } else {coverage_0x0dbb89fa(0x1559e0e20405f248b754db0fac734a991c10b045f10b7c8357508380c98587c4); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xfbadb325502bb04453f2f1deff6e045c106efd5ba1eda2ea4fd8e53c1db6b8d4); /* line */ \n            coverage_0x0dbb89fa(0x412edda92c492eda8484de718d8255bfbaa75b312f77ff994681662a53f0147e); /* assertPre */ \ncoverage_0x0dbb89fa(0xed081fb90d34a14301bebfb314e20e6ddc09f5f481a2efa6331e05da45fa3792); /* statement */ \nassert(false);coverage_0x0dbb89fa(0x10c5bfafbdcc0fb731809d0b099e715d45210d24bf4c2ab052cf1fe14a0f5aa2); /* assertPost */ \n\r\n        }}}}}}}}}}}}}}}}}\r\n\r\ncoverage_0x0dbb89fa(0x6c7c66c47372016305e1a183fb62f9cda12e0222a31b8c3804dd7c3a692de73c); /* line */ \n        coverage_0x0dbb89fa(0x8103434a190de97978b2cb671cbece80cd2dc2e297e2a47a950d78caf6a64830); /* statement */ \npushVal(context.stack, Value.newInt(c));\r\n    }\r\n\r\n    function binaryMathOpZero(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xb93c5d33ad3aad0b891e5dd8bb7774b24e7f922ceefd9ecdadda46ae4dae4a3d); /* function */ \n\r\ncoverage_0x0dbb89fa(0x673a68da37b643c6c4734d9966ae103e36e45212a4f99c32ca3d4dae012ce025); /* line */ \n        coverage_0x0dbb89fa(0x952ed3a02c8e26b3626f4a4d5461550145e7cfab92f990a49e8da8d5b8a80640); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x1aad3dbf85b85f4e27164f5a60b093b6e3f22fc7bc978d68a8de414a9b1b39be); /* line */ \n        coverage_0x0dbb89fa(0x70b966670a29fea6ae7ba4fba8254e27547544749d90a8506d63ea4307873173); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xe83e0eab74c544377e5e3c9c8ae9fcb15a6e2527d1695122cb8a10ac0662d4a6); /* line */ \n        coverage_0x0dbb89fa(0xa7b1cb8bcc0d15fca5ff2e155abfe0eb5a5a11883115f904890469ea58fe00fd); /* statement */ \nif (!val1.isInt() || !val2.isInt() || val2.intVal == 0) {coverage_0x0dbb89fa(0xa7c18f6d399b7a3eeaf425b158f703a2ddb516006a36be35fc0da5c838429d51); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x6db006a09afd2386ee2a6eb68b77bb715bf9555e518b0f88d4b58b31ca95078b); /* line */ \n            coverage_0x0dbb89fa(0x299780434c7c6a50419f761b51f2182f4a9357042d450c874b891b5b3667b7c1); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0xbf29d047e1d4a7579fb4e995184f92bffb2b4d89d04bfd1fb8e323ee2b56b3c1); /* line */ \n            coverage_0x0dbb89fa(0x3f5302ee010ce28f4696f0a41e8ba2e03bbafe3ae2059c6fc08c2edb2119cd1e); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0xa4b0e1a26c49ecea1fb840dee76a2d471cbe6c1155dee7fdfa7ba0f9df5987de); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x64e996a3ff16d86c59863181d605bcecca6f1d0879fcfe6bb272b82e58a4c57b); /* line */ \n        coverage_0x0dbb89fa(0xea7b5fe6daf4ca1f1b70952e359d6c3de52680fb51687637cc6d3f48fb5534a5); /* statement */ \nuint256 a = val1.intVal;\r\ncoverage_0x0dbb89fa(0x056b2476daa8dbeaf3b463251342a05faed182d234b7d7c91dcc2cf3542309d8); /* line */ \n        coverage_0x0dbb89fa(0xf53e792b7852797af1941a84e1f4b0af95d077aeb0da284e33b9b405dec9c9c4); /* statement */ \nuint256 b = val2.intVal;\r\n\r\ncoverage_0x0dbb89fa(0xf28b4e4153ffacf9f744e87a41b84557cce9c5af7ca2910cbc9fd71188b04bfa); /* line */ \n        coverage_0x0dbb89fa(0x62cee15afa18be9776ff113a002e1e34fab80c8c0c8d43fca139e480a08a6355); /* statement */ \nuint256 c;\r\ncoverage_0x0dbb89fa(0x169a2e8dcd196db7992ddd937cda229b3018ce90d8d04408929d1a468efb631d); /* line */ \n        coverage_0x0dbb89fa(0xe03b47fa51142fb614aae167813db1437a11375e813690ea6063adc7c5015e98); /* statement */ \nif (context.opcode == OP_DIV) {coverage_0x0dbb89fa(0xfa9fec4172bf55e9e07d44c0ad2bec2693a397e1ec3decf647d78c7638dcf1a9); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x424054095a5620d75b203e6236ef02508278732c9bc34cc093fa4fa50971b976); /* line */ \n            assembly {\r\n                c := div(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0xa09a829b0af023a7f387c92df4091ff44325edb4638fb75d8bf3da9dd8917fd0); /* statement */ \ncoverage_0x0dbb89fa(0x7f6b59d356cc77ed3ea3f399e39fd8aeee8a05c26c81db5fdff9866c61efac73); /* branch */ \nif (context.opcode == OP_SDIV) {coverage_0x0dbb89fa(0x0919f76f7c2e5b22605e9307cd2169c34708c48981358685c658b3d03057b325); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x1a81abb1be8f50d355269be4ee69aefc000a2cc6b57a32bb9d3eba0cd36cc639); /* line */ \n            assembly {\r\n                c := sdiv(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x649c6eea19f577c7a0960a37ed6756aa25b39c2f37ab307c2070e6a5f6d74db8); /* statement */ \ncoverage_0x0dbb89fa(0x6aafe0e2682f9c432264d12b22c463c7bdf1d6ec54305eeb4ff8f5e92d5d954d); /* branch */ \nif (context.opcode == OP_MOD) {coverage_0x0dbb89fa(0xeaac924633921b5a93cc9c9b835803824d409a0971274eb19609bd83d155ff9a); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xfdc92fc55d2fdac87935f3dd6132b5e6d9987483d0ced0f5db4485e2fc898eba); /* line */ \n            assembly {\r\n                c := mod(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x2672a0c99b90e26e62b3f9851258c7e1b74c9ddc132bcb3a8937da2cb1c4fdec); /* statement */ \ncoverage_0x0dbb89fa(0x022cbb505955fd81dd5a6c9d5ffddb318157b7031d3399f13d74e748ab41f96c); /* branch */ \nif (context.opcode == OP_SMOD) {coverage_0x0dbb89fa(0xbc61e3b4a3e997e22224086b96570a4f30bbeb538328137521078151401ad9e1); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x265c6c3846e3b275507bcaeda37d44092113bcd53b36a81c9fb887efaeb3dbb5); /* line */ \n            assembly {\r\n                c := smod(a, b)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x9e963cfc39d2bbefa016e7789fdeec2118b98b66c1008cf164f2a451c0e4c992); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x34686f4c7b4f8a2f8f79278eb352906e8ac9344f7e38918a34fd5ab872faaa85); /* line */ \n            coverage_0x0dbb89fa(0x5d57662ef83363a24d020fc71b36c765b18a16cea032ab3cedfa9666d8f7cc52); /* assertPre */ \ncoverage_0x0dbb89fa(0xc1ddda58a9b1b7a2489fade981d4631c131817378e7f9102c4f283c34511c17e); /* statement */ \nassert(false);coverage_0x0dbb89fa(0x8503cbc21a0d53fa9c86103f738a85d5ace1f9043b128fd9f50addea92de1215); /* assertPost */ \n\r\n        }}}}\r\n\r\ncoverage_0x0dbb89fa(0xe59eb6445dd94902ca62c336bb7e3e621105460a0e7434bddb9f50c346e90172); /* line */ \n        coverage_0x0dbb89fa(0x4a34b9a31312574a45552641e044d50bf1eb5cdfda4067326823c682064465eb); /* statement */ \npushVal(context.stack, Value.newInt(c));\r\n    }\r\n\r\n    function executeMathModInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xf0c6253b56e82891dc10473bde7c82fae885c85579405b670825f2585984154d); /* function */ \n\r\ncoverage_0x0dbb89fa(0x8650dfb4c26cd1cd465a00f6fae4d083ea88192b21f0f928cc9a701a89907c72); /* line */ \n        coverage_0x0dbb89fa(0x280aee4dba506ba9e711e36635a12888e33e983993823ac243265a9d038949c9); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xc4654579337a00396e21d02ee8a3c651bc253fef6440da73ad79b61c9df8c250); /* line */ \n        coverage_0x0dbb89fa(0x80a392d575ecd3ef94edb94fafebdc50fc1356c66cc3d7631952bfdd8d5e06a2); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x08f6f724084bd10c62797de1c3e43a7ccee27f3b1629e8201e0f695059846610); /* line */ \n        coverage_0x0dbb89fa(0x03f11e83a05926468443d8242394151873e38da417dc0eb21eb84d4e668e090d); /* statement */ \nValue.Data memory val3 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xa8dee0e7fefc93ba465762f710976208e422a97819e6648416b47f91388d6447); /* line */ \n        coverage_0x0dbb89fa(0x0845b7bfac6ccb7058a93688ffa8e95303bd7f76f4e585b61c57cdcd0188f7de); /* statement */ \nif (!val1.isInt() || !val2.isInt() || !val3.isInt() || val3.intVal == 0) {coverage_0x0dbb89fa(0xea83866a3f9b07b55314bbc04ce9621ab9f5a2f642894aad88442825e5ae31f2); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x0597919d23a5a6c98821816605478327b8c3b3c0bc8624132703fa8ca1803423); /* line */ \n            coverage_0x0dbb89fa(0xbed357702737d719ce2e80aa868407a9b1936c83522af5d2af62b5c0818ef20f); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x294a06cb91115a0e14cd8e3a0921fab4d7b6097a7e7ad6498e890d846c6259e0); /* line */ \n            coverage_0x0dbb89fa(0xceb1ce0e1ce71f1838dc094c3c1c309f9b148985b2c51116b8ab5a97d59e23ef); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0xd660ad726b585386a0286e945a38419622a0ff50cc9c113f4aeb10612bee7469); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0xe46f3f086a6269eafd29f84bfece14741029a49ec94e5867e0ddcc0af298adb9); /* line */ \n        coverage_0x0dbb89fa(0xb5e67cf3171f4a8671fda64fca2d703d3f82befb61fef92f35ac58e4030266cf); /* statement */ \nuint256 a = val1.intVal;\r\ncoverage_0x0dbb89fa(0xed94fd917d7f0adc2757f6b35a6968e47270a2b1e3d0cad533493a38d2ac990d); /* line */ \n        coverage_0x0dbb89fa(0xd361d7651e70ab5d3e8c3b727dc5ad7c1eefb2984d4706a75a96c14dfd475c00); /* statement */ \nuint256 b = val2.intVal;\r\ncoverage_0x0dbb89fa(0x174d4eb2900fade6cf33ae2d0b6157f30321fb51c15e8d35d0bfbf2e53f38b2d); /* line */ \n        coverage_0x0dbb89fa(0x0cc85aae8bda055679133c0b487295a6b7332cc01d7da818e911a452391db113); /* statement */ \nuint256 m = val3.intVal;\r\n\r\ncoverage_0x0dbb89fa(0xcd381629a322f7b89cc2c2ba8f3beaf2721de1b16c0a11a7e3e5527cd85d04ae); /* line */ \n        coverage_0x0dbb89fa(0x7aebbfd02c209877e89fd3b5060ad8e8e1d5203cdb8064d7f570caf53cbf6d7d); /* statement */ \nuint256 c;\r\n\r\ncoverage_0x0dbb89fa(0xc75f0cfb4c77a93d25da204e41ebd6e886f0d72d46f52dd202b7849214d2e699); /* line */ \n        coverage_0x0dbb89fa(0xcedbe06ad54b96869206b0f892e3a8640eb317d56454d413b174f112d97bc003); /* statement */ \nif (context.opcode == OP_ADDMOD) {coverage_0x0dbb89fa(0xe3c75dbbb57711ae92008b30cee11f5c5bcbec96ec4113612d905548fd32bb4a); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x72b3b5a40178bb97875f414a05b32781f6de6e8793f492a1a700c86836f61b7c); /* line */ \n            assembly {\r\n                c := addmod(a, b, m)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0xa6fc305a6354526930a310710fa97c2b2d44d04f20bea2cfcd9b033793e641f0); /* statement */ \ncoverage_0x0dbb89fa(0x0aac48e1c4cdc73f842175e7c3838b70294d289db2cbdac912a63616108a9630); /* branch */ \nif (context.opcode == OP_MULMOD) {coverage_0x0dbb89fa(0x3b5d1a0b5da65cd156971ff25515bfec81491387fe60ccc6157bdfaf1153e3bc); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x6a016e6e333ded524934e15b0c17016f9f92a739a745c0b5831c88a40425f325); /* line */ \n            assembly {\r\n                c := mulmod(a, b, m)\r\n            }\r\n        } else {coverage_0x0dbb89fa(0x7517d1269d86e63aa5042e2de181b9bc7f27b3ef92ecca406c31e535bdbafaf0); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x02283861172ba5afebf1f29276d2f26532de499f9a76e263eabb961fbde927d6); /* line */ \n            coverage_0x0dbb89fa(0xdfa94b9be81169f0056da582bc88d66b9dad5d7eeb173114dc8d1b1c36f1b128); /* assertPre */ \ncoverage_0x0dbb89fa(0xf5ea88cd1f94e4e90185e82248348f71c179b6a87cbe91b5bac34a87ec2c99d8); /* statement */ \nassert(false);coverage_0x0dbb89fa(0xcc6aa6d5b1ed16aa9a1dbba844e9c5d6143396b480bd160a867ffc2fd8104453); /* assertPost */ \n\r\n        }}\r\n\r\ncoverage_0x0dbb89fa(0x93d799efa5bf510ea257f2081e6ac63b43c894c5e233555ad050300b79be87a2); /* line */ \n        coverage_0x0dbb89fa(0xe5be931b22f115d27762afa4d0d1b47c1ba4e18a6d5b0d6bb4ddfb8a0618235d); /* statement */ \npushVal(context.stack, Value.newInt(c));\r\n    }\r\n\r\n    function executeEqInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xb2f450add9df7be6ed5225635c5e18c24bb1ea90bd0a3faa93d3acc415eb6c8d); /* function */ \n\r\ncoverage_0x0dbb89fa(0x3aa955ba8a32f7a51feae290d04a97e46d38e57ede971e7d563b8cf0e2c404c4); /* line */ \n        coverage_0x0dbb89fa(0x5eac054661c15b24075b276794c740c3ec75089c974d3d83d90ffaecef9d9428); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xaf194f2df3152120043160d3a8f2896059fbc4737cfb0f6aa8b5e90793aff5a1); /* line */ \n        coverage_0x0dbb89fa(0x0a5b2f39d65e4d3ef52315aafa6638d5f8f206aee447d1d193681e8ad049d67d); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xfe9faa94108bc15c1a20b5af8929b2ffa0fb53a7cf9911a3811014ab2530a924); /* line */ \n        coverage_0x0dbb89fa(0xcccea03548363692c2721675fa9516a9a8cb1742c0a3b13f1fea5c032a8a0ace); /* statement */ \npushVal(context.stack, Value.newBoolean(val1.hash() == val2.hash()));\r\n    }\r\n\r\n    function executeIszeroInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x24963e208c4565c49a5a1781164fe7d0b249fe22cbfb21a3a21fadc1a1395808); /* function */ \n\r\ncoverage_0x0dbb89fa(0xb0425e2e355c0c5fea527809d49bb4747531aa6e423a6620d8e0310eb03fb4b5); /* line */ \n        coverage_0x0dbb89fa(0x5df6e9c39a77c76adf2a09717bf29449e2a53a0a9aeb70da3bd2475fcb8fdbfa); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xab3af49d216e38daa077c085fb30bbcfb67e8b2d07bcd54cdd2885aad4805ef1); /* line */ \n        coverage_0x0dbb89fa(0x09fd70b9d6e401f7b00a4f12d3efe0ec11f7675a11a9aab680cf16db9e569137); /* statement */ \nif (!val1.isInt()) {coverage_0x0dbb89fa(0x146069262882ebf25f1fa8c31ca7f3d8b44a46dcf4c7c37f2e68573a13a30176); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x5a8a385225c658f7e19d82e94218c76dc24c486759bbec3534372536b1521796); /* line */ \n            coverage_0x0dbb89fa(0x7530a0022e9ccc13e127510f5552d5dbfbeac177f00dc51bad95b83d65f08ef8); /* statement */ \npushVal(context.stack, Value.newInt(0));\r\n        } else {coverage_0x0dbb89fa(0x35a18c8c1b244866bbb2d9e2618c97021955cc08ed6e5b4b5a6b4738e6f39141); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x13303c0eab80588df50fa9c84c6f785bdc837120a53600cde6b226341cb405b1); /* line */ \n            coverage_0x0dbb89fa(0x995c730c4191d8fb43090066f65e57c711b45d49f2457548237171448c16bf0b); /* statement */ \nuint256 a = val1.intVal;\r\ncoverage_0x0dbb89fa(0xb71f3c88c0b58b5e9101ac6b310d6ee5654e9e6306cd59e6a366c10247eb7468); /* line */ \n            coverage_0x0dbb89fa(0x3220d19bb748922e9d48c6e87295b75f3e327d641f86c671e9a75904e6f929e5); /* statement */ \nuint256 c;\r\ncoverage_0x0dbb89fa(0xfbd62a9e1decd9fa60e2dc234503463304577a0bfa19ffbcd81b7677eceaacc1); /* line */ \n            assembly {\r\n                c := iszero(a)\r\n            }\r\ncoverage_0x0dbb89fa(0x0c8a8428b31863e69ed5f63b6648c117207db09aaab8b512b9f59d57f96a254e); /* line */ \n            coverage_0x0dbb89fa(0xa4a28281c5540f69e1e08a63cf164c7366b0ded8e862b6c99cab1a44e7614ebd); /* statement */ \npushVal(context.stack, Value.newInt(c));\r\n        }\r\n    }\r\n\r\n    function executeNotInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x5e2648f754b03b59ff9f2802df984addc49112b07effc62bc3e4b56ff5490e3e); /* function */ \n\r\ncoverage_0x0dbb89fa(0xc040ba5b46db6a89f9aa2b8b45a37dbda559f908522597ce9efa4835c42d1bc3); /* line */ \n        coverage_0x0dbb89fa(0x70f77504b246095f4334d11210ce9644be8f9d370780feb6837a093922ea11b6); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x67c2ed086786305cd5cfcfd6281c79c2ff896b2ca474050fe5364cece7cb406f); /* line */ \n        coverage_0x0dbb89fa(0xb4cbebec93343663347eb1160a85c2569e96e5694f53c61cf056d9b488202e15); /* statement */ \nif (!val1.isInt()) {coverage_0x0dbb89fa(0xe2d643f55414894bd7151b65b27af005db6cdefcd70d04d90506e49b528ac975); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x2988386ff07717bb8addf0c75629983ec79ce44ddd99698e6333bb154e7b7e01); /* line */ \n            coverage_0x0dbb89fa(0x24669c01a1d9adeff128212e2d1f03f8fa8c51032747384304579d6391d05d85); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x8547e72f97aef3b13f45f63e4ede36bf4bffb925116ab9054e412b362aec211d); /* line */ \n            coverage_0x0dbb89fa(0x3e0ba59ac44aa061d4add9795b8a96ab27bb45f82a06afa60ed2034d2f84f065); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x06d865dd27bb27fb5061a09745058ae7eaf575a05381eb2425124449ae7b6ec2); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0xb3da9f6e59e63b848084ac91b3e65aef4bacc778f268f4272af9ce6725e504b7); /* line */ \n        coverage_0x0dbb89fa(0x6877625fd41914c67369a804aef0688cfa89688f20b3c92231f6fd9f523acc30); /* statement */ \nuint256 a = val1.intVal;\r\ncoverage_0x0dbb89fa(0x7dced97588c1676cf8e6de474c0d52a775e3f448451e4971e100dd4d6c862a39); /* line */ \n        coverage_0x0dbb89fa(0xeca66f7f8024e24fd9c7f506fcedeb014f054bfc963d766cb5453be80d70ebb6); /* statement */ \nuint256 c;\r\ncoverage_0x0dbb89fa(0x35591992be491d4b2faf8f2b029dbeb6969c1ce6fef5ef3ae32c39bf0159cd89); /* line */ \n        assembly {\r\n            c := not(a)\r\n        }\r\ncoverage_0x0dbb89fa(0x56a105b683d88b399a2db4938d3aefce85122f19f31781c1f1a4ce24564fac05); /* line */ \n        coverage_0x0dbb89fa(0x50123cbabe022d80304042baab36a0a75201f2ec30a0aa6c5acd4596b7485250); /* statement */ \npushVal(context.stack, Value.newInt(c));\r\n    }\r\n\r\n    /* solhint-enable no-inline-assembly */\r\n\r\n    // Hash\r\n\r\n    function executeHashInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xd6fd5e7be147164112e70d0d260bb681f76caf53eb957f031dfb4e8047c6c201); /* function */ \n\r\ncoverage_0x0dbb89fa(0x958e6e5bae6e6e99272dbe18767f16f1ccdb9453f58538cdd86d805a93b6bd12); /* line */ \n        coverage_0x0dbb89fa(0x6ccdfc71839a20a22dab427273baa3a2f002190098ee9b84b9012e68025de6fe); /* statement */ \nValue.Data memory val = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xa252a67302e8cfa03ed5284885c57e81ee0c2c1013190f75f956b8c3b8818217); /* line */ \n        coverage_0x0dbb89fa(0x37eb96929b5e9053cd5f2eb0286694996ec5e6c5ca6cabe62dd520a98592cbe2); /* statement */ \npushVal(context.stack, Value.newInt(uint256(val.hash())));\r\n    }\r\n\r\n    function executeTypeInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xd0db037ea3b1c20fc09e73bf23e890ec0d5e1e0b3f36fea7a28a3a89a447f10e); /* function */ \n\r\ncoverage_0x0dbb89fa(0xc078a6e3b8067fa76cb25026c0e9056ec79eb069ce450e5769bd42c534d0c0de); /* line */ \n        coverage_0x0dbb89fa(0x61c3700a4f98f5d1c5596cb362a0f51da59130f0e0e0aa2ff60a82ba34759d1f); /* statement */ \nValue.Data memory val = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x234b5319a550564717bdfe71e2ea8c92445b36c35fc0a977b122103682be6a5c); /* line */ \n        coverage_0x0dbb89fa(0x8c656981ea72f579199911eaed854ff19190c23b325e549e20b41780cc879ad5); /* statement */ \npushVal(context.stack, val.typeCodeVal());\r\n    }\r\n\r\n    function executeKeccakFInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x2358e9cc1b6072a17bd2b8ab5bc879095ee64902bde1b0040a87eb98eda44726); /* function */ \n\r\ncoverage_0x0dbb89fa(0x9fc7ef25d19eceeaaf220a5a71a5e4c823a3cedcba8545958fb1b0ae99f6f1f9); /* line */ \n        coverage_0x0dbb89fa(0x085e689b51dc3ef39374ffcdb25127aa79a57928266414cfecf7679dcd90ca37); /* statement */ \nValue.Data memory val = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xe3c2adc08ae341a3340fc1c1adbb1fbbb56166459c5094c778ef3488ce401c2e); /* line */ \n        coverage_0x0dbb89fa(0xcaa08ccd20f6fcf174535d088e6d12e2d6814c44f509eab3b89736291743095e); /* statement */ \nif (!val.isTuple() || val.tupleVal.length != 7) {coverage_0x0dbb89fa(0x188a71db2b40a756c8ffe440b5e591e8aa80e0652b4ae9703ea1f5cc4739e471); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x61c49f0ddf3a3dd49a404605c9314c7e48725b31210b20ebd50bc78e33a55e07); /* line */ \n            coverage_0x0dbb89fa(0x74a6e4c81036af36c6cf13e5788a06a7675c75458f67955ce21256a25543492e); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x82a5538d338d5983d66fec66c5b62e6de67ad851bb90485bf29438d23c7f91ac); /* line */ \n            coverage_0x0dbb89fa(0x470bc4f189741383e75c50166a526d432a9eb9f3182cecf6e4dfe9fa55e15453); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x776c882df8d6a44a2cf4f033cdd09f13d3717537c3c6cd6387e7a310c9087318); /* branch */ \n}\r\n\r\ncoverage_0x0dbb89fa(0xc59c3bb258be1204bc75329c907c105b94c707550dfd929963fc8ebe761c0619); /* line */ \n        coverage_0x0dbb89fa(0x7b23a86f4acd07b3d43fd09c71af8283521f4b3320fb2bf8b7aff98d285a6ad9); /* statement */ \nValue.Data[] memory values = val.tupleVal;\r\ncoverage_0x0dbb89fa(0x7422d39ec0b2f3b69306defec5200760637253f4d46e2df0aa45247ab3d88a2a); /* line */ \n        coverage_0x0dbb89fa(0x3e7295ced593ae73aa295b83c0919783516fe4d6b196035df2bcebff6ee4ac5d); /* statement */ \nfor (uint256 i = 0; i < 7; i++) {\r\ncoverage_0x0dbb89fa(0x07d23432040c8aabf510b7412d96c49cd3fe87231d7e8ff4137eb4b50ef1e50d); /* line */ \n            coverage_0x0dbb89fa(0xfc0cda4f78bd03cb3b5672f2c76ca1b3c09d52cdad9d6c95ce1af53f7d9f0c5d); /* statement */ \nif (!values[i].isInt()) {coverage_0x0dbb89fa(0x1246115cd45f8ec6c98a99676881a19b925c9680aa665362afa72f3a76efaafc); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x1e1aa32aee19dd7e8cdd6310a6b1940a7e68a01f1703bfe9b4aa935f20c5d495); /* line */ \n                coverage_0x0dbb89fa(0xdf12a056c2d77d586ac14867f5edd138ccb787ac57312acb4d313147dc788b00); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x5762b8d255c685cc4d40adbc3cb3b4450dacf7b532025f463c276d34dd6dbb2f); /* line */ \n                coverage_0x0dbb89fa(0x7122ab9bdff52759dad5557488ca5dfa8b206bf8b57d58009c5e3ab6d6c80d86); /* statement */ \nreturn;\r\n            }else { coverage_0x0dbb89fa(0x3656ab0baacb998480f3c72ef454015b6d13c53d74b35e77d84359868a267155); /* branch */ \n}\r\n        }\r\ncoverage_0x0dbb89fa(0x8b3a362cf7c3ec1ea5bdca62b1fc07e68222ab16f23b1c9c894d31eab9f89a23); /* line */ \n        coverage_0x0dbb89fa(0x53058a070de5a999cfa8f9860b59d64751717f5bbf596b4beb04305a82fd6210); /* statement */ \nuint256[25] memory data;\r\ncoverage_0x0dbb89fa(0x5a2f8ec1dcdb2a8cfab742cf2dcefa77aba989f1019528d875dba53fd2a0c892); /* line */ \n        coverage_0x0dbb89fa(0xed716577fb659587668b11516c17dd35618800fba494a5c06eae65a1c5b3b352); /* statement */ \nfor (uint256 i = 0; i < 25; i++) {\r\ncoverage_0x0dbb89fa(0x373c5d2bc359130dcbe6bf1eec45fd2a876b0eaa53b6ce9cb284e0d76d0261d4); /* line */ \n            coverage_0x0dbb89fa(0x36ae53d9b0f9ca66c037b2a31df3a54fbae0d88bce72ba15ba89fe864e500af1); /* statement */ \ndata[5 * (i % 5) + i / 5] = uint256(uint64(values[i / 4].intVal >> ((i % 4) * 64)));\r\n        }\r\n\r\ncoverage_0x0dbb89fa(0x13db45922d33bd0de10f81cd8420fd37ba4476b8f0a33443c166820991deea23); /* line */ \n        coverage_0x0dbb89fa(0x97734977437bb10498c92d20f9ea48fda1be25bfafc3648040f03bf3be46df50); /* statement */ \ndata = Precompiles.keccakF(data);\r\n\r\ncoverage_0x0dbb89fa(0x73f1476133766be3d7797c87e3fbf011f02561388084171b723a3555633a8832); /* line */ \n        coverage_0x0dbb89fa(0x1bfe01686cf57ccc888796a2d0a0f3e537a14a4f007b1449633f614a90b1012d); /* statement */ \nValue.Data[] memory outValues = new Value.Data[](7);\r\ncoverage_0x0dbb89fa(0xe8830eba8eac0248a28bc12736764a02770022e8142e031943fa54e9fa101383); /* line */ \n        coverage_0x0dbb89fa(0x3e2d72ffc15f1ae25350771d52ad9d8580c244f4f3276405f0d7d9beb2a0ed15); /* statement */ \nfor (uint256 i = 0; i < 7; i++) {\r\ncoverage_0x0dbb89fa(0x5003d69162c9b2c6809ace0d9ffa829b3f69a16c84c37fb0086ed02ea8f8486d); /* line */ \n            coverage_0x0dbb89fa(0x85e06bd6fd1a81bc0cd90e4c3f79031ff1c26c51260866a59f8b0b6e21d823a0); /* statement */ \noutValues[i] = Value.newInt(0);\r\n        }\r\n\r\ncoverage_0x0dbb89fa(0xe1c94829d583c7320a4b2a9058f9f8a203974641e15ad3cf54835bc452afd808); /* line */ \n        coverage_0x0dbb89fa(0x898c3957d3565e41f618d4e469e9a6acb551583dab42c04e1057fb471077b678); /* statement */ \nfor (uint256 i = 0; i < 25; i++) {\r\ncoverage_0x0dbb89fa(0xeadd376f4980cd27185e609333cbc945592b10c3b680633a732cd1af09fd111b); /* line */ \n            coverage_0x0dbb89fa(0x77791496ffe0241c8e5faf9f6d52a5d8c03c06baa62ad2ef97167421797f05b9); /* statement */ \noutValues[i / 4].intVal |= data[5 * (i % 5) + i / 5] << ((i % 4) * 64);\r\n        }\r\n\r\ncoverage_0x0dbb89fa(0xe76dd31a6c394ea5ee5ea03e02e5c57046c7cb3e88ecb04576d869aabd021030); /* line */ \n        coverage_0x0dbb89fa(0xb253108b887b21d9f0bc5f27524a48b3347761a69f97dba9754b6eced68175a7); /* statement */ \npushVal(context.stack, Value.newTuple(outValues));\r\n    }\r\n\r\n    function executeSha256FInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xf7f01c378fc53b4d2a77c2972ee68db49869f844603ea68eea0400eb85b85dd6); /* function */ \n\r\ncoverage_0x0dbb89fa(0xc2b10b6dd124ab4ffec7760aef10194d6d3614de039fd53d2fd45f104772cf9d); /* line */ \n        coverage_0x0dbb89fa(0x82cb5bccb17e009d00b564116ae1abfcb6f3ef8617b9b4a60e37b1460d804413); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xefafefa3a0d4a909f36163cb38076c8ba507f680c0bc194920de0515b9d9d1f7); /* line */ \n        coverage_0x0dbb89fa(0xf6f1b3d588397293410f0f3f451670fda67c7c53defc03da1712917fd183ad6a); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xa8aed090b6a095dc8a132500eedf19983330ff0eac07f907ff7c93178d149fbe); /* line */ \n        coverage_0x0dbb89fa(0x4dd6f3bf72eee8db53b9df121672a1a21a59cde4ce8b0c9fc0f59ebc340516ab); /* statement */ \nValue.Data memory val3 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x777529aa3ff532c18d09431d2b69d1bb381575140d39dcd767759f7b0623efd8); /* line */ \n        coverage_0x0dbb89fa(0xf17186e532b5276da0b6b29262038b15ae3fa88aabef5c70d5777c90a89fb7f9); /* statement */ \nif (!val1.isInt() || !val2.isInt() || !val3.isInt()) {coverage_0x0dbb89fa(0x18f25435d607f98f0dd9b33947016ce32f2b9895e00350938c914d2a62c3a5f8); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xc05d26c80ac56140d7dd39e9f48739e7a8e7009d64dd5fbb4a9fafb5d54bf311); /* line */ \n            coverage_0x0dbb89fa(0x6977715703b25413c00a609e043fd106deadf8fc92a1271243961c195179cb2c); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0xdd8ee88b9582501cda3d7e1cf679552ed0e2cb0cecad31f7b14177b3c7275d6e); /* line */ \n            coverage_0x0dbb89fa(0x4b0c8bfadc53ec080ac6f19b8638c1dd65bd366216769c588a826d582d45023c); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0xb78c37c8dadda3511b663fcbf8ed65a797a0e5a5eeb35f05a079f9f34e6cccde); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0xeb7290d99147bc2dd9c72d575c596ee954454ce8d970439e400c060ac1e28496); /* line */ \n        coverage_0x0dbb89fa(0xd9bc1f1e6c2f11cf06a5d1eb50bd0c4e4ca3242f972645a7812018bb4a441bfe); /* statement */ \nuint256 a = val1.intVal;\r\ncoverage_0x0dbb89fa(0x24181d6839875b28ffc05cd5b2bcbbdc9f4f16b545333ae3f0aa367db5717c3d); /* line */ \n        coverage_0x0dbb89fa(0x94f51f5887b641308a15a9b1c144687ef14a5bfe5f52ee24b5c9ae2f12287042); /* statement */ \nuint256 b = val2.intVal;\r\ncoverage_0x0dbb89fa(0xd4cffd3306d58f11e9b5341f0ddfaf91a099be36dca874f98060eda1c4024855); /* line */ \n        coverage_0x0dbb89fa(0xea28e669b0657fe6f8cef3c1e12308cb9c0fada5d3a3de4ebc21c7064337522b); /* statement */ \nuint256 c = val3.intVal;\r\n\r\ncoverage_0x0dbb89fa(0x7b9907b84b15d1f2d27a7858167bceff12ce9015fd07dd2a704e136b2aad3940); /* line */ \n        coverage_0x0dbb89fa(0x0fa69f68b9e19db6694c8dd67c59a6fb9cf5038ebbd13d6530eb43b7d1298f53); /* statement */ \npushVal(context.stack, Value.newInt(Precompiles.sha256Block([b, c], a)));\r\n    }\r\n\r\n    // Stack ops\r\n\r\n    function executePopInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x29da7b5e960802e978a55e90c5fa2f7ab0a1f6aaed3a1c442cf3dba193141dc7); /* function */ \n\r\ncoverage_0x0dbb89fa(0xac83e1f1483000f14ee214e42c1c1b3c0ed2f992f4aa747fe8641a14f87bf853); /* line */ \n        coverage_0x0dbb89fa(0x7455110fadd878ae257022003e8c0580c7622c3d2fe3814d49fb1357debb9575); /* statement */ \npopVal(context.stack);\r\n    }\r\n\r\n    function executeSpushInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x03428f66096236b4b9343be88847749504fb31af3e934082b2220b5324e1ef7b); /* function */ \n\r\ncoverage_0x0dbb89fa(0xadc43e8dac4263d31a9596c6457ba821a8a24ea4e8187f3c91cb1df2d6518558); /* line */ \n        coverage_0x0dbb89fa(0xc33969ac464bcb8676036b74542748c179b4be9caf13368113c82a3eb4f28282); /* statement */ \npushVal(context.stack, context.afterMachine.staticVal);\r\n    }\r\n\r\n    function executeRpushInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xd693c55951c34a5d9b6ecae7df1ebed42ab6b148de02a48fac808710d8c8976c); /* function */ \n\r\ncoverage_0x0dbb89fa(0xf8e518dcf1882084cc39bce05a6bdc3f833ecdc7931c0f23c3562859b0bb232b); /* line */ \n        coverage_0x0dbb89fa(0x1f0f1ff515a7908cb7e36d34c3321632b4da8e5e9bd0831f58b9034852b5759b); /* statement */ \npushVal(context.stack, context.afterMachine.registerVal);\r\n    }\r\n\r\n    function executeRsetInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x65371dd22dfe2114a5601fb77bc97b469c2ee75d6468580150a083721807199c); /* function */ \n\r\ncoverage_0x0dbb89fa(0x581c0d8c29659c6c14b076b2f4f0fa357c3450368bdc0406e3c99e54c4fab1c7); /* line */ \n        coverage_0x0dbb89fa(0xe49ad2cc46e7656c5838c29c11a58311f546e18d8688aac76d66360938af1c43); /* statement */ \ncontext.afterMachine.registerVal = popVal(context.stack);\r\n    }\r\n\r\n    function executeJumpInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xa95b7479542aa026eeef1d75176c9acc7ff43000c8c869dc5b3a0e00f747bd8f); /* function */ \n\r\ncoverage_0x0dbb89fa(0xd3da19cee7bfa1658ea61a29d06cf6e3ef73adc8931947d32cc1f6fe251345f9); /* line */ \n        coverage_0x0dbb89fa(0xf677ffa9f9a3ccb866a9168a14842e37b5be0e186ae92b1f0aa496f4edfedf31); /* statement */ \nValue.Data memory val = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xaa51c37a5cd6320f52e1dbc520331e3b70ada8a08ba2d42ef34a7f2afbb1846d); /* line */ \n        coverage_0x0dbb89fa(0x004192818987995dc072569a2d4b2833a8c45e51d4116e143907a4bc55621298); /* statement */ \nif (!val.isCodePoint()) {coverage_0x0dbb89fa(0x306773190cf7c871704ee025e59547bcb06435b65950dc3e83b8f9d268ca3d05); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xeae64bda4c7d0a9e0772afcf973a4a82965ce2273ba07608ffd340f42aea240b); /* line */ \n            coverage_0x0dbb89fa(0x0604f2994641b3385260274b8dfafb6a17ef468e792784b08a319a472063a907); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0xf867469a9bc459c3b7dc71ccd49034e199015f587923457d88e798e0775176f5); /* line */ \n            coverage_0x0dbb89fa(0xb2d2b1803f639376a7be99b5cc700f9b7314c56d2bacc4755cbd57fce2715d15); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0xd0f3cd461816b2d78cdf77b40fd23991f5999a387b77ddd5400cdd7602319f1d); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x9b3abddd860696be8966530d0b8543b10a950ce0f2d5106cd4119c7cdbd38dc5); /* line */ \n        coverage_0x0dbb89fa(0x72108e62ad5ad323cfcbad1915dc4e68c2d37128877dc5b5f0325c5bf5c19b5f); /* statement */ \ncontext.afterMachine.instructionStackHash = val.hash();\r\n    }\r\n\r\n    function executeCjumpInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x4e9c2654feb80367629b8806fb65e86792268fbab7f6a92a4dd832b2ec3d5120); /* function */ \n\r\ncoverage_0x0dbb89fa(0xe23a55ea265d27677ac1f33f33e0da303bf7ec45851ee51771235a760dea6634); /* line */ \n        coverage_0x0dbb89fa(0xdb27c40dad5219661c8086d15e2e42d508514b2448ac96cc8c0a42b44a3f1a38); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xeb329728103ae65c8bbbc927a7a119660e61101264370b9a75a3bef03d004807); /* line */ \n        coverage_0x0dbb89fa(0x0507aef787c125fe85283010b5e091f2d2195f371d80da3d600c73317c28fedb); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x81d8a80bb27de0c4e302080a15696112ca29be250feb4431e8614e9bb84504cc); /* line */ \n        coverage_0x0dbb89fa(0x9f2a702f4f5c9da13d57741abae4363fa2c5367d24f4b4d6296d4393bf1a83dc); /* statement */ \nif (!val1.isCodePoint() || !val2.isInt()) {coverage_0x0dbb89fa(0x57b58ee7b125862923f38bbd5e17ac19b60769d49adb7daffbfc24bd6a74d1f0); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x2e6d8490fb01fa3c5d19d8ee1aa11d4c6c68acd12c25073ec20086b04733a1bc); /* line */ \n            coverage_0x0dbb89fa(0x52b11a264be274e47bd15b07fb4f4927c566f19be7bf295b36ae4f421a80cd9f); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0xa9a6f0a9076efc9d2e904b47b410ae973cec24d1832d61f395ccb1742ec3d945); /* line */ \n            coverage_0x0dbb89fa(0x0d16480d325a6726440eee14f96620fc5d381b51b1a4fcf1fd94fbc587e0cf87); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x027e9c51656fcbfb7c4ace4ec57d3ed254a5166d903d234b218f858b9696bca7); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x4eda3dded69111c4097916a828a85e5e49c42ef7544fdfbb2a99c79f2a884f25); /* line */ \n        coverage_0x0dbb89fa(0x7cde79fb85496694706a21c219ad007df20ba8b22a1094c0154ac65b5d938955); /* statement */ \nif (val2.intVal != 0) {coverage_0x0dbb89fa(0x0dab6be69dad545e735ef0636fe7e9e7eb8e001141577f946d1eeb61671a5224); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x9c063ca4b3cf57b6ef2fd2c98d4120626390b92d9181df08c76ee1741de53066); /* line */ \n            coverage_0x0dbb89fa(0x39bcc5991d309b6795aeafe158391732c7d7b2ba414c5a479dc0c0028c9523ad); /* statement */ \ncontext.afterMachine.instructionStackHash = val1.hash();\r\n        }else { coverage_0x0dbb89fa(0x6b8ba7f24d1d6246f86820f8bb3eb4edb2c58f19a89b858339bb74b95175b80c); /* branch */ \n}\r\n    }\r\n\r\n    function executeStackemptyInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x3ad5d2d8749569e514ac345e6a9220bf781eaebaeaba6cd72d436556bf6fc76a); /* function */ \n\r\ncoverage_0x0dbb89fa(0xb0e346dc4c4643204124e71f00076b5534a572cafae27d04f45cc1cc33569fac); /* line */ \n        coverage_0x0dbb89fa(0xd002a2f10b9acffa7aa6bd65999db736f88bb9f571658488afdb84a9fff31324); /* statement */ \nbool empty = context.stack.length == 0 &&\r\n            context.afterMachine.dataStack.hash() == Value.newEmptyTuple().hash();\r\ncoverage_0x0dbb89fa(0x12a305dcd1a263bd9fc62ba16d3536cf2a5205fa311b5a7035121dc8e938b7e4); /* line */ \n        coverage_0x0dbb89fa(0x36791fc1479a6fd85d544e654b4e26e44ebc551b0dfec37b3aa8b4c48279406d); /* statement */ \npushVal(context.stack, Value.newBoolean(empty));\r\n    }\r\n\r\n    function executePcpushInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xc44f0b21a42e18181d5a1b0394dc86f0429f5ac8ccac65a3b731b9486957ff1b); /* function */ \n\r\ncoverage_0x0dbb89fa(0x360a6c4fb5932ec454c61fda38bf3839bcd9ebabd714e25f27096d701b7b8284); /* line */ \n        coverage_0x0dbb89fa(0x9df9a6169204faf3bd462d6c5606f481692748b089754ea7539c4134325074d0); /* statement */ \npushVal(context.stack, Value.newHashedValue(context.startMachine.instructionStackHash, 1));\r\n    }\r\n\r\n    function executeAuxpushInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xeac8de3a868cbfadc09bedebcdfb0fc060535585415c9f387cf03ba391338099); /* function */ \n\r\ncoverage_0x0dbb89fa(0x06e9ed481b2fa011c9866918f50a8ca932cbf40ae9b094852e2894fdad4925ab); /* line */ \n        coverage_0x0dbb89fa(0xc2a69deca55044ed1ed8c58ed090ec06c12ec97c2909a2db807db32bdd71740a); /* statement */ \npushVal(context.auxstack, popVal(context.stack));\r\n    }\r\n\r\n    function executeAuxpopInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xe2518083ebcf1515fbe125a0ef83baa899e7753042ee3fb96ddf3f8f25661d8c); /* function */ \n\r\ncoverage_0x0dbb89fa(0x2cb7e0516be84fafff917415a2c1b251e194e43be595669401e03e6e793ffdee); /* line */ \n        coverage_0x0dbb89fa(0x702c6fbcc02c96f6fe6528f827b53b7070cb6b3a0a15d3562446c1974b3eebb0); /* statement */ \npushVal(context.stack, popVal(context.auxstack));\r\n    }\r\n\r\n    function executeAuxstackemptyInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xadb3a5b7cd4128d0642050c1d25b5df7d139811c2c9d2882c09e8930d178d04b); /* function */ \n\r\ncoverage_0x0dbb89fa(0xb2e31579b880290321ab24f3011cff4eb662a0a8e069d80022678d5ff9b9f5fa); /* line */ \n        coverage_0x0dbb89fa(0x5f34107f778f182f77c741a2458824b44c158b68948e5be324cfa66d548d1a1d); /* statement */ \nbool empty = context.auxstack.length == 0 &&\r\n            context.afterMachine.auxStack.hash() == Value.newEmptyTuple().hash();\r\ncoverage_0x0dbb89fa(0xf5b0ac5626bbb1f552e4b041907994fae6d116f0c2a7a3db288323bbe6515640); /* line */ \n        coverage_0x0dbb89fa(0x530a1bd3c44a9bc369ced7e9a6b61aceeb3279cdb27381436357a7cb98d5f7e2); /* statement */ \npushVal(context.stack, Value.newBoolean(empty));\r\n    }\r\n\r\n    function executeNopInsn(AssertionContext memory) internal pure {coverage_0x0dbb89fa(0x3a538d83b00c3a29fca910b039272fd77264e08969fa99d36549a0a7a9b8610f); /* function */ \n}\r\n\r\n    function executeErrpushInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xdfef5da7496b6de4e00f8dec38d883951f0f505a7b06408983a1b1442eba7654); /* function */ \n\r\ncoverage_0x0dbb89fa(0xddb1ff831808960ac7d6bc5a3349c0311043e464e9aec92250b2fe4b71908ab3); /* line */ \n        coverage_0x0dbb89fa(0x4552c352b127895e6a0ceecc8723ab4d28d679b7378f9fc4354a3113e96d16a4); /* statement */ \npushVal(context.stack, Value.newHashedValue(context.afterMachine.errHandlerHash, 1));\r\n    }\r\n\r\n    function executeErrsetInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x697eade098a3e3b66bf74d22c1467e8dfeee2b003e230b6312ea543bdf9a0529); /* function */ \n\r\ncoverage_0x0dbb89fa(0x5718fb48cdf59680e4897320c411fce4e9f2465af9c45850258048f5b2867fe3); /* line */ \n        coverage_0x0dbb89fa(0x36d3fdc1916b3a129d25a9f10fc9e73489db7e6855fb76016480ee677406b1ea); /* statement */ \nValue.Data memory val = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xdeb93a4c1e641cacbabcbf53729b626111366333165f5947cbeec7f91d5d414e); /* line */ \n        coverage_0x0dbb89fa(0x7d7f4ed7867c947d34bde4af570c5266ddf4d674546d51471bbbb4ac153d025a); /* statement */ \nif (!val.isCodePoint()) {coverage_0x0dbb89fa(0x66554e5a90ae639b67cfc699179e6ca0ca25a500ffdfb5e7d0e0e6ed4fe24a78); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xc1ef4acbaabdf31ba639a6ab50ac8aff66a71bbe31b5edfbd160ef477eaba491); /* line */ \n            coverage_0x0dbb89fa(0xfb31a4edf7b0a5dd4b581ca194ad1c543abf1886b743df57f10ca70745074479); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0xbe4a864dd766ac4ddc10dd6026710e60cb369d97afaed2810ab2864058a3aabb); /* line */ \n            coverage_0x0dbb89fa(0xdba217281a03af46ec0a764fc3c060c03abaa049d100ff15b9cc361be9d50098); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x5acd4eb701f9a14fae04cbb8a61c9000c9855e6d5b6ec4cb2a26d8ab75274f5b); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x052a7dd3d4a7a536a16186942771947843d05de633cfa5009b8bd2ad2ac59da8); /* line */ \n        coverage_0x0dbb89fa(0x2e49944fc1b914fbe64900e26d0ba02d46dc837372dd91df7e93eddd99092931); /* statement */ \ncontext.afterMachine.errHandlerHash = val.hash();\r\n    }\r\n\r\n    // Dup ops\r\n\r\n    function executeDup0Insn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x1d886144a7b12891acb813d3190d72256aa218a98e40faa4e545e486a7f3d325); /* function */ \n\r\ncoverage_0x0dbb89fa(0xd70a533606c6d6f49e2602012ebb0dc49d1ada8aac64e3385cda0e0b90f8fe8a); /* line */ \n        coverage_0x0dbb89fa(0x7affde64071c526399044df05014ed0293d3d9f0616adce46c4d9dc0b08e2d3f); /* statement */ \nValue.Data memory val = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x3d24ecf5b2917fce591e9a138f3e44a19136d48a3619fb2f180c4beb8eeb35b4); /* line */ \n        coverage_0x0dbb89fa(0x357e19298e4d370a6b5327ebb1a107fe8331c332944df511f9241daefa6a7a71); /* statement */ \npushVal(context.stack, val);\r\ncoverage_0x0dbb89fa(0xc3b932b5b333016565b5698b8a27d890aeb7c795be4d2611690394b91c2b5d19); /* line */ \n        coverage_0x0dbb89fa(0xf1ecfb39f6900b9015289f5211f03523286409044331926db73749a3cd5ae8b8); /* statement */ \npushVal(context.stack, val);\r\n    }\r\n\r\n    function executeDup1Insn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xecb32f23befdef59008b841d745d97eee58d201382cfba9a63c7786ea18b540b); /* function */ \n\r\ncoverage_0x0dbb89fa(0xdd8796f113f923b39a9c2a3e6577419425f8d848cf1756624fb53cf7493cd413); /* line */ \n        coverage_0x0dbb89fa(0x63fbbdd1efbe574754b6bc43159d9d7ea00739eece3b501f66ff693890ce387c); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xb8b211733764222e67644d265fd045573ce342a916699e981893e2fd5e94b522); /* line */ \n        coverage_0x0dbb89fa(0x9827ace3b01d7f60c163a938e2625307fbeabd02fb0632dda9bbc73ce24187ee); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x0d15f714d9375d9e1ddc76254023dbf1f15d848affa55cdfdb8614a3ebfe1103); /* line */ \n        coverage_0x0dbb89fa(0x1becdbe09c8caee87d9a81a6d28a0737ba3a6734ca8d0aeb3c15458bf3f8cfaf); /* statement */ \npushVal(context.stack, val2);\r\ncoverage_0x0dbb89fa(0x531110487c3c012f227dae071123ad73217107d6989b3935b6ab03c246f6c472); /* line */ \n        coverage_0x0dbb89fa(0xb4a86f97673c2e3d22105eedfb8521560e1c1d635bc33bf8f0503346697c8112); /* statement */ \npushVal(context.stack, val1);\r\ncoverage_0x0dbb89fa(0x4a67cfe2e36fcc87ed69f8943332ee7be237ea70765523818c3dd3d7eb65c5bf); /* line */ \n        coverage_0x0dbb89fa(0x08e6152df28312d711429c9374d3f98130d72e9a496599a4284a01fe45d3b366); /* statement */ \npushVal(context.stack, val2);\r\n    }\r\n\r\n    function executeDup2Insn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x117d7f397c016db82712e23f28ba17186a79a4eb9734b3d6cef79ce8d6f0055c); /* function */ \n\r\ncoverage_0x0dbb89fa(0x4cce5126c691fc78fe54b003ce5e4c691b5d5e9b8f5e341b70579d7a3319e6f3); /* line */ \n        coverage_0x0dbb89fa(0xf8631108ffebfc23010f58f381fec1c9218342c7f8af3031413faeeef93cf94d); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x4ee643f3c34ccaaab397431c6a610d37186e1bc22b46723bb50d93e2421a2e7c); /* line */ \n        coverage_0x0dbb89fa(0x7c27f6c228035e8715a73f2e5dde64b13c27cde4c3106d579ab0ad2ec29df558); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xc1e90c3b51a43ef28e4f078ae13461f7ac59c551bb51fa1acbabaa2b91dd7fc2); /* line */ \n        coverage_0x0dbb89fa(0xe8c4bdae0681e29b82c6c42bc39a18912c07a04473a248d87cfd4ec131101b69); /* statement */ \nValue.Data memory val3 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x8c16cd1dc877530d77aa1facb92f68179ef833a1fd4754c0e563cfe99fd0472e); /* line */ \n        coverage_0x0dbb89fa(0x1087c94d54bda9668e5d34b04d74c57ce4eb3b14ec4581a5104dd922be05637c); /* statement */ \npushVal(context.stack, val3);\r\ncoverage_0x0dbb89fa(0xa259999c1b96f5de1e62ba3b6273cf176a3d3d43d4d2d6d08200b2da767a96a8); /* line */ \n        coverage_0x0dbb89fa(0x5f9812e2ea62cd5ec528f7ea4b60ef5b694f4880c9ee2e09e10be95ee29e28bf); /* statement */ \npushVal(context.stack, val2);\r\ncoverage_0x0dbb89fa(0x09ee161355aaa2788f4abae4ec6a606d6fca790c1ce636f48d24ce408b9b832b); /* line */ \n        coverage_0x0dbb89fa(0x4320528c28096a14ae254bab81234509864ba29aaa1e3f64431c65cd5d01b516); /* statement */ \npushVal(context.stack, val1);\r\ncoverage_0x0dbb89fa(0xfa23a02e831767fc4f35c25afb1bff0275f1aee051ee52e9eafc0381f8f7db29); /* line */ \n        coverage_0x0dbb89fa(0x2b99c1f5ac96af6c706e68ae2d5ff65533a1b7bd6cec0a34e304247cccb052dc); /* statement */ \npushVal(context.stack, val3);\r\n    }\r\n\r\n    // Swap ops\r\n\r\n    function executeSwap1Insn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xb8e03b3bab730247b9d6c2656cc3a934041553c082f2b19933aa83deca5ddad1); /* function */ \n\r\ncoverage_0x0dbb89fa(0x13c007128e40b8f4a3f91036671e48327ca425ee20fb364984d0a0b60ba17717); /* line */ \n        coverage_0x0dbb89fa(0x8bc2ae07735e9d10b7b01263dc66ebf02e30ee945b7d068bd6659924bd62fcd9); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xca2318b073b0cffad909e86fa783d2293dc270f653f7f7e504ce0bdc1d73c808); /* line */ \n        coverage_0x0dbb89fa(0x6d0e9fd85cae94d4200dbdd5c7a0ea257c32c20521e760c92996928e93fa9b66); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x0ac2caec199f599e51051e69257d5a0258390a709121d039e3e18bc6fdfb944e); /* line */ \n        coverage_0x0dbb89fa(0xfe4a2150ad116e231e52fd3a32d1adfd9143a455dfb46e90b7c569c70873776c); /* statement */ \npushVal(context.stack, val1);\r\ncoverage_0x0dbb89fa(0xf096669648743d455ff4c7bbd8df5a928fd8f708d53bc2a1c91f4e700ddf0fe5); /* line */ \n        coverage_0x0dbb89fa(0xb9c2a7b4be3dfdb3b79d76a217fda7e530921ea57375438c01145b617a4cdfce); /* statement */ \npushVal(context.stack, val2);\r\n    }\r\n\r\n    function executeSwap2Insn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xd359410c5e49431401e0bf204a65c5144d120aa80ef2dab67d647b6aea620f53); /* function */ \n\r\ncoverage_0x0dbb89fa(0xe350d4c636edffa5b73c3f01585331eac082c3ae7a1919b500807769f43fd0b0); /* line */ \n        coverage_0x0dbb89fa(0xd8dd2bf598d93e6fc7308677a52111ef78b37ee1ccd451b8d967258a41e2bbab); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xe162a237f82cefcf10395e056aee5ab9f07a90c2d7e7fde2b6920dfa009db0b7); /* line */ \n        coverage_0x0dbb89fa(0x4e4804b16d29ce43ae6a25c714e81a65047d03dae6a9d57a3d7b21b69860e243); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x668a1f6b0909a5e1f6ee039079e0cb4623e460b55ca91d049c5589bfadd1353b); /* line */ \n        coverage_0x0dbb89fa(0x52db9088dfcbe8cac08c7f50c73952620d04a4303d1c5c24cba3bb15e0e65852); /* statement */ \nValue.Data memory val3 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x899327081ec111ce9bee16e3665f1a71126a7e2447afe6793cf36df2fd0b8e3f); /* line */ \n        coverage_0x0dbb89fa(0xd894ffc157cca26dd44ee884e7dc4b40b78a7b0dc5a07ebbcf7afd2668fcf467); /* statement */ \npushVal(context.stack, val1);\r\ncoverage_0x0dbb89fa(0xe55dea21ec3d7ef7512349156258e4248a046c46a7c2bbb6b1467e24890fa6a2); /* line */ \n        coverage_0x0dbb89fa(0x346d06e0b9a3f23c303e023f53a85e33923fc90f156a68b673c89112f00474f1); /* statement */ \npushVal(context.stack, val2);\r\ncoverage_0x0dbb89fa(0xbb5914ab093695df81b9f368cc58597a9f3fa6b1a6a30778eddc1afd2bf0ff97); /* line */ \n        coverage_0x0dbb89fa(0x7863f16b8c5718ea9e80af0fb97dd4b72a843796d9bbd5b3a2b713ea5ea6036c); /* statement */ \npushVal(context.stack, val3);\r\n    }\r\n\r\n    // Tuple ops\r\n\r\n    function executeTgetInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x269df0b62ff57a75b1fa2cc967dfa5434bd9160114f41fb72f2fb6eee171266d); /* function */ \n\r\ncoverage_0x0dbb89fa(0x1493336e59a753e0215d2d14604ad6512d8900b99eb56e84435c27c932495688); /* line */ \n        coverage_0x0dbb89fa(0x3590e1e95047fac64d7984e4bcd0724c32a6cf44b72855c291b05b8b584964ad); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x1d35fa8e6bf3b2252957460549580e9be63618ada20c9678c8ff372e62800a93); /* line */ \n        coverage_0x0dbb89fa(0xa58e36ba46c4639206e1a94b230572fc6f7b6544ff78e34a8bb4da0b3c6b5333); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xcb6e481578ee417bf487619d21f3a92ddd08f24ed89cd023811ccfa7c163b61c); /* line */ \n        coverage_0x0dbb89fa(0x4a8a62dd5810cf1f7310fcb54be7edc6308631bb7cb5614a8f38f14719b35115); /* statement */ \nif (!val1.isInt() || !val2.isTuple() || val1.intVal >= val2.valLength()) {coverage_0x0dbb89fa(0xf28ff9e5f866aa73d8ce75645a855f0a8668a1c0d647da07eb367e2ef48bceb7); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x9540a4983c5cedcb8bea251e335b42c6d98e51afa629a6bf8dddc617d6bd630b); /* line */ \n            coverage_0x0dbb89fa(0x1a6bd86df695a5119952e76a185c2d61c9a0a0e8ade32876138534d74b54b8b1); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x82ac3135fa3a06c1feab68e1842e0bcb09ac3a8aa3167b4abaa2aa132fde5fde); /* line */ \n            coverage_0x0dbb89fa(0xbd77b3b25c3be9f69fb37de1cd799c33edc90957521604c4c1f2b5f48e4270d6); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x8def5033bea76fd3f0c2fc8cfb4f701e11a286a592074d2615410b62d457a0dd); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0xdf0073be00dd559969b25b594ef3642031aff2d94e7ef25906478598531cc5d5); /* line */ \n        coverage_0x0dbb89fa(0xf4e742f5b415fa60802cdb7854220df4384bb8e55d385a4eab36ca376fe39252); /* statement */ \npushVal(context.stack, val2.tupleVal[val1.intVal]);\r\n    }\r\n\r\n    function executeTsetInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x2a99df1073969993bf955a2bf088787042c38b81040373ebc74a6d0ca6ddf7aa); /* function */ \n\r\ncoverage_0x0dbb89fa(0x841f089416d50735ac045022d38b703eb1c162d0d6f6f7353a0e583f5fc5fa73); /* line */ \n        coverage_0x0dbb89fa(0xef8cbcd7b5df0d76b726425757cdd62fda31d1c212639256f6e9089cbc37751c); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x7eb52249e3a9771e2f3d597ae69858df804eaff5e82cb8ed7b85b466d4950e7d); /* line */ \n        coverage_0x0dbb89fa(0x87b766f42f0796f5ff2aacddccc9f0138d893daaee262894396afbbdea8c9d41); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x3f293efa4138b80e1ff53d3deb62504a923a2f96c0fcb83fe395bfc0adc45058); /* line */ \n        coverage_0x0dbb89fa(0xe1a40294512b7182ab37c7c00f36a46b6070da0a3feb4538ec01e6eaf3767e39); /* statement */ \nValue.Data memory val3 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xe52d10475223d7f18cb423e00be0b5c0c103fe0f458cfd9bc8cd9c52adb17f0c); /* line */ \n        coverage_0x0dbb89fa(0x1260a54f1d764f7c6ec1d4d2d8d40eba4ca8d0f74aba06d65f78ed839aa4165e); /* statement */ \nif (!val1.isInt() || !val2.isTuple() || val1.intVal >= val2.valLength()) {coverage_0x0dbb89fa(0x9853a448f69631f30ad2d40800bdfd02e48afee1f041e6aafd1336a7d6e1dd44); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x7edb2267e1fabb9646bed7fd930fb1d72142f6855c598f86f68a77fb0437d3bc); /* line */ \n            coverage_0x0dbb89fa(0xb72362c5f1788c4d617d5e8785fac1f34072362b4ee6c3f718c5055749f83780); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x728899e8a90582b6e250ebf4f9f846c91c754fc3e31012ffdbb0fdb3be6a538c); /* line */ \n            coverage_0x0dbb89fa(0xe1683801aef9a56c469e1d0baa71a4fb9cd9c2b34b1e770a29f69de543d8df8b); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x4ac67a1926be7644ec1725b85f513bd54c4e414467c7a22d44c6d19a901874cb); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0xe2f0919cb02593a584c8d93b0b2b69584876c751b4e1b681dc044684affcc08a); /* line */ \n        coverage_0x0dbb89fa(0xd2b8086473197e226c63f9d5a5b3ffcbfa1589adb6ed754b2172e1f0cd735ba6); /* statement */ \nValue.Data[] memory tupleVals = val2.tupleVal;\r\ncoverage_0x0dbb89fa(0x9583ab9054ed7397747f55fe331f30854eb64af8882bf1523dc396610d2a9de3); /* line */ \n        coverage_0x0dbb89fa(0x71c094fafe8d46aef7e1fb4d1510c09fa5417de5b0baaf930d302f2e0ed268f0); /* statement */ \ntupleVals[val1.intVal] = val3;\r\ncoverage_0x0dbb89fa(0x03580dab742acd8f5901e0d1858ef987d082ad087202c4a8d54bb4dae87a156a); /* line */ \n        coverage_0x0dbb89fa(0xe3919fb2f87ac92635dc1d7d7a10302280fab66a8e9a5dd2f198163686aa34bf); /* statement */ \npushVal(context.stack, Value.newTuple(tupleVals));\r\n    }\r\n\r\n    function executeTlenInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x62ba3efa02b19bc1e513cf8123f6d35422912af04daf4bd5f8ab77db12771211); /* function */ \n\r\ncoverage_0x0dbb89fa(0x6b8f0d6da6a79a34e6dceea075fefacc4226285e0bff5867bb75d2ffdfe350e3); /* line */ \n        coverage_0x0dbb89fa(0xe8958655bd8748247adf3fdfecde53c95b986edfc69d19a94b959af0cf2107be); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xe4e4c58948a82b3732da0df464a8d61793e7243b2696190534775b6794e61302); /* line */ \n        coverage_0x0dbb89fa(0xd0c36937b371f41fef096eba1bea0d7a919a814a8da5405ad6ec368ada862d27); /* statement */ \nif (!val1.isTuple()) {coverage_0x0dbb89fa(0x16e85766bbd7e4a8510436be54e2b02296360b6c3260cbe9a93e2c28189ce9d6); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x6ff9f94a095d5bf515524156f132cbb5718237ced00df0ad52a52d10e435750a); /* line */ \n            coverage_0x0dbb89fa(0x9ecf6d49460dcd5e26d0c9414d8526ae68c8d3a0cb80f1e6f8ed07bb5c776ef3); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0xf6da2fddd775c54f20621571d1e294679ce7c2d56954a171fbed2077cc5fef9d); /* line */ \n            coverage_0x0dbb89fa(0x2f5056374778b640610e01f7c6900ad0b52b7a17576bdf13e37fbeaf97e5fc48); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x34aa21f6cf7a2bcfd9aaaacdb2cde509d51298f8c7b75bbde48fcc4cf7e4e967); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x7e0bcb747a0d5d7d6be6eaa1f32d090b8757c22ab0773df3541377f858278cd2); /* line */ \n        coverage_0x0dbb89fa(0x62f6c1c0057b8271aa709bdd31b8c03daa629baeb202a99abcbca1657447cdf6); /* statement */ \npushVal(context.stack, Value.newInt(val1.valLength()));\r\n    }\r\n\r\n    function executeXgetInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x876ff980cd480dd71c4a8bc4d12f415b3a0eacf58640113d927cb91ef1092b68); /* function */ \n\r\ncoverage_0x0dbb89fa(0x09225ae7a83d467561e0f07adab72b503bf533e167e7aa178fbe89e5ee18de43); /* line */ \n        coverage_0x0dbb89fa(0x507961efbdeac29c6b589065111cbff395dbc6a7094f4bfd551a6ad61362831a); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x7f983ce7f9035de8df3413b435e5f0f35e2a4c45bc1c63b2337567556ce334de); /* line */ \n        coverage_0x0dbb89fa(0x1d615b4643de4644bac4b75a458ee9700d4753d726897707233bca171950c1ef); /* statement */ \nValue.Data memory auxVal = popVal(context.auxstack);\r\ncoverage_0x0dbb89fa(0x1539fdd6bc1f09c55f2cce355f69e51d6f58c6b3eba96363446ad03590497677); /* line */ \n        coverage_0x0dbb89fa(0xe91bf05ad37d2a0612e6869b66fc033f0510f1f45682aaaf124f711f84707723); /* statement */ \nif (!val1.isInt() || !auxVal.isTuple() || val1.intVal >= auxVal.valLength()) {coverage_0x0dbb89fa(0xbf8d1db024358db7c6e2ff8c7030394ed224fcda2ccea54878e3de149c20f5d7); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xbd5cbd3bb153b59714048053ef23b043b610444714f0fa8ee40fc9f264ccf553); /* line */ \n            coverage_0x0dbb89fa(0xc64ffe4f439f8e193443bc426d449488d00eb52ebd6b122c32c0448923beb6d8); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x0d751983a7c334daa596ff60f7633565ad92b4c6e667509e8afab28fe7240bb4); /* line */ \n            coverage_0x0dbb89fa(0xd3bfbdd1b7f589ef820475bc363cf6992ee07103fd8a94ab773b62e113d1bf4a); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0xf00042ec9f2d28a40fbb65f3d60fa54b961c950fceda0e0914552f9ba5bdca65); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x1b70d8f6ec3760b0b916dc4eace9deb4980e59b5d5bd8076942fdb97b4870275); /* line */ \n        coverage_0x0dbb89fa(0x5f8cc7d02c2d6a7c14677ea4086631693860089ca9f1787a0733922c46374f7b); /* statement */ \npushVal(context.auxstack, auxVal);\r\ncoverage_0x0dbb89fa(0x79a2388e1e8eb078f8e49199931e9761eba136f1b498675753915c5d62d01753); /* line */ \n        coverage_0x0dbb89fa(0x4f7c884fde791f149c022d6156a458ad26e1dc1fbdcf03865543f9f68b3fbdd0); /* statement */ \npushVal(context.stack, auxVal.tupleVal[val1.intVal]);\r\n    }\r\n\r\n    function executeXsetInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xb6a435a0493eb345aafddcd03553b083206884786b269cb2d307d2566d198d05); /* function */ \n\r\ncoverage_0x0dbb89fa(0x4f63219fa76c8e40bd7dd8613a1f1305e638376c223fcc66582bae29ec91ea17); /* line */ \n        coverage_0x0dbb89fa(0x31b71a572ec2246b44cafbf4b9f11bd9d0d2c8d342791bf20b905a57c091edca); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xe78f676737e3e07fcbbd0926badb59aa87c35f5afa4f97b7711472a29f775483); /* line */ \n        coverage_0x0dbb89fa(0x3b283b83216a018d3b0e7a68a84aa32e7f09bcf965db758cf946f5f46dc9d980); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x9a1d4cb7e837545a8d54fa4454225fcf3d2850e9663a09b6bd4539132462d547); /* line */ \n        coverage_0x0dbb89fa(0xb69d3c7566b04dd5990c8c099a881adfdd7ac41e4777ccc440c7d6bfc160c518); /* statement */ \nValue.Data memory auxVal = popVal(context.auxstack);\r\ncoverage_0x0dbb89fa(0x41f5785dab1d8495ce425e28fc069ae82a39b9cd83edde5ac2caf1fe61f8dc57); /* line */ \n        coverage_0x0dbb89fa(0x54d2358a0dde1d3287f3de6205f2c345c299812f4ef3afc3a1334f6a6352765e); /* statement */ \nif (!auxVal.isTuple() || !val1.isInt() || val1.intVal >= auxVal.valLength()) {coverage_0x0dbb89fa(0xf632a6e953da14e260acf688d387a61282911c4d71f9f1407563d31cdc0cd7a3); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x2094b72af0b3f307fd8851f2522dbb4898baa127a6d873482cd8a75dce2287c6); /* line */ \n            coverage_0x0dbb89fa(0xb754b054e1fa860e1b10546392442d1335640f94b9a1f25ea72873bed1231390); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0xc51ec69ae2d76f86b1935a639afcc51a6f3e44aaac748ad676d71a4874ecbae7); /* line */ \n            coverage_0x0dbb89fa(0x39c62521cced991aa1bf772604a86d927615b900d21167e43c1bb7a9dd7aab5f); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0xa95bbeca1686cb43c01657aa67a579f690a86846b80821efca5d0a65f8cafa42); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x6c4eae577c989b96fc16504e241cf7a57604885e4eb054fe616a0c732b84cafb); /* line */ \n        coverage_0x0dbb89fa(0x03cb9a0867fbace3c8436e235aee08fae76f07d5db4bfb4c127fc94be89c964c); /* statement */ \nValue.Data[] memory tupleVals = auxVal.tupleVal;\r\ncoverage_0x0dbb89fa(0x1e7afb70d5fd27f17314de4ddf9c9b61b1a47ad4885388720a9d143cccd8671b); /* line */ \n        coverage_0x0dbb89fa(0xa28f784b60decc31c89f480e48532a0d0b1cdbfc14ea09bb26527f913542e34c); /* statement */ \ntupleVals[val1.intVal] = val2;\r\ncoverage_0x0dbb89fa(0x7de1f7e90d95e0b4560c5053a345efeeaa7aaa97c2174c6a519480b83c35e270); /* line */ \n        coverage_0x0dbb89fa(0x15aca6e8dcdfead60c7a2e391dea1d58eaabef659cdb9c5184ee445f351ec9e4); /* statement */ \npushVal(context.auxstack, Value.newTuple(tupleVals));\r\n    }\r\n\r\n    // Logging\r\n\r\n    function executeLogInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x0bb66f032ad5d12a4a2719478ed07ca29b4ddb841e8df8a7bf380a1d471a744a); /* function */ \n\r\ncoverage_0x0dbb89fa(0x0de78957cfae50b8bdbe5c466e8c45a1ed452acbe3c227a79f357d3b63002561); /* line */ \n        coverage_0x0dbb89fa(0x31be1200347b11f5fe0117624a778e2c42f79acaf8b53c398b1ba9662f36b5f7); /* statement */ \ncontext.logAcc = keccak256(abi.encodePacked(context.logAcc, popVal(context.stack).hash()));\r\n    }\r\n\r\n    // System operations\r\n\r\n    function executeSendInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x44f45793d5a15be48cbb73cb4373aa661b210fc93ac0c856f3f3c03ab86ba6a1); /* function */ \n\r\ncoverage_0x0dbb89fa(0x5867bcca5cda79767c5721c7545f2e23be050db05a222761fb1d2a1b374ecd25); /* line */ \n        coverage_0x0dbb89fa(0x1178b446d2d31e8097cf6e3f16b9fa4a6a3eb1a9ac9831bc5144061a5bb3eeee); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x60035d9a05548357bbda843f461165e24dffb51c4045e6f602fa2970e197eead); /* line */ \n        coverage_0x0dbb89fa(0x0fb8dc6b04ef11ba05acd6633676ce455656d35b8c72fefe2259329346e20557); /* statement */ \nif (val1.size > SEND_SIZE_LIMIT || !val1.isValidTypeForSend()) {coverage_0x0dbb89fa(0xdda162a2fec2a0b8add1694ddc685eb303d82a3c6b0ee5c66a09e65e2e952155); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x71657d6cdc2bf077bef0c60f720acde251dff504131958495906d189c1a64239); /* line */ \n            coverage_0x0dbb89fa(0xc6a993a9b23d306f650931291a31ffce45ba46ac0f27daa85500931d8c8a9fae); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x1ed21b0dd839cce68dd9f80cb0dca8b54b86dfe8a7d108f48150776ad3abacfe); /* line */ \n            coverage_0x0dbb89fa(0x58922a7ef8c46ca8967fbe12903a233f79072b4ebe81b4ceac4703c4c06c7543); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0xd08bfe37e6c78c47950dae7db385c0b07cbc4ef5b77d6c0a1ecf0742853e7079); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x57fb17b69339635ff6373210c3163909642e063ee083375668b7461cb573a0fc); /* line */ \n        coverage_0x0dbb89fa(0xe373ca054b28634a19f3aa8313398e52b7d8dc171e2a874fa81c1d2d84ce5b05); /* statement */ \ncontext.messageAcc = keccak256(abi.encodePacked(context.messageAcc, val1.hash()));\r\n    }\r\n\r\n    function incrementInbox(AssertionContext memory context)\r\n        private\r\n        pure\r\n        returns (Value.Data memory)\r\n    {coverage_0x0dbb89fa(0xce0aa790424082c24b1b081b7b939c917a51ac45420338733d5644f31bb9ff97); /* function */ \n\r\ncoverage_0x0dbb89fa(0xd65c624ff6af461ed02af33d14470b36bfa753cc30f027603da91487a6a6ac6f); /* line */ \n        coverage_0x0dbb89fa(0x06c5016b66e8ed61e2b81dc50688fb0dd991d927af3c19e952077a82bc99dd33); /* assertPre */ \ncoverage_0x0dbb89fa(0xfc0bd766da8dc2244f8e9157844ad7b150ef5008d809fe665b5f8e4ee0863ae9); /* statement */ \nrequire(context.inboxMessageHash != 0, INBOX_VAL);coverage_0x0dbb89fa(0x8bd0c90a830bb6bb4c405fa5bb4d96b8eaef4228b865225e779ba46fa23bb420); /* assertPost */ \n\r\ncoverage_0x0dbb89fa(0x1f57f519c250938c3a8524bf93d3d790098e5db1365cb5712ac3c078ee0b57bb); /* line */ \n        coverage_0x0dbb89fa(0x2f63a963ff8ef6909a785f9cb92c2575f5b2f59652ebfcb515a58304c7465a54); /* statement */ \ncontext.inboxAcc = Messages.addMessageToInbox(context.inboxAcc, context.inboxMessageHash);\r\ncoverage_0x0dbb89fa(0x4189eda1ea390e2b749fd5d763f70445425bd92da751b69aca355530640ba5fc); /* line */ \n        coverage_0x0dbb89fa(0xb080dd252bd39bf52665ded6e48f051d66578411a8fd89ab965647f9f13b394c); /* statement */ \nreturn context.inboxMessage;\r\n    }\r\n\r\n    function executeInboxPeekInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x5e8555d256015a34b7d603724f846ecd4959557a9a92838c9880290ef8bbc461); /* function */ \n\r\ncoverage_0x0dbb89fa(0x4b9ebb28ce81b16dfbc9e6fc0ba74d94324e1a247bd916e24fe9d4d26a6e0d08); /* line */ \n        coverage_0x0dbb89fa(0x287a51b330cf57e30d44e4544ec4c5962165d4384f9f71d60a4165ea0596cb50); /* statement */ \nValue.Data memory val = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xb34ccb421736b9b8da31e9ebc33d639bfbe76f7bbd40ef5e8a4e95a74abc0f7d); /* line */ \n        coverage_0x0dbb89fa(0xc4894013192f20541e82aca6ca1e60b8431d6ede9ad4859501461ae44bb47617); /* statement */ \nif (context.afterMachine.pendingMessage.hash() != Value.newEmptyTuple().hash()) {coverage_0x0dbb89fa(0x347d6b6097013a845e432b2eb8cf90fefeb7ea084cbdcdd72a23104be97710db); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x6d9ecd2e318629044b909c08392666fd6cc5e7781eb16221debf622878c58758); /* line */ \n            coverage_0x0dbb89fa(0x61a02e47bbd0691f3e6b544bc6d8dd70b7942e94b49b975d60501ada623e0b9e); /* statement */ \ncontext.afterMachine.pendingMessage = incrementInbox(context);\r\n        }else { coverage_0x0dbb89fa(0x3b4c35c79ae3f28ebe5cba9299819e50bade81114ea27b780b8bd21353b73446); /* branch */ \n}\r\n        // The pending message must be a tuple of size at least 2\r\ncoverage_0x0dbb89fa(0x0ce768127420bbc9309b03a0c47ea626f618aa50c40527c51e647903d2ca6639); /* line */ \n        coverage_0x0dbb89fa(0xe09c8cdd1caec4207234b3066a6ddbe809cd411fe8bdf2e896222e6497e10053); /* statement */ \npushVal(\r\n            context.stack,\r\n            Value.newBoolean(context.afterMachine.pendingMessage.tupleVal[1].hash() == val.hash())\r\n        );\r\n    }\r\n\r\n    function executeInboxInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x9165788ccc86f07ad0770b5e524bc27ae65407606410de71f8eedcbc0f7787d2); /* function */ \n\r\ncoverage_0x0dbb89fa(0x4bf149d65f35258970294f0196708730256c3195061a9003e46af77ef41fbdad); /* line */ \n        coverage_0x0dbb89fa(0x623f032f19e30bb670f4dfcea9395d049b90215ddf006affd94b4ab96d936d3d); /* statement */ \nif (context.afterMachine.pendingMessage.hash() != Value.newEmptyTuple().hash()) {coverage_0x0dbb89fa(0x4cdcf826bb28dad2f2c8d504ad4b0acfb574fa6afcfef9a53eea5772faa35a38); /* branch */ \n\r\n            // The pending message field is already full\r\ncoverage_0x0dbb89fa(0xcd57940ac0189e932c4b7a02a2e2aea35181267a509befa8dedbe92d7eda811f); /* line */ \n            coverage_0x0dbb89fa(0xb0c6f13f80ef18bb9d8dfe4129774daed7abf2c0d3b128ccd507bed3d1b3c246); /* statement */ \npushVal(context.stack, context.afterMachine.pendingMessage);\r\ncoverage_0x0dbb89fa(0x63b37b3a5ccbf0598264bd7cf3fc5e62c83f2f6d57c57b28f77466c4b83ea32e); /* line */ \n            coverage_0x0dbb89fa(0xca703b98a5be71f65f020cbe9846aed0faf7f8a0c93a434c443a0c525e49861c); /* statement */ \ncontext.afterMachine.pendingMessage = Value.newEmptyTuple();\r\n        } else {coverage_0x0dbb89fa(0x25bbe2486296d937025e83c586df6ae0c0a0237fdb16b0424c25aaf38b0b2986); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xe5293d961acf364459d14c1af48a0e56ab78a493475f57fac2edd8f28a41f257); /* line */ \n            coverage_0x0dbb89fa(0x86b511cf49836f41fac0379ecbed70b26c9ef4409054b87d9bda7dcbcbd7b317); /* statement */ \npushVal(context.stack, incrementInbox(context));\r\n        }\r\n    }\r\n\r\n    function executeSetGasInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xbb1f3ec131ff2aa33a78f70e1da17780eb3bbbd399768a28237db6b7cebfc939); /* function */ \n\r\ncoverage_0x0dbb89fa(0x56c1d86de883f8f8794378fbbd7f58589aaa211575d05f31aeb3acba8f27273a); /* line */ \n        coverage_0x0dbb89fa(0x185238e5424c2a99e2798111b4ba584944b290a7d3f82d7b030577dcf54d8f20); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x7640a6118ef8a94bcf9f04333b9c80b7e4dad9d31be4110c6df2899338db0073); /* line */ \n        coverage_0x0dbb89fa(0x44cd61725b7ca19ed37eaae9594f838046448a760331cd712101f8140b6323b8); /* statement */ \nif (!val1.isInt()) {coverage_0x0dbb89fa(0x7ff82c3574890c05f73e199962d9fb18ef2c23771928d02e77cfbd753cf7d447); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x6177e1504e1f185d30e7ff238b50d0e01b4e9c86b53016846b0ede45d52b60ac); /* line */ \n            coverage_0x0dbb89fa(0x96cc45501256adefff50d02d1ca5efe5409718b451bfa1620680b1ba4dc92bef); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x3a002bcb9e7a1c8d5e69a161299de9e915b9c633b77fe7c8d66fa846a658d1b1); /* line */ \n            coverage_0x0dbb89fa(0x76f7a55f0552d5694458d51980651308645a3dd4b1814f685eaa589469f6aa37); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x76946a77d73e7e14239ec25638783d0e47baa5e0ed56cc0680a06f040fac5607); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x4381e3122c8e9e0649e958453b3639a8fa400840f0b6b9b7600c4e56bb6928be); /* line */ \n        coverage_0x0dbb89fa(0xca9f9cb0eb4078d8cd6d835beb1a07e58e1aebf7dd00488c4ced4ee76816715e); /* statement */ \ncontext.afterMachine.arbGasRemaining = val1.intVal;\r\n    }\r\n\r\n    function executePushGasInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x83c754ed97e3f3ce01d09c972a66e327ed71edc6265011fff71e6809687c4221); /* function */ \n\r\ncoverage_0x0dbb89fa(0x376a05cf5a0009ce0254b5a30e31182e66de622e181b12f9a33b5162351885c2); /* line */ \n        coverage_0x0dbb89fa(0xd3716c4416ad218bde671c87ff2949581aa455131d3925858a5649a4e0e492e0); /* statement */ \npushVal(context.stack, Value.newInt(context.afterMachine.arbGasRemaining));\r\n    }\r\n\r\n    function executeErrCodePointInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x313ca40cc6c6407ca4ef62401f378c3f219e99c02a31f91bd170c23c67c631c5); /* function */ \n\r\ncoverage_0x0dbb89fa(0xa621c7b6f0e5b379058e173e3eb7f57c21d65db50f877edd1424a448e7425e5c); /* line */ \n        coverage_0x0dbb89fa(0x38673488d16e1c7380dd73aff7333dcc74c26f1188148d4853d1e1791825e0aa); /* statement */ \npushVal(context.stack, Value.newHashedValue(CODE_POINT_ERROR, 1));\r\n    }\r\n\r\n    function executePushInsnInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x9694802004e63dba15d65dc71d66c06f66aecc1142be8b91ff1a07235f1e8860); /* function */ \n\r\ncoverage_0x0dbb89fa(0x6a6b4092a168003cf8540622f28120c45d1cfbce39a01e79a09450897d40922a); /* line */ \n        coverage_0x0dbb89fa(0x4a41c6142459575c7ada61b00dc12359dbe7275dc9f5329949b0430cb5e63a9b); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x6150b1a4ca808936e729d63a5aba79dbdb16ace34e51ea0a43fa93e4b88c0a54); /* line */ \n        coverage_0x0dbb89fa(0xfaa4acc01017e771c30971a100c66f4628b0e01ccbdbc4d2ac043540bfa3ea3e); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xa8e7f8ebf7400082ad309357248d6835cedaa7bc89893e681be0c798817f9e77); /* line */ \n        coverage_0x0dbb89fa(0x49bc6913eb34e453acc4dd0720b5dd1c19fabfd1e4f65417a2c9840a0b29dafb); /* statement */ \nif (!val1.isInt() || !val2.isCodePoint()) {coverage_0x0dbb89fa(0x06559a4967252b520926635a0fbd9a1ca27bd21786775a6da5414b1b11adc4e9); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x908e7911c43c44478d078284ff4d44e26af87705c5649f85f3b4aa1db71fef23); /* line */ \n            coverage_0x0dbb89fa(0x2b3599f997bffdc0a3148b9ae1b6071c2e34506d54d97c48400dd7b476ca338d); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x43a5528678ed9f1c77fd44b0af32fab9ff79d4a314507eb76b0f8f00c293883c); /* line */ \n            coverage_0x0dbb89fa(0xd411b93f277d5ba2bbc29c28bfe9e35896b8e1c5c6134e66811437e255c50971); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0xf7f13dc91826eecb68f5a263e0216d666a6e8cda3dd1d61d5b9f8787ecec0417); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x371bf3a87de02ef49883d871ea78fa557edae9aeb510f3dc6ef9286ebee17c65); /* line */ \n        coverage_0x0dbb89fa(0x2a6d1eda907e3f6dbc67410d1884b85be36ba96b2424238be9be3c7ff0ba592b); /* statement */ \npushVal(context.stack, Value.newCodePoint(uint8(val1.intVal), val2.hash()));\r\n    }\r\n\r\n    function executePushInsnImmInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xefaa555a1a0b316e8320d26d1b22666c0c18dcfb8a5bea3c109510d3095bfd5b); /* function */ \n\r\ncoverage_0x0dbb89fa(0x0999a7996af605e938ed3aef977939fb163fc6f29431f5bd0f5c9726f09b83fc); /* line */ \n        coverage_0x0dbb89fa(0x02e590e16dec1d00c505657703c1fb9ac5ab13e03fc9e6ff4a5eddb77a12a926); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xd7c600bdf42a45a43ff4f77975ff933a522747f069f3286c4136448847565d9e); /* line */ \n        coverage_0x0dbb89fa(0x811bec633dff96bda07160d80946be71f6eac6732190ab681c00f2e9dacd09e1); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xc3c2475ef4ebc1d46caa386ecf82881d41a807ef897193c33a7c484f3ba5e6d0); /* line */ \n        coverage_0x0dbb89fa(0xfda08289741be785429a2ecf524b58eea981684b4e71152bc3ff3e8c61bc003a); /* statement */ \nValue.Data memory val3 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x1800ee4e7d01f795c9e4e094c37c6343df3379fbe209d3d68cf0e10fffb97a61); /* line */ \n        coverage_0x0dbb89fa(0xf9ba50ccb76e0c8f2d89c1d17ebd30f42c5178b64628d08b7a6dfe1794d99bb6); /* statement */ \nif (!val1.isInt() || !val3.isCodePoint()) {coverage_0x0dbb89fa(0x35238123c8795d11a135c563997e072b65cec1e3c00955d1d9bddbb5705fb0fc); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x698de4804706c7f59ec3254d4c6de13eb474820258cc4592031d48e29e769d07); /* line */ \n            coverage_0x0dbb89fa(0x6124378e18f687b230752676430e816351144859aecb83ecec6e2535cda18660); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x411b2f63c42794759f3256d22f7295f1ad229a571075483a4b4b0664711d8023); /* line */ \n            coverage_0x0dbb89fa(0xb60d2179226c283dfa63c62d6a79ebe0f5ea92fc40aedf51965cf447f7e4eb83); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0xf1100f0a3af1202a05cc7e4e7a17522e670d86b9f01daf93d876149bb7f61aec); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x2e5bb4c0199e2ea6b21aedc5102f4f6d19713d2052c7144a6f745232829afc29); /* line */ \n        coverage_0x0dbb89fa(0x75152432f232dfb3df41dd8ee22711ff7abf64c6655a7739577881272c42f770); /* statement */ \npushVal(context.stack, Value.newCodePoint(uint8(val1.intVal), val3.hash(), val2));\r\n    }\r\n\r\n    function executeSideloadInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xa2cf4b598879b33fd324a6f20e861c005cca077b1185139aecf379f21397b30f); /* function */ \n\r\ncoverage_0x0dbb89fa(0xa0a1082d117015169914eb18f0ec830cdd13e33541c1b319a19e5377d00fe508); /* line */ \n        coverage_0x0dbb89fa(0x5e5887d8d71b4246d13ae2e7214ea71470548d8d12b84777df47c09abfd570bc); /* statement */ \nValue.Data[] memory values = new Value.Data[](0);\r\ncoverage_0x0dbb89fa(0x66a62adc16c3ac99a2f00ca34174407e05b2b38dacec220b1807ba0eec951bfb); /* line */ \n        coverage_0x0dbb89fa(0x5ed2f2215df9b3de7c23a5631ce04bc5f8d1994825bae482d313c5c103fa3cb2); /* statement */ \npushVal(context.stack, Value.newTuple(values));\r\n    }\r\n\r\n    function executeECRecoverInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0xdb7dec049b91ecc44c796af04249b7c4023c22a883fe2233128c517644ecefef); /* function */ \n\r\ncoverage_0x0dbb89fa(0x2ee37828f782ee2c3ad637b34561f07cedc52b99ffc978a9b3d9190e78831124); /* line */ \n        coverage_0x0dbb89fa(0x68fcdf024f18fba6ff57db66d1013d7b7af0201ebf03fed47e71ce08c2d09868); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xb7a39feb97d3f1c99088b8bf42ae8e43da1ad7d7a945334b9cafd4b12048699c); /* line */ \n        coverage_0x0dbb89fa(0xca25a2d912fef6f67efcf9ba675360e1596a1a0d954f93805f4bafb5e0680103); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x4a29853f386d134be0f1a0d1aa53e4d51e0ccf9a387cec6439bcff48c288bc20); /* line */ \n        coverage_0x0dbb89fa(0xba8cbe75969c06695e3bc681afaa2189905acbee30723cbb60a85b07ad7011eb); /* statement */ \nValue.Data memory val3 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x672d5c5523e9e9f3ea74be25a782ddf7883ca9760be49043e4eed65144625224); /* line */ \n        coverage_0x0dbb89fa(0xf25b274a92976bd760f694e5067224523e5a653d3f23718d239f8aef2a9980de); /* statement */ \nValue.Data memory val4 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x6f3669814b08e0eb8fc9e9b63c491982d5cf041bc456131f883b1b9b7470d1b1); /* line */ \n        coverage_0x0dbb89fa(0x396bba3d83ceaacb8acb0c98c949fb2478e44b99a29199120eaeecff81fc7d23); /* statement */ \nif (!val1.isInt() || !val2.isInt() || !val3.isInt() || !val4.isInt()) {coverage_0x0dbb89fa(0x239abdb9958de30c8c15850570611b15def4b1e4c8879426c9fadbb56d6411b9); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x9c15177da518c12dea6f7838de8ac3be7c42d6baf5062575b5d11154c9cff8cd); /* line */ \n            coverage_0x0dbb89fa(0x705cfa95242d43c78cfccfb5dc4eb560cecd9132b4a43b69678db484d4c6f721); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x4a5830a7ae33c031f334a1187d806c23dd10cf97ce3f2b93734c2f65e683ef5f); /* line */ \n            coverage_0x0dbb89fa(0xdf692da43ccc634271ce8f3ca304192ea51df351a34e3cca4f43132813976fa9); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x1a483ae5e3487cde535e9e26ad8c13089c627c72bce70f30d9696a06150017eb); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x0f32bd20ae93ebbf732611a57ff3175fd7201677bb5cbf16f1580cd60721a63e); /* line */ \n        coverage_0x0dbb89fa(0x9f741d71c1d9aff08920a9b8986c874839642e2277fcdb1cb4e0774f6fecb07a); /* statement */ \nbytes32 r = bytes32(val1.intVal);\r\ncoverage_0x0dbb89fa(0xe841d082a7e60ace7afb9f4e17efcefc35ce41ae17ae41a0bda0932fe951a7bd); /* line */ \n        coverage_0x0dbb89fa(0x7353c397e5ddad1cade292fd6fc5d5c0a3ceb6084b145189e48b98eeede7490b); /* statement */ \nbytes32 s = bytes32(val2.intVal);\r\ncoverage_0x0dbb89fa(0xa63f640c7b5a4bf22e4a8e3866f5212a85d0c9bf942cb00533aca92b02041b94); /* line */ \n        coverage_0x0dbb89fa(0xadd9c328a7a008a084dbd005ec6db24b2dea29187fd8809fd0a3259b1b3a7a1f); /* statement */ \nif (val3.intVal != 0 && val3.intVal != 1) {coverage_0x0dbb89fa(0x0399782d4b54f083914ae18266c3791b86cc798da81496578c3ec33721b56eb9); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xdc19227b839eac9b8e89eda3735162846d750775dfb20e04755199dbc878e596); /* line */ \n            coverage_0x0dbb89fa(0x074c35a866d8fad7fa3cb3317420c63a32816a87f0eaeddbee1f11ea6a4133c5); /* statement */ \npushVal(context.stack, Value.newInt(0));\r\ncoverage_0x0dbb89fa(0xa63294e17930747ffb342bd3b5d23ec94eea8e5bceecb2671bb8c4a9b0ade2c6); /* line */ \n            coverage_0x0dbb89fa(0xed6c680e5f5cb4221cf1a18be87142c87ef04f561fd90b38b6a3df95dd718270); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x578e595325789ea112b6c3910cada817a14777a7e2838365cedcc3d84f6e4fb1); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x7f8845cb7a417322c5e1960c9d1bda82f389d0fa0a04abe9058e374a956aaaec); /* line */ \n        coverage_0x0dbb89fa(0x2445fe1a0a49a3ade66c3c2ff8ffd1070d85f39da87c482eea39e0e94d70ff0b); /* statement */ \nuint8 v = uint8(val3.intVal) + 27;\r\ncoverage_0x0dbb89fa(0x39ae4a1a028d4e784649525b4319ba7a3a795b839acf6daf0c3ce9b0c9df51d7); /* line */ \n        coverage_0x0dbb89fa(0xa38cec3319a6cfc798206701c0aee1cf9de3f34fb970c63c21650d5f173a3035); /* statement */ \nbytes32 message = bytes32(val4.intVal);\r\ncoverage_0x0dbb89fa(0x8ed36137ddbcd77acd7b4a4783fa3a6410c69d812a495348c9684a1fe157944d); /* line */ \n        coverage_0x0dbb89fa(0xb7ac1f726676d391b3aa83a31f56f4c03c504d88a6126c033cc1fd6b6f931db0); /* statement */ \naddress ret = ecrecover(message, v, r, s);\r\ncoverage_0x0dbb89fa(0x4083fa9a96d7fea960b4e0c1dc81c6a06280f9e45da362a18300751e996f245c); /* line */ \n        coverage_0x0dbb89fa(0x5722b13db371dff6d8b0084d9bc96e7ad63b5858385a2994cc241594e7228d05); /* statement */ \npushVal(context.stack, Value.newInt(uint256(ret)));\r\n    }\r\n\r\n    function executeECAddInsn(AssertionContext memory context) internal view {coverage_0x0dbb89fa(0x834f01b22e35b86fd19865934414c3f13f1c44a712884467ad58ab28ba43a1cb); /* function */ \n\r\ncoverage_0x0dbb89fa(0xaf63677325ccbe8b1a72ccbdcad0107ca7d74127d438c03024f3dac7d10275d8); /* line */ \n        coverage_0x0dbb89fa(0x9e22eb4aeaecee66adb93e208d2b931d0e91d3b7af1bf6844172a5c56ad696d9); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x0cba7c95abd911cbceb8cea6a3c918116235b732b4bdf09a664deb70f685a070); /* line */ \n        coverage_0x0dbb89fa(0xb36b943e4562b182339647e1d4d4df1879fcab3105439ed860357d65a99817f1); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xb8dd78db144d0dfff802e9bea5790e081a6ba48df05e5ef176969da07cbe6ded); /* line */ \n        coverage_0x0dbb89fa(0xb836bf7ac171a7a4183f63705084ce58b29ae3ffb93f204c154d6e77294b71ec); /* statement */ \nValue.Data memory val3 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x6f1d56212b72fa857c55284e363b07256fda4190e584bf0dfddf885b2c13c4a6); /* line */ \n        coverage_0x0dbb89fa(0x969fa67e93e8d1d3eaf2f5e2869c2f80777aaf4c3e3d93ea4e39c3be26f69e64); /* statement */ \nValue.Data memory val4 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x72cb2b26d486843d33be95a380b5b516960142597d9fa4b794412e1527f5f16c); /* line */ \n        coverage_0x0dbb89fa(0xf331b88bf0140144cf3241b3a6b7c6b48fda65ee46eaf802b2a9adbef6c8fd50); /* statement */ \nif (!val1.isInt() || !val2.isInt() || !val3.isInt() || !val4.isInt()) {coverage_0x0dbb89fa(0xd491ff819a276e3167d6903bd381f11e39a10ed0c6b3a5b15451eafce6fe7e36); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x927cc671993553c84be8f6c96868867384b075d6e26eb1bba6d906530ab7cfae); /* line */ \n            coverage_0x0dbb89fa(0x6b6a6f974c1f3775b753df3278e67d9ddddaa1531d35dea7550b5b785d4061b1); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0xef4a909c6924d1db336dc50e0789399d864f4df020eac3af6d4f8848cd246bd4); /* line */ \n            coverage_0x0dbb89fa(0x381ec53015b7a1fd47f2eec848003bcc64f140af77d66911f988d2f802a0b0ac); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x1987df8ec437515fd01475b71fc5a8d42e375a06fedaf863aa7c3251b2893989); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x018152b296e3657912060706030c9860f5e3aa21253b258536ce451e01b2e082); /* line */ \n        coverage_0x0dbb89fa(0x665862451a20b3f2c58106a0dc1aa951bb0bc30b73a0185d0a63ee79acb3a88f); /* statement */ \nuint256[4] memory bnAddInput = [val1.intVal, val2.intVal, val3.intVal, val4.intVal];\r\ncoverage_0x0dbb89fa(0x65273ffcceb3e9ddf94a3591874b3f6d687cb3311735a49749d6234237ef64aa); /* line */ \n        coverage_0x0dbb89fa(0xfb9d7cc4e137a658a736ec2088d6dce8790af075fdbbbc1c026c3090453fac64); /* statement */ \nuint256[2] memory ret;\r\ncoverage_0x0dbb89fa(0x9b4d0752fa57de6f528daec24ce43aca5475a227f46c9e56b48e10901fd3d972); /* line */ \n        coverage_0x0dbb89fa(0x901afc34f3b1e1557e32344f480bcc3999ddf63a7fba0058fbfd644cd58a3026); /* statement */ \nbool success;\r\n        // solium-disable-next-line security/no-inline-assembly\r\ncoverage_0x0dbb89fa(0x9a9c863abf2960fcf46e3779994216c468d74c598ca5e4bcd132b0ec24363d92); /* line */ \n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 6, bnAddInput, 0x80, ret, 0x40)\r\n        }\r\ncoverage_0x0dbb89fa(0x6c71b7fb052c68d4132d4d25b7f620935bd03e52212010d305366c81ce63043d); /* line */ \n        coverage_0x0dbb89fa(0xd206fa7295732e0fe11eb73b8a21e1c5272397fa577008ac2f301f9ebd5c1d63); /* statement */ \nif (!success) {coverage_0x0dbb89fa(0xdfdb401022174c323ddbf89af8c014b559f3858c08410adc4c730e1c36bb15ba); /* branch */ \n\r\n            // Must end on empty tuple\r\ncoverage_0x0dbb89fa(0x87e7c3c5029384b909af4fd6848cd57d41159408ff1cc8e373ae8456159ee63d); /* line */ \n            coverage_0x0dbb89fa(0xb752661d24b72c1eb70c4fde1ef6e7a39b17d457d81ace587b7d7d5179643947); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x81e640099276151acf46009d2e84a9b71e60764be726df350d4c2996424a5b9d); /* line */ \n            coverage_0x0dbb89fa(0x04856b5f8462800b942d6b8ae664a286994dc3d517237054d3fc709f7b8b3bf8); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x96ae49d183c4e557ea232be8e8a7f3336f38b5325f5caf8f6b6f6277dd45e21f); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0xfae6209caeac0f1284b4b7502181cc3a439d8610adcc60146b5656b5e045e768); /* line */ \n        coverage_0x0dbb89fa(0x109af1797615e35b019c2bb543ed838c5796a0dd822c2d9233f11199248e95f4); /* statement */ \npushVal(context.stack, Value.newInt(uint256(ret[1])));\r\ncoverage_0x0dbb89fa(0x46818a5f0a729972b5a5d9b54334f1f87c0b122a6019bd661cf994e44157c10a); /* line */ \n        coverage_0x0dbb89fa(0x9838862cb28c3ddf9918fb741ad019a0567ddde425b97d5abc882603680202ee); /* statement */ \npushVal(context.stack, Value.newInt(uint256(ret[0])));\r\n    }\r\n\r\n    function executeECMulInsn(AssertionContext memory context) internal view {coverage_0x0dbb89fa(0x6fd4e1e078a37223ab702381f66d9fac03c522205093637fd280a877e6b23f55); /* function */ \n\r\ncoverage_0x0dbb89fa(0x00aa7d20d5056e3652b3a57569b700b0196073d8524f3929cc52aa7e2f049848); /* line */ \n        coverage_0x0dbb89fa(0x600c0bc778de59242b822554b21d462250f12e03028d4e3490a5b7c567ce238d); /* statement */ \nValue.Data memory val1 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x861ec4a5a479fe55a3f2363aec0c1d0a0ad408d46b67436b796ce36440a2cd07); /* line */ \n        coverage_0x0dbb89fa(0x1c312d65d8aa7247c0396c18fdca381ce4bb67cd6bf533bf6c3dad6930fb7a8d); /* statement */ \nValue.Data memory val2 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0x4b2c787d6f53ed834517d0de105f37a60c700cbc90d637568cd79e171dc398a1); /* line */ \n        coverage_0x0dbb89fa(0xca51e58d7a2c0d349194cbff8d2e9e7573d7554a23bf5b3d290ebb874bc0ae85); /* statement */ \nValue.Data memory val3 = popVal(context.stack);\r\ncoverage_0x0dbb89fa(0xeb9f47bbb076e97cf6af4765c5f07e5a6326ad369f75064dbc83b7690b98fe6a); /* line */ \n        coverage_0x0dbb89fa(0x61526678183952d792665bc88b1a607ec84eafaaf9f33a9d308926dd312c1938); /* statement */ \nif (!val1.isInt() || !val2.isInt() || !val3.isInt()) {coverage_0x0dbb89fa(0xaf59d7ad299a4d33ee17b29f9a13853ad4ba6e1c127892c3fa37df6a75e20e0e); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x6405b01dca1c4f0f76c3536cb6e9667bb795203c24f0c903349aa09a90e41540); /* line */ \n            coverage_0x0dbb89fa(0x008133d43252f9f90fe7f86530abd6d456497feb55a35fb9ad5f6145d49a127c); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x443c3715c85db40acc5b8c13715ef09ac1f1e0804e155107c771317b9e825996); /* line */ \n            coverage_0x0dbb89fa(0xdccf3baa041d824613ee3fc69f3350f01dc1c49be5fc9b964cedae9d649b3770); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x8833f4f9bdf3badf3ede4a0e4da94768b809dea1671ecdfbc2bce524e307d23f); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0xd5b1b07982a9e8caf2d82e4225e075c342ce63607f27208b4f3d2846b5b24c8b); /* line */ \n        coverage_0x0dbb89fa(0x38ae75131bb0001939e0220412af8648344f608616e44133a1806aeb0345c4f6); /* statement */ \nuint256[3] memory bnAddInput = [val1.intVal, val2.intVal, val3.intVal];\r\ncoverage_0x0dbb89fa(0xa9e488039f2db713bc61c1e55c0a9e304ed6d83915d64cda72b8e56dcdd72e80); /* line */ \n        coverage_0x0dbb89fa(0x8e2ef414ee4a0a31745285ca33a2dd5bbcbc2f35915192c0ca91f5da595afb16); /* statement */ \nuint256[2] memory ret;\r\ncoverage_0x0dbb89fa(0x3941c6a6ed490c83b62d5536872339c3b3f960a82015cd09d51bfa63c53b596e); /* line */ \n        coverage_0x0dbb89fa(0x3b5975e8d832e2f0e85ac8c4cb35249afd0f69856f890f479f745ad7fd9d2ba0); /* statement */ \nbool success;\r\n        // solium-disable-next-line security/no-inline-assembly\r\ncoverage_0x0dbb89fa(0xcc4ff06aa8f88abd01c7b089a09ab5694b6934ce31599fb205492d4813644801); /* line */ \n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 7, bnAddInput, 0x80, ret, 0x40)\r\n        }\r\ncoverage_0x0dbb89fa(0x40fb0bc016d190949a738629ef4c003f1bd4f1b297853ebc0d29fe1160c82fcb); /* line */ \n        coverage_0x0dbb89fa(0x3ae76c811f7079dc5b91ef51dc84d1ea521b31f46a48a8e52069429e078aa79e); /* statement */ \nif (!success) {coverage_0x0dbb89fa(0x24e0af2bebae0375e42dd00d1e5622dc9ad38def2ce46cc97d1db0cf5263df9a); /* branch */ \n\r\n            // Must end on empty tuple\r\ncoverage_0x0dbb89fa(0x8557243cfa9f611c457268ffa4f371e82a8a1d5a2516159a512d02e33e709b68); /* line */ \n            coverage_0x0dbb89fa(0x8a411313d76fd50e9673ea67cd4a2364938176b7080939e0e32a4a4613028844); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x94d020aeb842b58d7bea378ebe3d711a045a60cc9d3e8a356cf1925135f0e00a); /* line */ \n            coverage_0x0dbb89fa(0xd915e2130728d0153b8bf3b5a123131f12d4b326e20619c35e63eb22ea728142); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x1c91c5ed3563e7fd3110f3c24478600d21d8771348f86751e8073af89629e4a3); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x7ac10f271893bb9455a62719e6347dc44b35cef55fdd8a0394e9c27439f437eb); /* line */ \n        coverage_0x0dbb89fa(0x2fa37f4d1f0b9edf3a9c68f245bcaf32ba4ca5e14f0c7d7e9345283151342936); /* statement */ \npushVal(context.stack, Value.newInt(uint256(ret[1])));\r\ncoverage_0x0dbb89fa(0xdd118acc690a098048569ab7bd1166a6e2ca175e6e89c083a86a10acfe4a8261); /* line */ \n        coverage_0x0dbb89fa(0x13e9a3d09f4ced94d205a72cf78bb5ecab48979f9220d3a09da9e99c7021a8cc); /* statement */ \npushVal(context.stack, Value.newInt(uint256(ret[0])));\r\n    }\r\n\r\n    function executeECPairingInsn(AssertionContext memory context) internal view {coverage_0x0dbb89fa(0x72c45cb2a137df863b9dfef53c40bff6f1fbb80bbfdeefe049bd0cd2b12a0c3a); /* function */ \n\r\ncoverage_0x0dbb89fa(0x57408d134633f39914abd9ac77c734ef7c0975c8d8af5f17272b64a5aabd63ba); /* line */ \n        coverage_0x0dbb89fa(0x03bd4a62f422cc4de6a5b56e7d8b26d4cec0db2dee56f6982a9d3b06f9bc1868); /* statement */ \nValue.Data memory val = popVal(context.stack);\r\n\r\ncoverage_0x0dbb89fa(0x05c0e5a591a6d991260b66f68231d0a9e7a7072de882c9563bf5e1645fe41740); /* line */ \n        coverage_0x0dbb89fa(0x64f15cf5bc4fdec3ba5832b7e2920a4bc8f182f2f875a6b675fe89bfa1c53cbf); /* statement */ \nValue.Data[MAX_PAIRING_COUNT] memory items;\r\ncoverage_0x0dbb89fa(0xb29bf8bcea3fd492b6101340ed63004164fb414427d75bf630d1b02017eae3a9); /* line */ \n        coverage_0x0dbb89fa(0xbc721439d8e1721b3211b53c0bd186b620dd0bd3ecce27fa4a6fdacc0346c010); /* statement */ \nuint256 count;\r\ncoverage_0x0dbb89fa(0x2a37089cdc71edce1faee8e00a7d09da5ef7f8db3852541cb01f5f71404aeb19); /* line */ \n        coverage_0x0dbb89fa(0x805e9919a31e27a0ef6d78600fa9ca4beec4e30245a5d69e4244cd43e319b8d7); /* statement */ \nfor (count = 0; count < MAX_PAIRING_COUNT; count++) {\r\ncoverage_0x0dbb89fa(0xb162b6b114f110f7247c2394fc9531018dbd043237a69dcd1e090001c6a91eba); /* line */ \n            coverage_0x0dbb89fa(0x93aedf032245c391b017bc7899a07c26dcfd05ef3f7f4777176b9d7cc6542d0e); /* statement */ \nif (!val.isTuple()) {coverage_0x0dbb89fa(0x63cca5e67328df32fe472d210682bfc9611c47c47b1590bc47f99ae3aa564398); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xf00c3539b24f62fb526ee0ebb72bf87d3b95de00711f822e1ee5c58a8e2183c0); /* line */ \n                coverage_0x0dbb89fa(0xd91fe4ce8c995c8c0bfc2f9167b2b8cc39ec747027c2c1f04977284d84056f1c); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x494332908fbc6a8c6b52aefa7fb70668b8ae6cafae9f2f9d92ed0b99f7ed6ecc); /* line */ \n                coverage_0x0dbb89fa(0xce10e16a3a3685e79ecd2704e9584c99fa9b7923cd945c9f8dee09006d5f0b77); /* statement */ \nreturn;\r\n            }else { coverage_0x0dbb89fa(0x3b784756134c9b40cc714dd07813b12f45afa322fcbb6cf1139555e4281647a5); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x797bf75245f72a4179ff6502f4d697f9d2d8d4178a60aebd23e08e1cf34a85f7); /* line */ \n            coverage_0x0dbb89fa(0xd7f57e76a0a559d6c716c35721523f55f16483642de3d1603f35a4db7b710461); /* statement */ \nValue.Data[] memory stackTupleVals = val.tupleVal;\r\ncoverage_0x0dbb89fa(0xe5f34befeec7f6c1fe2afa3362bc2652dc1f749b0e47bd67bfd1147e021ec6b1); /* line */ \n            coverage_0x0dbb89fa(0x371dfd8d84df2d1385b86580879fa079c697668a33f58cc537b06c66f7378941); /* statement */ \nif (stackTupleVals.length == 0) {coverage_0x0dbb89fa(0xeaa943b31616481fb8c84a5cfc612abb3b6133267977168dc41da9ef86fef1ea); /* branch */ \n\r\n                // We reached the bottom of the stack\r\ncoverage_0x0dbb89fa(0xd10839518c7136a713b4ca134af75fb6b393592b71a472c2bc18c7e5ae957537); /* line */ \n                break;\r\n            }else { coverage_0x0dbb89fa(0x92345936598ef8d654fb15b3552012641f6050cf7e1d0217f75a2bf6b7e4e151); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x6d8f27ece4bd9dea83f36d66ff81bd44c716d5c29e42b02eb466bfa49cf04b00); /* line */ \n            coverage_0x0dbb89fa(0xfb82197043b448e9ff99109310cfdb07662bd6c858417a2c61903870610c1dea); /* statement */ \nif (stackTupleVals.length != 2) {coverage_0x0dbb89fa(0x4712898bcda3b514a86f8c02c7255dde91019cfc355c8f4cb928c23b68cbd09b); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x3df3873ba7f34d599164dba2790fe0c4efd8a3488a9e44a869708b4cf6d04dfc); /* line */ \n                coverage_0x0dbb89fa(0x834e21b4e36305ea2eca8e5568989968c50469f4b7fb73cd3a077e1c79a3a391); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x874bf479871b9cc699e958a9383e49d2c1c1dd6ce3ecf2ed1c55097ac6fbf6ab); /* line */ \n                coverage_0x0dbb89fa(0x9dbc258697698fc19a260da1f6c6938b06b1af632be916f0d869f438a4418fbe); /* statement */ \nreturn;\r\n            }else { coverage_0x0dbb89fa(0xa8603024641604155251c33c9fd354d0ca8e29aeceed88d022beec72930fa451); /* branch */ \n}\r\ncoverage_0x0dbb89fa(0x6ec91950213d8c4411dc4bf0655b9e344dd097ffce8a6f42d84771f85c156156); /* line */ \n            coverage_0x0dbb89fa(0x3ccbb4e22dd8ea1f2ab37793965ffa9cd79fdc6db119e1458a2d36b0a77b6d9e); /* statement */ \nitems[count] = stackTupleVals[0];\r\ncoverage_0x0dbb89fa(0x2c687adae2beb31ae88d89b05573ae045eb97d5c5d82cc1a7b3cb43afc63eb90); /* line */ \n            coverage_0x0dbb89fa(0x7a040da37cd4ae6eb2e096bc023326abbda4716e9d07d0d76566c2c8a06e8ac8); /* statement */ \nval = stackTupleVals[1];\r\n        }\r\n\r\ncoverage_0x0dbb89fa(0x25a800b7cd0a423015b172e6f156513bd46bab5f1d07667e7cac841fd5bd3c63); /* line */ \n        coverage_0x0dbb89fa(0x1a0e6fb8762f50281da117e75cbfe426c08860d2bea57456b279b2e04c96785e); /* statement */ \nif (deductGas(context, uint64(EC_PAIRING_POINT_GAS_COST * count))) {coverage_0x0dbb89fa(0xb2f3edd9ced7836f31314e748bc24cac6a59510bad149aeef9042238a45dd7d0); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x5e10701b17e352bd6346b29d6a3ea2fcb3d529bcd84ec4c70f814740be80f930); /* line */ \n            coverage_0x0dbb89fa(0x0ed8851088dec9ebdf27bc8402ce56b000b463ca9b9bae78f2152ea589aaa2c2); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0xdd507f2c1525a6ebb5e3ce0f2efe9a73094a7fb71be7a37830981a2813cffbc5); /* branch */ \n}\r\n\r\ncoverage_0x0dbb89fa(0x43d6878faf336409e475396033503bc8f927abd69ddd7366d0b175b7a6e6ffec); /* line */ \n        coverage_0x0dbb89fa(0xa525ae055fedfa813ce69c487f71d0f2189a2a5e3dd04e1f76973961b0623316); /* statement */ \nif (!val.isTuple() || val.tupleVal.length != 0) {coverage_0x0dbb89fa(0x224a2e5ab0bf1780848b033f151d0684a131071fc2280f6a9e6e5349cf223873); /* branch */ \n\r\n            // Must end on empty tuple\r\ncoverage_0x0dbb89fa(0xfae737c0d9e7367a1cd0bdc5f493c44665bdc1c246cada0fe1ae0a06b153fc33); /* line */ \n            coverage_0x0dbb89fa(0x6a9866b4ea06692295aafa8f2713d03fb757a3cfa543fa8b7c70584c7bf145ab); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0xaeea21d25489fabc593fd139cd9e9f8d42e2e25aded056a8dc1a0c8cf5eb7ce9); /* line */ \n            coverage_0x0dbb89fa(0xd24011e4a1eb7f38e86666b789987f4f77ca07d55684aecf188a3efb7a69f0f1); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x2dd0e5a4f81ff46e376ccea370b1e928afefcf63a7bdf433f6b9571fd8f86c95); /* branch */ \n}\r\n\r\n        // Allocate the maximum amount of space we might need\r\ncoverage_0x0dbb89fa(0xf64e1a7f1f6eb31309b30742cee2465d66c513b817aa7eb3de08946227228c3c); /* line */ \n        coverage_0x0dbb89fa(0xf9e5ee58b90d8defc4a0be93ba606afafc3f13961d33f8785bf3a7326f32cbaf); /* statement */ \nuint256[MAX_PAIRING_COUNT * 6] memory input;\r\ncoverage_0x0dbb89fa(0xeb13dd812f1c897240f86078e3e516f40a86eaacc9444671bf0bf591c68f6b32); /* line */ \n        coverage_0x0dbb89fa(0xd49ed7f7290355f809940575e37aa758f0a325fd441910e918469f5fb9144e1b); /* statement */ \nfor (uint256 i = 0; i < count; i++) {\r\ncoverage_0x0dbb89fa(0x87c1b0eb2ec91f4527f667f20a4e88414c083baa9a2e0ba1bbf1bac89b84487c); /* line */ \n            coverage_0x0dbb89fa(0x62f9c03f4a5685e8b5e69c71615d08130d60ee7121374b4815dac95c31567960); /* statement */ \nValue.Data memory pointVal = items[i];\r\ncoverage_0x0dbb89fa(0xdbaddb15b8c6bcfd846e1fa55a37a29230bc4cec035ad03faf48d121fff92863); /* line */ \n            coverage_0x0dbb89fa(0xdf4ad020c3e5fe3a3e2b17cd62ce82b4f4bd4c24b6f22d11731decb8ff610237); /* statement */ \nif (!pointVal.isTuple()) {coverage_0x0dbb89fa(0x75ade5e82e55917c037698ea9aa47e50eb168d0cddda78b7c642f56b0b3b0335); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x9b56ecdf47dc8f6bcf977aa695cb47283aeec1d9fa51d8f812cbf4541825badb); /* line */ \n                coverage_0x0dbb89fa(0x015d4eb31a2c72bcae20aa74f07f2f5fc3765d635eff4f1bd0682985d4f0b9ab); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0xfb9e4f7f7032722a213128e3c1bff22dfa10d5bea824309d382efe137b2c7d98); /* line */ \n                coverage_0x0dbb89fa(0x7617414a969fdc516ec6bfa4e4b2dfb865493813a6ae3415f926bd47d394ffb6); /* statement */ \nreturn;\r\n            }else { coverage_0x0dbb89fa(0xe7f5d6dcaeaf5687362b1562d735cba02673b19645314b8d42163ed130bc8324); /* branch */ \n}\r\n\r\ncoverage_0x0dbb89fa(0xf085067b2aee4b1c00cdd55a63076d696808964e19b078ef7350666babddaabe); /* line */ \n            coverage_0x0dbb89fa(0x830597dd6522d998431f9947a5526a491bf21ec265a0538c3b728747aa8c7f63); /* statement */ \nValue.Data[] memory pointTupleVals = pointVal.tupleVal;\r\ncoverage_0x0dbb89fa(0x10a2b0ff7fc4849d3dafa90f6f13f85e4562a78b291fe756a9ca710cc170eefc); /* line */ \n            coverage_0x0dbb89fa(0xaee45c2f46625e438616725eeea03d3452fd9b980e7368e968eff6bcf6df5752); /* statement */ \nif (pointTupleVals.length != 6) {coverage_0x0dbb89fa(0x1b883947d7fd1f99b3d19759ce8e61415534003ea82182a63f2a031913eef543); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xc9168c50db2b33f6cfc2fe0bf5382285de3d7edbf5b2c085d68264af066a8821); /* line */ \n                coverage_0x0dbb89fa(0x31d5431a188cf6772d6b7ba33964230e94b83d6fc2da6270a69a2f5fea2c455c); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x73fe35ee37af87b8a2d964ffeb341cc5b609af79bddaedd3034ece4ebb341d75); /* line */ \n                coverage_0x0dbb89fa(0xf063bc111b1b0586ac6828af65be53907662843f284493a5eed2088f1b2f0f8d); /* statement */ \nreturn;\r\n            }else { coverage_0x0dbb89fa(0xafe326b726fd5d4375f7e0d66658cda18f223c14474179e716efc6e673d0b41a); /* branch */ \n}\r\n\r\ncoverage_0x0dbb89fa(0xf81a001ad0f5b4a844a881933372735e59914f7bb86c8e9d7e9eda18462e0e16); /* line */ \n            coverage_0x0dbb89fa(0xb8ea8e02c109b7dc2f37b9230fcce7af99cab7b2992bb1b54473a59201bb1813); /* statement */ \nfor (uint256 j = 0; j < 6; j++) {\r\ncoverage_0x0dbb89fa(0x7d72373c00dde20a94265ee12b0de0c25c52fd060a32d165b8970ca7ba901c00); /* line */ \n                coverage_0x0dbb89fa(0xe16cf150ba9f4208b94a3331ca4786fdae514295ea8610a6202689e00f843d3e); /* statement */ \nif (!pointTupleVals[j].isInt()) {coverage_0x0dbb89fa(0xd9e2519358535fc309fcebe56d15021c041f97a19d9a2ec9eecd7b918e09e2f7); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x5750e29228cd64471660a5c7b62195208088325eb3abec76b69502d6e48f7ed4); /* line */ \n                    coverage_0x0dbb89fa(0x8bb131040dcbc593b9f23048d30bcab4bb639ea7c12c3ead75c6288fbc86e8fc); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0x2d566c07cfd789a9e99f2a172229d6ec8028d742f8bdfd3f0eb579796816ed3d); /* line */ \n                    coverage_0x0dbb89fa(0x366affb87211a522b5e12c22f9f6008e09c61d38e5c5126cacf8dd1a21b0e05a); /* statement */ \nreturn;\r\n                }else { coverage_0x0dbb89fa(0xe9a22e3b94834a5412685fa883983e915658fa2f04eb90ba17a9f0920da10c6e); /* branch */ \n}\r\n            }\r\ncoverage_0x0dbb89fa(0x2b548bef820ebb900e69e932c703ecf27d02b1e9da877f842472285a306a7948); /* line */ \n            coverage_0x0dbb89fa(0x59dbf1f3b746d4e53866419f4728ddb423bee9f1329557f0b952fd611ea04d55); /* statement */ \ninput[i * 6] = pointTupleVals[0].intVal;\r\ncoverage_0x0dbb89fa(0xe5235a81966def71bc80e03237762bec39ee978e90fe67c444d2b87e9b37d7f8); /* line */ \n            coverage_0x0dbb89fa(0xea8c5f1836dc2b2cb5e09d4d576bc4c81eba551d2d0478d4f492d122002225ef); /* statement */ \ninput[i * 6 + 1] = pointTupleVals[1].intVal;\r\ncoverage_0x0dbb89fa(0x8a2432371c2d12f7326bc2f07bcd9efe69f8bf161918d7a614068cd74404641e); /* line */ \n            coverage_0x0dbb89fa(0x2a17f3770792be5655fd9d570bdea195c1c0a7ba1110be3f2beb10e61dc4d70c); /* statement */ \ninput[i * 6 + 2] = pointTupleVals[3].intVal;\r\ncoverage_0x0dbb89fa(0xd7dba5031158f9979b2deebc4369e1f0b0d37e33fdbb3442ffc91e482e55bf96); /* line */ \n            coverage_0x0dbb89fa(0x18ee3d6a30a3268e52797e557ecdab542cd3cd81296913897c032ca361acd2c9); /* statement */ \ninput[i * 6 + 3] = pointTupleVals[2].intVal;\r\ncoverage_0x0dbb89fa(0xa8e5cd618f6778b1aaa4fdb9d0c5cabe51296296a968f18d7f85907f03c84bbc); /* line */ \n            coverage_0x0dbb89fa(0xe302824e0974b0f05ea54dfb8a2d0743f94a8e82a7d3526059e3dc4d6bea7f6b); /* statement */ \ninput[i * 6 + 4] = pointTupleVals[5].intVal;\r\ncoverage_0x0dbb89fa(0x543d630253fe40272605bdd6667ab9eb9c7bc0ea9a54821efb415fa468ae916f); /* line */ \n            coverage_0x0dbb89fa(0x8eaf13b0e5a6a793c95bbcdcd806e72002e81e194b793112de02e8e374030966); /* statement */ \ninput[i * 6 + 5] = pointTupleVals[4].intVal;\r\n        }\r\n\r\ncoverage_0x0dbb89fa(0xb74c5512ba4ac4750c82eae94ee3a6a1abd8fda16a68a9e6267fd61f316d5b28); /* line */ \n        coverage_0x0dbb89fa(0x4bc021343092a5080c824e338b690f0abcd39546f7aeb02169186f1084904084); /* statement */ \nuint256 inputSize = count * 6 * 0x20;\r\ncoverage_0x0dbb89fa(0x35298ecbcd8a590dfb70cfad298b107c1b4fa554f37363dadf362856cd33f719); /* line */ \n        coverage_0x0dbb89fa(0xb06bf94e168cf6df55a067647e52cc9bf617c8310b62972a53db51ff0fbe27eb); /* statement */ \nuint256[1] memory out;\r\ncoverage_0x0dbb89fa(0xb12b69b7a1c07f99fcf2b997e4a4a1377bc36a7f158e9638e75ed6eac3cf91c2); /* line */ \n        coverage_0x0dbb89fa(0xe9a257ea900eb20b077b21bc42461fa5a8dd4dd1f2035533ec8678688ce29482); /* statement */ \nbool success;\r\n        // solium-disable-next-line security/no-inline-assembly\r\ncoverage_0x0dbb89fa(0x8a5325088cd021342fc258030ab1a1450c5764fb9af30128aff132aed8a16d51); /* line */ \n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 8, input, inputSize, out, 0x20)\r\n        }\r\n\r\ncoverage_0x0dbb89fa(0xf94c8d2d59f1b18b332f890ff40593097248af6e61990df24dca081b368e8c3d); /* line */ \n        coverage_0x0dbb89fa(0x4de07e92d43f912f409ceba18242d1f37d461a7ab5ffc066117ea4641a951219); /* statement */ \nif (!success) {coverage_0x0dbb89fa(0x013b857affd9e97d577956c43caf464283ca3464bd4647c05be2b573b2068e93); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x8665fbac578abcab4f0c6a220681fed12e78032eb0694ce5b0c9d5e15939a29f); /* line */ \n            coverage_0x0dbb89fa(0x974da7f81f92a4f41c095640ab7082281f54291c6b25f3068fa93d02484857eb); /* statement */ \nhandleOpcodeError(context);\r\ncoverage_0x0dbb89fa(0xc28a50494dd5d01306a8585ecb4482ae11e5ee3a87793427dc294f297f30b133); /* line */ \n            coverage_0x0dbb89fa(0x82b9374de99137c66997e7398f1276770f7eff0c690efd385fd0fea738bf2db4); /* statement */ \nreturn;\r\n        }else { coverage_0x0dbb89fa(0x033d8f117defa2a1ffc12c75f1dd2881b8ff6237a9331c19be5e7747dee54f16); /* branch */ \n}\r\n\r\ncoverage_0x0dbb89fa(0x87e37b59e08280a31539d62c391c799737fd92f503d68d4ea67e6b7892877497); /* line */ \n        coverage_0x0dbb89fa(0xc4528e84a393c286c778aa31a54fea7386bee4a974be94c982e29230df2b03af); /* statement */ \npushVal(context.stack, Value.newBoolean(out[0] != 0));\r\n    }\r\n\r\n    function executeErrorInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x96f1d31abd23f5617d093e208d2365ca49b8cfd17a9b041cb4d7ca639d60c865); /* function */ \n\r\ncoverage_0x0dbb89fa(0xb7b0eee4e0c3ded72e33ad9bd96b982ac7274282fbab102f309219baa28ee7db); /* line */ \n        coverage_0x0dbb89fa(0xc1f744cbabc696c9b20aa15223cf074a7ff870bb9cb5770b1511a34013e71810); /* statement */ \nhandleOpcodeError(context);\r\n    }\r\n\r\n    function executeStopInsn(AssertionContext memory context) internal pure {coverage_0x0dbb89fa(0x1e4a87d525a881d5218a55272cd122de60eb2b1db0cc9dd2c63cc9864434ce13); /* function */ \n\r\ncoverage_0x0dbb89fa(0xa83b6a4ce28c7c676cd4927196762605b7530fe645d9e67cdf1df27df0445843); /* line */ \n        coverage_0x0dbb89fa(0x374ce60986dcf0813f7348a5acfb0e7b9c032d434716bbee352b414d950a2c4e); /* statement */ \ncontext.afterMachine.setHalt();\r\n    }\r\n\r\n    // Stop and arithmetic ops\r\n    uint8 private constant OP_ADD = 0x01;\r\n    uint8 private constant OP_MUL = 0x02;\r\n    uint8 private constant OP_SUB = 0x03;\r\n    uint8 private constant OP_DIV = 0x04;\r\n    uint8 private constant OP_SDIV = 0x05;\r\n    uint8 private constant OP_MOD = 0x06;\r\n    uint8 private constant OP_SMOD = 0x07;\r\n    uint8 private constant OP_ADDMOD = 0x08;\r\n    uint8 private constant OP_MULMOD = 0x09;\r\n    uint8 private constant OP_EXP = 0x0a;\r\n    uint8 private constant OP_SIGNEXTEND = 0x0b;\r\n\r\n    // Comparison & bitwise logic\r\n    uint8 private constant OP_LT = 0x10;\r\n    uint8 private constant OP_GT = 0x11;\r\n    uint8 private constant OP_SLT = 0x12;\r\n    uint8 private constant OP_SGT = 0x13;\r\n    uint8 private constant OP_EQ = 0x14;\r\n    uint8 private constant OP_ISZERO = 0x15;\r\n    uint8 private constant OP_AND = 0x16;\r\n    uint8 private constant OP_OR = 0x17;\r\n    uint8 private constant OP_XOR = 0x18;\r\n    uint8 private constant OP_NOT = 0x19;\r\n    uint8 private constant OP_BYTE = 0x1a;\r\n    uint8 private constant OP_SHL = 0x1b;\r\n    uint8 private constant OP_SHR = 0x1c;\r\n    uint8 private constant OP_SAR = 0x1d;\r\n\r\n    // SHA3\r\n    uint8 private constant OP_HASH = 0x20;\r\n    uint8 private constant OP_TYPE = 0x21;\r\n    uint8 private constant OP_ETHHASH2 = 0x22;\r\n    uint8 private constant OP_KECCAK_F = 0x23;\r\n    uint8 private constant OP_SHA256_F = 0x24;\r\n\r\n    // Stack, Memory, Storage and Flow Operations\r\n    uint8 private constant OP_POP = 0x30;\r\n    uint8 private constant OP_SPUSH = 0x31;\r\n    uint8 private constant OP_RPUSH = 0x32;\r\n    uint8 private constant OP_RSET = 0x33;\r\n    uint8 private constant OP_JUMP = 0x34;\r\n    uint8 private constant OP_CJUMP = 0x35;\r\n    uint8 private constant OP_STACKEMPTY = 0x36;\r\n    uint8 private constant OP_PCPUSH = 0x37;\r\n    uint8 private constant OP_AUXPUSH = 0x38;\r\n    uint8 private constant OP_AUXPOP = 0x39;\r\n    uint8 private constant OP_AUXSTACKEMPTY = 0x3a;\r\n    uint8 private constant OP_NOP = 0x3b;\r\n    uint8 private constant OP_ERRPUSH = 0x3c;\r\n    uint8 private constant OP_ERRSET = 0x3d;\r\n\r\n    // Duplication and Exchange operations\r\n    uint8 private constant OP_DUP0 = 0x40;\r\n    uint8 private constant OP_DUP1 = 0x41;\r\n    uint8 private constant OP_DUP2 = 0x42;\r\n    uint8 private constant OP_SWAP1 = 0x43;\r\n    uint8 private constant OP_SWAP2 = 0x44;\r\n\r\n    // Tuple opertations\r\n    uint8 private constant OP_TGET = 0x50;\r\n    uint8 private constant OP_TSET = 0x51;\r\n    uint8 private constant OP_TLEN = 0x52;\r\n    uint8 private constant OP_XGET = 0x53;\r\n    uint8 private constant OP_XSET = 0x54;\r\n\r\n    // Logging opertations\r\n    uint8 private constant OP_BREAKPOINT = 0x60;\r\n    uint8 private constant OP_LOG = 0x61;\r\n\r\n    // System operations\r\n    uint8 private constant OP_SEND = 0x70;\r\n    uint8 private constant OP_INBOX_PEEK = 0x71;\r\n    uint8 private constant OP_INBOX = 0x72;\r\n    uint8 private constant OP_ERROR = 0x73;\r\n    uint8 private constant OP_STOP = 0x74;\r\n    uint8 private constant OP_SETGAS = 0x75;\r\n    uint8 private constant OP_PUSHGAS = 0x76;\r\n    uint8 private constant OP_ERR_CODE_POINT = 0x77;\r\n    uint8 private constant OP_PUSH_INSN = 0x78;\r\n    uint8 private constant OP_PUSH_INSN_IMM = 0x79;\r\n    // uint8 private constant OP_OPEN_INSN = 0x7a;\r\n    uint8 private constant OP_SIDELOAD = 0x7b;\r\n\r\n    uint8 private constant OP_ECRECOVER = 0x80;\r\n    uint8 private constant OP_ECADD = 0x81;\r\n    uint8 private constant OP_ECMUL = 0x82;\r\n    uint8 private constant OP_ECPAIRING = 0x83;\r\n\r\n    uint64 private constant EC_PAIRING_POINT_GAS_COST = 500000;\r\n\r\n    uint8 private constant CODE_POINT_TYPECODE = 1;\r\n    bytes32 private constant CODE_POINT_ERROR = keccak256(\r\n        abi.encodePacked(CODE_POINT_TYPECODE, uint8(0), bytes32(0))\r\n    );\r\n\r\n    function opInfo(uint256 opCode)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256, // stack pops\r\n            uint256, // auxstack pops\r\n            uint64, // gas used\r\n            function(AssertionContext memory) internal view // impl\r\n        )\r\n    {coverage_0x0dbb89fa(0x879598f4b5ee277cf128a82b9a3fcc69c2c1454c42af9f9a4ea84d0571869be8); /* function */ \n\r\ncoverage_0x0dbb89fa(0x12951547e551c92f34e46313623b21b1f69764c7ed8d4b067f1a848cbd4a789a); /* line */ \n        coverage_0x0dbb89fa(0x736be8e75f346f7d01e20fce28e2ad45338e03ef16b9f1678c936f36127baea9); /* statement */ \nif (opCode == OP_ADD || opCode == OP_MUL || opCode == OP_SUB) {coverage_0x0dbb89fa(0x92feb488ebd962d50de5f424e973f48961351529fb7b9f51863c030f7e1854d9); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xa226887543d9f39d22b6da694afcf1486c12c3830edf70a767c443527498e46e); /* line */ \n            coverage_0x0dbb89fa(0xc284ef4a24c6dc8392470ec4ebc99a50821931d022efdf8164df5451c8b4a98e); /* statement */ \nreturn (2, 0, 3, binaryMathOp);\r\n        } else {coverage_0x0dbb89fa(0xafcd914532ac2c5202e16a6f100cd6fd4397499c8568daa95d38bd6b01b27829); /* statement */ \ncoverage_0x0dbb89fa(0xbc0c085c6365d2d3eaa9911166fdf62dcbd5d9c37026bd733cabde5ddc866fb1); /* branch */ \nif (opCode == OP_DIV || opCode == OP_MOD) {coverage_0x0dbb89fa(0x4207ee2d092090c7feaaae1c42252e1f6f3b188e41be15a3448e8fd886ce365c); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xb76d5055b0c7f13a125503877dafe896ef4cd2361519552b9dcaaf09d184145d); /* line */ \n            coverage_0x0dbb89fa(0x9bd814509f3fc7cead1d686a2f74f39447c59999dfba1e5979d0aa6b66b35841); /* statement */ \nreturn (2, 0, 4, binaryMathOpZero);\r\n        } else {coverage_0x0dbb89fa(0x2574f748ffec172c3ae11ca4024bf1f8c405141b536d7ed046361bd8c09fa8c8); /* statement */ \ncoverage_0x0dbb89fa(0xf87cdbaec6f8406fdcf31220212af580a5a48312db75426833c296fd0ff7dcd1); /* branch */ \nif (opCode == OP_SDIV || opCode == OP_SMOD) {coverage_0x0dbb89fa(0xa8403d6962cfb03784f8d28a9e13ef229534a374a1666514139565c56e2859a7); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xecd47b0e686f04d00f36ea43d8f894f476336ebcc08802591c0d43357f12cf12); /* line */ \n            coverage_0x0dbb89fa(0x18f540f7d2cc8cb35bc205af52cebd8316ed92db263ecadbf4a01f2267f4f6b7); /* statement */ \nreturn (2, 0, 7, binaryMathOpZero);\r\n        } else {coverage_0x0dbb89fa(0x490a38f980b0af4f7e5301939f54701bc470110958f93284e8e32ac096ca121e); /* statement */ \ncoverage_0x0dbb89fa(0xf052af04a0d7b594ac23dc21c2f3af8d575a2c8b27fc7958960eb97a41249e02); /* branch */ \nif (opCode == OP_ADDMOD || opCode == OP_MULMOD) {coverage_0x0dbb89fa(0x584d9eef3a2ddb8f91df080727b137fe11d5407ebaf5cb8c1b481dad501efa3f); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xeac18a6b54a9348b9f57ca8c780ef23b4830ae66ccfde1239445376245d878f0); /* line */ \n            coverage_0x0dbb89fa(0x6dba9d87565af66434c2d754effc155cfd0fda3f953ff1bbad900c20fc3eded2); /* statement */ \nreturn (3, 0, 4, executeMathModInsn);\r\n        } else {coverage_0x0dbb89fa(0x3350d4be6ccc116231a7136432f87d31fbc46d8980b355029ee8d2e6f5c59e21); /* statement */ \ncoverage_0x0dbb89fa(0x72470c1a92c9e6825f8934433658c0c834a4cc13a54c7d37f20365616922c72a); /* branch */ \nif (opCode == OP_EXP) {coverage_0x0dbb89fa(0x75b00eb1e9e1d5da780d810b6c31fa5acd02f17f3cd0e2e6a25ead5575368582); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x4d91fdbb86c0b64de9ce2cb885ca164f64cadf4558e4c1fac0aec673f745a53c); /* line */ \n            coverage_0x0dbb89fa(0xfccc168ef83bb6c78f25b66ae5acf2e1026e6218f244a2317a5a9db078728c63); /* statement */ \nreturn (2, 0, 25, binaryMathOp);\r\n        } else {coverage_0x0dbb89fa(0xcd32b8db9c4c3684449abe2b729527fdd6e973bb948a000448e2277db1485866); /* statement */ \ncoverage_0x0dbb89fa(0xc36b2ca829ee6be13fcf563bcb7b23634d6aa6c9adc9ac227b150a493eaa4829); /* branch */ \nif (opCode == OP_SIGNEXTEND) {coverage_0x0dbb89fa(0xed8dfe164415f6238522ff0f09640bf3476cf89f7534e73f12b4d9ca70c6fc3f); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xdf7f409835454dffce1a6cda2bdc256517ecfb6e6e2b005417d87f981594fb03); /* line */ \n            coverage_0x0dbb89fa(0xec213b6c38358eebc9f5fe4d21f725cddf085d6b9e64a997311f7e98c5497547); /* statement */ \nreturn (2, 0, 7, binaryMathOp);\r\n        } else {coverage_0x0dbb89fa(0x3f21dd8dc991967bd8ce25b51ed2da8004dba3868b9b453df591fb5e3e88ec87); /* statement */ \ncoverage_0x0dbb89fa(0x48d1798249538a14c932b82dabf10ea7a33d61bbba1c6e3785a6a8b41bcae52f); /* branch */ \nif (\r\n            opCode == OP_LT ||\r\n            opCode == OP_GT ||\r\n            opCode == OP_SLT ||\r\n            opCode == OP_SGT ||\r\n            opCode == OP_AND ||\r\n            opCode == OP_OR ||\r\n            opCode == OP_XOR\r\n        ) {coverage_0x0dbb89fa(0x6d75ba1544ceb38bedb8f70dd32e4c87c1051ab3374b9453e797161bdaf28fa9); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x5b13f11169b232e2bdb58c51a91ce624b897987f494a811447ff87b802c96bfa); /* line */ \n            coverage_0x0dbb89fa(0x66c2fdefc7922587ae12c539143b3692af7ffddfe6eb5c071a47afc7b6c80510); /* statement */ \nreturn (2, 0, 2, binaryMathOp);\r\n        } else {coverage_0x0dbb89fa(0xb89ad877b7af250c650af1519f8525cddc832edd8dfd33a3fa73330f3d7bff21); /* statement */ \ncoverage_0x0dbb89fa(0x057e612e1e8ab1c6ae254bf280c9c10a050419a95dcd6e999486598eccfef08e); /* branch */ \nif (opCode == OP_EQ) {coverage_0x0dbb89fa(0x2f4f0bc6c3fdb0a078141d121afc030e13784f0f39f1b407bb4eba2ebfa7e563); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x4c3bc5162c7f64838f70e73d3397273e02ac06e6410616420c9c7716b95f039f); /* line */ \n            coverage_0x0dbb89fa(0x00fcbbf7bd64ca1cb8ebd84d3e682e900aad9b9c647be2cfc960b6a5d3c0c1d7); /* statement */ \nreturn (2, 0, 2, executeEqInsn);\r\n        } else {coverage_0x0dbb89fa(0xeb6faa2aedae219190afc4932f753b468296e45670ddcd6a9e468cc574835545); /* statement */ \ncoverage_0x0dbb89fa(0xa46b2ec6abfd433aef118269d9a098c47642d72700e737ff7cf1dca42f4628c1); /* branch */ \nif (opCode == OP_ISZERO) {coverage_0x0dbb89fa(0x961de844d6261c0e6ef8a5449b9fa54c4bb48d56afc13f02e6217cd96cae2ca0); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xedc9753b9c960edee4b96979ce4dbb24d4f82be8f84b07f0ed0b77874cdd6f13); /* line */ \n            coverage_0x0dbb89fa(0xebf517f5f925ef7b6093225a2577095e44c82763f8061d7892c031c022576013); /* statement */ \nreturn (1, 0, 1, executeIszeroInsn);\r\n        } else {coverage_0x0dbb89fa(0x55edacc5a37237f5ac1a9248d22f34f2cd5d18385bf7b8aef1615cec17dbce92); /* statement */ \ncoverage_0x0dbb89fa(0x42543a9baa7aeb5fa3fc23b40e9724a174424887306c3e0b8cd34ac37517ff6f); /* branch */ \nif (opCode == OP_NOT) {coverage_0x0dbb89fa(0x58653786079d8580bcca7aa1aed977250a0369529fbdff07a7bebe84a3ac25b8); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x967f2fa49d4ad078c92cb56196a19c5f3de618ef7b85ddab3ca945908be13a3d); /* line */ \n            coverage_0x0dbb89fa(0xff5df71a25e43cdc3becdf3f71f24b09ad0dad94163808e378d32ae512eeaadd); /* statement */ \nreturn (1, 0, 1, executeNotInsn);\r\n        } else {coverage_0x0dbb89fa(0x3befcbb03e7d48e196002228d74fcc5f1c39530fb86656a58916ffb9b8ea6a20); /* statement */ \ncoverage_0x0dbb89fa(0xe621045504d27c70e412f14ab2a759362ee96f75d6da3c7372b4c5dc7b5a2b7c); /* branch */ \nif (opCode == OP_BYTE || opCode == OP_SHL || opCode == OP_SHR || opCode == OP_SAR) {coverage_0x0dbb89fa(0x5bdf51ff634bbffc0547b1bdc0872cb3bfd1a5261c61dd9187fd4234729db582); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xe6f28c91666db6aad8e7e9835fb678f3a9524b0284ebd80e02155c49f434fc64); /* line */ \n            coverage_0x0dbb89fa(0x44a8b3c8fafd7c431f8eb13ede5857ec1b3a94a390f27e028852e610205f113a); /* statement */ \nreturn (2, 0, 4, binaryMathOp);\r\n        } else {coverage_0x0dbb89fa(0xcd2c67a8b975aebc13576d8f39056e46cc186b9d70e621c021f0dc0f901cf8f0); /* statement */ \ncoverage_0x0dbb89fa(0x7f2e2de6b6b14e6d97892d1a058462a2d7c78e248ab59caae7b2a52110a73dc7); /* branch */ \nif (opCode == OP_HASH) {coverage_0x0dbb89fa(0x3816056666cd9904f593b7690110638cb1a5fdac84c8ff59031fd4ec8cccccab); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xbdaf078dd7c0591bf442c194468ec7e3e92e1cbfaa47cc8b19f03a023de7b9e7); /* line */ \n            coverage_0x0dbb89fa(0xa7447d2309e65725133f5f5dccb6733326cc0eb585a48bbd5b72ea7f70ce1700); /* statement */ \nreturn (1, 0, 7, executeHashInsn);\r\n        } else {coverage_0x0dbb89fa(0xb1e3fbf2da526b877a0f2d801a714bde6805b731722b2e550723ea355659ee55); /* statement */ \ncoverage_0x0dbb89fa(0x6c3047aae9e31be1dde96482ef37416a46d7813903ecbdfe5c96b436933e75d9); /* branch */ \nif (opCode == OP_TYPE) {coverage_0x0dbb89fa(0x4c49707c7770de5fc8b0424c230a2184ebcc6e6504f3c95e07f926b449db6e8b); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x57d37c7fba741dcf82ef2c0a329fe1b8ec275c3222fcfd5a13a8b968158f47fd); /* line */ \n            coverage_0x0dbb89fa(0x56917ee7419e9942fab921b602186feb2a1ac250a9355f3c597990ac6c39b024); /* statement */ \nreturn (1, 0, 3, executeTypeInsn);\r\n        } else {coverage_0x0dbb89fa(0x3022680fe5c94c2bb00c3e87d4d785f31109d12b50a73cdba806ff2ec2e0f854); /* statement */ \ncoverage_0x0dbb89fa(0x40f5b8a92eb0c1c724575edf300c513d35b4dc6792fff5d196cca697e649aefb); /* branch */ \nif (opCode == OP_ETHHASH2) {coverage_0x0dbb89fa(0x5835872b9bd5a424f2f61785249a34beed4f716aa754ecab2f18f79323d7e6df); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xbdc29ae41e873c03689bb3b16d437ff779c692184fe790831adf7f94015d2a35); /* line */ \n            coverage_0x0dbb89fa(0xd00d3c6a715fa4f23d2ed5a1ff2c02512cbd21d546b3710597b6eeb5eaab1bc4); /* statement */ \nreturn (2, 0, 8, binaryMathOp);\r\n        } else {coverage_0x0dbb89fa(0x36c3b682b904ab03bd6d479886cbf98070dd2f8cc930eac8c8f7d379e3988f73); /* statement */ \ncoverage_0x0dbb89fa(0xc5d13b611830c7ae6d0f37a9bc361aba53e4e0e1e42eac69f06f7c64b30832c8); /* branch */ \nif (opCode == OP_KECCAK_F) {coverage_0x0dbb89fa(0xe829851e24bc732e03680807f2063ccfbd8825e870357db30b0cfa5b015b7ccb); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x3759a9eb842094554f07094eded6c646d8822c53ead61eab09781f62dce6cd81); /* line */ \n            coverage_0x0dbb89fa(0xe2f25b9ff94fc1dcef6f2474d735f10fa74ba03db8c9f88157528f45d4153f56); /* statement */ \nreturn (1, 0, 600, executeKeccakFInsn);\r\n        } else {coverage_0x0dbb89fa(0x7e04da66a2851818b52437bc2d8a9d17da8ff961b998bd7838bf7355f37dfdd5); /* statement */ \ncoverage_0x0dbb89fa(0xbb47214a861dece4105c4c3109ec9e512bab43fa4a6a92625ae75ff2a2f6c99d); /* branch */ \nif (opCode == OP_SHA256_F) {coverage_0x0dbb89fa(0x58d4026bfbdd6bd6270bf93eb4f7b69938d6c6ff2336b73540a040487b8f9f09); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x31a6fcefa263e8c4e085ecd666127288868b65315f1d1f750d7bfa67efeb1a73); /* line */ \n            coverage_0x0dbb89fa(0x92c3a6026a00a9ed96b1494583411dc9c8d39b6f1db4b38f035b10fff20248ae); /* statement */ \nreturn (3, 0, 250, executeSha256FInsn);\r\n        } else {coverage_0x0dbb89fa(0x4fa48493fef7534a230fd532075adffa03b6ddf8544ea96501eaecff3a43143e); /* statement */ \ncoverage_0x0dbb89fa(0x2eaa0ff2ed28088a0e62d2008f03ad4f5bf77414f7241939aa8614c299dd2348); /* branch */ \nif (opCode == OP_POP) {coverage_0x0dbb89fa(0x70f44c9da404a7091006ad8d6244d18a0d9fb86025b759f0e4eb82a2226464b8); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x6b6bb1e4ba4c8803b0fb438353f48024455d4efcea51484926090281e6640b8d); /* line */ \n            coverage_0x0dbb89fa(0x3c3eb23f1f8516b3f6947945d96d489a91293b7e404eac0cbfbdf1d887d477f8); /* statement */ \nreturn (1, 0, 1, executePopInsn);\r\n        } else {coverage_0x0dbb89fa(0x716a76227c0be3e8747f934819ac8cf86fbe26de45f106190067a123de7b0b26); /* statement */ \ncoverage_0x0dbb89fa(0xf7d3d2526ffe6ecde50966cb2f436aa03251faad4543ec2b4474070370fc913f); /* branch */ \nif (opCode == OP_SPUSH) {coverage_0x0dbb89fa(0x8ed66a2bbd461c74c802bf28a8132adcc1de9e1dc1cfa493120eb1425c1c7154); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xf956f1327fa35491fea56fdbe9d4222744a6e00cd6f7d2c6e26c335acae8875f); /* line */ \n            coverage_0x0dbb89fa(0x9e555f765ed9ab28a819f03cc4e618faca0cb2b2afb9a9ab6975e58a988c9595); /* statement */ \nreturn (0, 0, 1, executeSpushInsn);\r\n        } else {coverage_0x0dbb89fa(0x2eb5cbf36b76bc4956ef9deb16b8d327a6780c41a828a22ed7bf5cdaa5a9b5ef); /* statement */ \ncoverage_0x0dbb89fa(0xc4385d64ddbd084fead65d6c8eb7dcbc64c0d340eb722b02d4737d5ae3cc3d5e); /* branch */ \nif (opCode == OP_RPUSH) {coverage_0x0dbb89fa(0xadf7132a349d5d6a7efdf7feab0816e01177db75a9900a547febcb3d5441cdcd); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x8b7b05fe72fbdee52d4647ae0cd6373be834133bd77ade38f312b069eaf586df); /* line */ \n            coverage_0x0dbb89fa(0x446d22aac1c96534489e009ffb6accf007a997d8bfca80f51b633b71a0742bb1); /* statement */ \nreturn (0, 0, 1, executeRpushInsn);\r\n        } else {coverage_0x0dbb89fa(0xd36310a4bb07f1d7ab93979b245d039b3444cc3d7630bdf0310759715e308e93); /* statement */ \ncoverage_0x0dbb89fa(0x04c602e8a7d5f9350d687981424abe92e6bf7390711eaca79dc7dc416aa88989); /* branch */ \nif (opCode == OP_RSET) {coverage_0x0dbb89fa(0x95cdd1fe0b8a23a23e9c147cb8a4164128c572c0d6cb052b324ba37ca486dbe8); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xf77bc9051b157b7f473a639c4cab0fd8e9f5e6f6aa111acd1332f55ebdbf43a5); /* line */ \n            coverage_0x0dbb89fa(0xc8b4f90c41e1b113c89644f25ecd81e47a32c5e47ec806d2a8de9067b074d2d0); /* statement */ \nreturn (1, 0, 2, executeRsetInsn);\r\n        } else {coverage_0x0dbb89fa(0xcdcf02f8d0863c16cf9a154c64e116e34c42659413f54357e50988f9c1b71d54); /* statement */ \ncoverage_0x0dbb89fa(0x920908703249e546e9ad636ed75938ef8a89e20b4d6c3d41ead176d5bb355fa5); /* branch */ \nif (opCode == OP_JUMP) {coverage_0x0dbb89fa(0xf70b472d0372324caf06da62f394249ca55ce57aad368bc2e7c0c61600d4bfeb); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xdb6aa37b520806af14df4d8ac2ec7e49c7028edc9b19d8783433682ead3c3698); /* line */ \n            coverage_0x0dbb89fa(0x46d12c0befb44f4fba06813d0b63ad5b1251d7f26bdad80854fcc293205d12ef); /* statement */ \nreturn (1, 0, 4, executeJumpInsn);\r\n        } else {coverage_0x0dbb89fa(0x84446a8562b3f6c057296d14e2d2b7623e778266993e07226ffc78248852ec2a); /* statement */ \ncoverage_0x0dbb89fa(0x970b719896211970db9becfc70a4c5f3ed533967bdefdb2550cd97a38793ca9c); /* branch */ \nif (opCode == OP_CJUMP) {coverage_0x0dbb89fa(0xda199d9014581db548dfb5ef468a876402b4c76f22e5bd30a9e4352c283c2ced); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xd80d68f33a8983ea95a4ffb12911cfd2f85fbfb550b90a695c11ee4e0a774c59); /* line */ \n            coverage_0x0dbb89fa(0x08dd3c375628e2f20d4be06c79e0f431108c10d3d88983654e2cadff6b782083); /* statement */ \nreturn (2, 0, 4, executeCjumpInsn);\r\n        } else {coverage_0x0dbb89fa(0xec7071257b62ab1d5c1f06ba3c5660a059910faff6f8621ddde3c7c32f696553); /* statement */ \ncoverage_0x0dbb89fa(0xe678a2a9c8a5fc57edebfbe5741536dc2e98b6fb2a57bdc0b2b7ae38383a5033); /* branch */ \nif (opCode == OP_STACKEMPTY) {coverage_0x0dbb89fa(0x4dc969149d3a4393df58536255a4c4587864d7d5c1d851b306d171ddf36318f6); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xbdf089c0a745d8c69569b7eb7e30a2c570c8d70578a9bb40caddedcb9662afb2); /* line */ \n            coverage_0x0dbb89fa(0xce8c1390d1a2a4a63012982079aafef5d7a1f5e64e1c156e3cceb64427f05a74); /* statement */ \nreturn (0, 0, 2, executeStackemptyInsn);\r\n        } else {coverage_0x0dbb89fa(0xaa87f4f0a48dbbe7798e2eea6b6afd1a0cbdb6fcef85ebcf2a5e0c6ab9be2717); /* statement */ \ncoverage_0x0dbb89fa(0xda687534c8eb6dad7eb5616d20ca16609bd9bde55f886ec90868a1b7b40c9b3b); /* branch */ \nif (opCode == OP_PCPUSH) {coverage_0x0dbb89fa(0x1d5242263f7e523dde7fd7a19a10257b6ec00e31ad8ac78053970e54d2334310); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x2d44882728bae847642c4dedb458fe5f4f2a4b303a18beb26dbfaede9eaa76af); /* line */ \n            coverage_0x0dbb89fa(0xb5635948931af59d47b2b1206a0cb697e19430696b5f0e528c091ff56d8f9898); /* statement */ \nreturn (0, 0, 1, executePcpushInsn);\r\n        } else {coverage_0x0dbb89fa(0x6b3e48645226673ccb26ad57a0d3a0a95c1e955823c558b1128ee6fa7492239f); /* statement */ \ncoverage_0x0dbb89fa(0x7f83279459dd6c9bab68cd881aae7932f2808416c0e3628e583ff216e6d83738); /* branch */ \nif (opCode == OP_AUXPUSH) {coverage_0x0dbb89fa(0xff2232bc25aaf11211c202b91bb28b7c1fef4df17b96dee03ce33d5862bff001); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x878e53e6ec41bdb47a5c1a7bb1efce6ae128036ddd5ad0e3bc24142f76bbc215); /* line */ \n            coverage_0x0dbb89fa(0xe67cdf9c5746cc048d79fba7abb51768b4aee3349742f2c7395ac438b1b07e66); /* statement */ \nreturn (1, 0, 1, executeAuxpushInsn);\r\n        } else {coverage_0x0dbb89fa(0x390c8f6ed031c5421c7495f535e9471f8404bf20da5a75772894303ca9990f61); /* statement */ \ncoverage_0x0dbb89fa(0xdfd70f2791f9482a27ddc70e426c17dc87e343fce17cbb2956eea89701f10abb); /* branch */ \nif (opCode == OP_AUXPOP) {coverage_0x0dbb89fa(0xc6cd51b3f4fd119220ec1ac2a34d6b6f8115df4f87c8a1bc6a6807aa9b5a5a51); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xfe657f7e8aa8c177a0d513992918899cf608b1e993113d045e303f62a2d6429d); /* line */ \n            coverage_0x0dbb89fa(0x5edbcb6f0f160adf4f0619b8da4a130489b2521bcca28438d1c03df318e44705); /* statement */ \nreturn (0, 1, 1, executeAuxpopInsn);\r\n        } else {coverage_0x0dbb89fa(0x1f929c98a4eb9b90362b9331e76e4b7ac13e30c8476016bc607d7d0b4f79aba6); /* statement */ \ncoverage_0x0dbb89fa(0x7605da585f54e936825f78bd4af03b9337dd567a1bbad4fc66cc98a36696abbb); /* branch */ \nif (opCode == OP_AUXSTACKEMPTY) {coverage_0x0dbb89fa(0x77d6a6f7438d1bec9d4f16d112ff8ec1806cd20aa1f868ec421586f5fd7c4365); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xb2767f05fc9139868c81b75dc7f74418dc2178967735d98f5f9bbd99a3153e44); /* line */ \n            coverage_0x0dbb89fa(0x825433226eb66ec6bdb135bd386a06611dd96c88e7f60cf4dfafe5b73409ed68); /* statement */ \nreturn (0, 0, 2, executeAuxstackemptyInsn);\r\n        } else {coverage_0x0dbb89fa(0x6bd8e80428ef26c986f47c94d1ec2c2a6af3dee9d990bc1ce7716d8132b178d4); /* statement */ \ncoverage_0x0dbb89fa(0xcd84570db7b83a33eab070cd69076f369b3dc28d9cf686c67fe1d7ce91ad2301); /* branch */ \nif (opCode == OP_NOP) {coverage_0x0dbb89fa(0x5f1604eda6c65e08a02e691488c50f4fe6ae6162bc876927a9628bfaf5c6f541); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x647a338fa5357a8fcd79c991454a090e4eab9acb108dccfc9edb4b30a0684994); /* line */ \n            coverage_0x0dbb89fa(0x6514f768dc02140edc21e0f5b38d56fa93d1ff8f8b6ad3bfb3577a4661ae9056); /* statement */ \nreturn (0, 0, 1, executeNopInsn);\r\n        } else {coverage_0x0dbb89fa(0x0d7c3a0e35d19f5f15878282a9f230fa9774744038d2de2615a768440d206ef8); /* statement */ \ncoverage_0x0dbb89fa(0xa56a140d406e33b8473ef5c853f08e0d159f04f6e826339ff88b7274dd9fa620); /* branch */ \nif (opCode == OP_ERRPUSH) {coverage_0x0dbb89fa(0x3ef46eea2a238d7b037daad72b69494c9adf0b092486a9a23a2116f97d297ca0); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x65317d8823eb400799ba1d50d66a47ec1878db94cc08b62b135ad90c31b7b159); /* line */ \n            coverage_0x0dbb89fa(0xaa28a0baf6516dcb966ea1d3e9bec0f17b4b7b4ef61f7db743db6177efdf3f1c); /* statement */ \nreturn (0, 0, 1, executeErrpushInsn);\r\n        } else {coverage_0x0dbb89fa(0x79fbd778a63dd79022cd4e0dad9d588916b9be2fd63fede62da8a54f2cbad8ea); /* statement */ \ncoverage_0x0dbb89fa(0x68bc0f757d27bf683b68a6504c0b17246a6f0672bf0a61ce9e34464482896944); /* branch */ \nif (opCode == OP_ERRSET) {coverage_0x0dbb89fa(0xd87f20a07aab1b7b4f5a50e144d45851a03bfa9b1ceb3ae503371bda7035de9e); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xde8e1d5e11be3a2f5b96b2f90f6d41cf89e72ed64d2daf3e398a54a3ed7a9269); /* line */ \n            coverage_0x0dbb89fa(0x8dfa6947372d76ba25a4e0e45b2260a51790ba5dcc447229a32627cd9cd8c3d5); /* statement */ \nreturn (1, 0, 1, executeErrsetInsn);\r\n        } else {coverage_0x0dbb89fa(0xf12c73df5f314c29fa92767174662ae84cad3bdea7240621c9e2ca6530f9c9b2); /* statement */ \ncoverage_0x0dbb89fa(0x26c1f65599e1fa80238e0f9ba9e827ec1f7d56a783bb77be328baafa1545cc65); /* branch */ \nif (opCode == OP_DUP0) {coverage_0x0dbb89fa(0x4860b6f7ad75c57235dca13d263f1066bf70e527b7d6dd972425fefdddee7085); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x03962efeb015e88c0fb4c5865a8b2d7bbf8029bbbcec1e5c9a76a93b57e70c84); /* line */ \n            coverage_0x0dbb89fa(0x6caa0a2baab75a0d52de05d024a798d6c100d8a2197b2bdf8e55bcece833bd05); /* statement */ \nreturn (1, 0, 1, executeDup0Insn);\r\n        } else {coverage_0x0dbb89fa(0x3067370a895ce1ee639470bd768a3233d1a6ef2898ee7f3d72ad6603be019951); /* statement */ \ncoverage_0x0dbb89fa(0xa0e90f0aac214de29ce72c74b6a0c7a94acf9668b73d4d10a1d8e90336fde702); /* branch */ \nif (opCode == OP_DUP1) {coverage_0x0dbb89fa(0x607d2d6911e5a52bd698e8adcdb1954f23ccb4d755f7e28b41e905fc1662242a); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x6236032d40d11c69f16d31f7ff9bca4b0bd9d19df4e77052cdbc03e5eb78c3cb); /* line */ \n            coverage_0x0dbb89fa(0x3bbc4deb1392e1bd785f74fc9694171df839a5bfdf9ab227d51462e001e5f0c9); /* statement */ \nreturn (2, 0, 1, executeDup1Insn);\r\n        } else {coverage_0x0dbb89fa(0x04282b21170e9b0cb39d0314bfabec27ee4c9d0b19606c228ba0c21c466a096e); /* statement */ \ncoverage_0x0dbb89fa(0xa08510ad91b32e43834ca39975eed2d53fb627778afc0de4f20b907fc0709a7b); /* branch */ \nif (opCode == OP_DUP2) {coverage_0x0dbb89fa(0x68545e6cbfaca29b2450ced1bec7ef4433ece774b2cd35d5c42e4ca7b1c6849a); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x890fb4c3d6e8bb359ce95f59b15435bc8e0aff53543babd330afcb10a496c31e); /* line */ \n            coverage_0x0dbb89fa(0x3f86f755a1c73e4d4bb895294af0372d28e858dcb97029fbc70542f8c2590fe3); /* statement */ \nreturn (3, 0, 1, executeDup2Insn);\r\n        } else {coverage_0x0dbb89fa(0x050fd75833ff944f91f5ec3992cd4c94bc486b6a5ae4f463cd2c208d8f8acfb6); /* statement */ \ncoverage_0x0dbb89fa(0xfb64d75d270f8395d1ada8812f98abe814e9d8eab9dcbfa5d3e1f271b17b3160); /* branch */ \nif (opCode == OP_SWAP1) {coverage_0x0dbb89fa(0x4fd404bb72ac69d54674faa821ed1ebe5a13c275405c3fbc6afb0aaa9bf4c485); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x26107ce99b11c5f1c07021aa7fbca2c5cab127df8f798b9e642ad603d43419bd); /* line */ \n            coverage_0x0dbb89fa(0x6606c3493c675daa3b83cdb0b241be7e64dfe9ddf2dc87e38f0dd8b36d1245a3); /* statement */ \nreturn (2, 0, 1, executeSwap1Insn);\r\n        } else {coverage_0x0dbb89fa(0x7251ce09e184b9379741fdda317e2177e85d0cf42b45a8c83fc90ac1ef2a432d); /* statement */ \ncoverage_0x0dbb89fa(0x1366db5214751874d0983a45491716a9c549855f3af8a779c947135371dcc167); /* branch */ \nif (opCode == OP_SWAP2) {coverage_0x0dbb89fa(0x358d67023a86fb5eafebab11dd37eee38d1c16d11f0458f4e3008f22d4effb2e); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xd0a589eb7991f917336fec01e58a4255bfc1458c0b4d18f135dc86c90f19eaae); /* line */ \n            coverage_0x0dbb89fa(0x08a1923d2e6a05f2882208b0ef5ccfcacb26b248896cdee7c0d67a6c5c07508f); /* statement */ \nreturn (3, 0, 1, executeSwap2Insn);\r\n        } else {coverage_0x0dbb89fa(0xfc5ed80b65314cf9fb3cd7c4778f145eecddc3faede2a5b63cf31b6eaf2f9fec); /* statement */ \ncoverage_0x0dbb89fa(0xf89a32d1d8f1666c462f0663015408c7d2460d7eb8c3c6745d8937a41c04663c); /* branch */ \nif (opCode == OP_TGET) {coverage_0x0dbb89fa(0x3e546e2f16eef21292adaeb0d062e825e2259adff74b76f3291fc55a892b7519); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x7f18c67fffd1cd5d5ccfdf6523a6d6c751ced7141cdea94ad99040c398315c83); /* line */ \n            coverage_0x0dbb89fa(0xbe37c4fda8044bce44e84a019dfaaa7edd676715f45f7d1e3e58481b69cdd1bf); /* statement */ \nreturn (2, 0, 2, executeTgetInsn);\r\n        } else {coverage_0x0dbb89fa(0xfa4b03fdff4d014831cd8b3b156d344f3859a19313737d12a81dbbca658f2b7d); /* statement */ \ncoverage_0x0dbb89fa(0xca6a091de4cc8552cf50220ea6c3b976ac9f7552a426f3f4bd10b74923a148de); /* branch */ \nif (opCode == OP_TSET) {coverage_0x0dbb89fa(0x4b010683c3eebc6d6d4d343bf85977526907423d6e4dd45f1c38870ec7fefa2d); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x8755014657444388f314fa1acbb95f006cc0ce8b4eb14463acea57b2b2512e59); /* line */ \n            coverage_0x0dbb89fa(0xe83aca918b64244dcb9c5c5c34f80c5a560a831a16ad0970f94eefdb7efe4cc4); /* statement */ \nreturn (3, 0, 40, executeTsetInsn);\r\n        } else {coverage_0x0dbb89fa(0x577abf950497d27136b90f32ae460538547a5f487bd8ab03984acfc7e19f0786); /* statement */ \ncoverage_0x0dbb89fa(0x88b9856a9c4724571ab988f1a2bee263fd8c24d580ce45c2a23d74a7481620b5); /* branch */ \nif (opCode == OP_TLEN) {coverage_0x0dbb89fa(0x29714d53e738c612c7191d899710989b02921a0674d03041162b480764c57eac); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xae704faeab622e3b0602e8c4ea0fbecd0982e3d780673357530edd70a2a8b189); /* line */ \n            coverage_0x0dbb89fa(0xfd0a89fdb32102a4b2104e5fed368e68cb6a3f8ce6abcb52c59c3d76ac0eaf31); /* statement */ \nreturn (1, 0, 2, executeTlenInsn);\r\n        } else {coverage_0x0dbb89fa(0x2b656716d80864b5e9e6f0b6533c430e17bcd3043a3b83834166948f487690b7); /* statement */ \ncoverage_0x0dbb89fa(0x682370ba0106388dcf55693812ed5e9439587465df25fbd92f3547500fc8a7d8); /* branch */ \nif (opCode == OP_XGET) {coverage_0x0dbb89fa(0x3775ef785122e01263eccfc690946467e9f7bcb527f74dc2809ef3537bc98079); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x9dd116104686491db8ddd5820a2f007804676633235af7da5fc69e39b557a49d); /* line */ \n            coverage_0x0dbb89fa(0x280fef50f93614557d0e419868a539f3709d2335debc6a0fccd50ed44888d6a2); /* statement */ \nreturn (1, 1, 3, executeXgetInsn);\r\n        } else {coverage_0x0dbb89fa(0x076b338f79f6cf9a469aadbb2d7fab80b7ee53a81177d429388abdb7780b52d2); /* statement */ \ncoverage_0x0dbb89fa(0xdba48443d48ccb3b9f656cdab65ad43e8db2b93715024881058611d7f7d3b072); /* branch */ \nif (opCode == OP_XSET) {coverage_0x0dbb89fa(0x3521a4ba106b5ea8d6ffa3575c68caf771c5371e66a081f6e123053e52ee0e9a); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xb58ed6d06e7e4a0ed3f8444ee2c2f8ee19f040e6fca5a43da36230cd91dc0234); /* line */ \n            coverage_0x0dbb89fa(0x9426a2f5a7e67cef5d847a2db1543cace12bbf98c42d072ec97cf205e2e4fd2a); /* statement */ \nreturn (2, 1, 41, executeXsetInsn);\r\n        } else {coverage_0x0dbb89fa(0x88c0523e5afc9b411a85ffe449f4d1a79af7fc36165ab721dfb8704864b8c360); /* statement */ \ncoverage_0x0dbb89fa(0xade6f13a94307f12fd119050e20e6ce84859292c2a329d5021896dbe557a4701); /* branch */ \nif (opCode == OP_BREAKPOINT) {coverage_0x0dbb89fa(0x214deded52b9e079acd776d729fbf35a7b1b761011247ed2034b78ed63550046); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x31b00761f9c2199913b8fb223431e0656cf7abf89be344169f8e5964065e5d22); /* line */ \n            coverage_0x0dbb89fa(0x32113252fd96f6e14716062253abc50bbb53d1d87fac640dd3faba31eb271778); /* statement */ \nreturn (0, 0, 100, executeNopInsn);\r\n        } else {coverage_0x0dbb89fa(0x76405057c6eb531774dec20bd04fcff90fccd011ec39d5edfdf4308044c50e0c); /* statement */ \ncoverage_0x0dbb89fa(0x71c989e24b77e187952a30e6084fb4d910d129ea8377306489522a2f05d81432); /* branch */ \nif (opCode == OP_LOG) {coverage_0x0dbb89fa(0xe43cb2f007841269cea07035dbd226149e7de5a42bdd91b05746e7ce89831149); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x10583c94c26a216bf529aac72cd8bf166871f52e45b214cb3961bb9a5f441b44); /* line */ \n            coverage_0x0dbb89fa(0x71665894d448be76a14b9e2e8ff4abf49881f2b6277415b59fd651ea10c873b8); /* statement */ \nreturn (1, 0, 100, executeLogInsn);\r\n        } else {coverage_0x0dbb89fa(0x82d9d8b1e8926c55754efc6edb97852f04dc113ab1c1ab2715a25e11e5db91be); /* statement */ \ncoverage_0x0dbb89fa(0x9164e7ffb407164dabe9c6f75fb3e320695a5338aeaa5d3b297bbe3ae72724e7); /* branch */ \nif (opCode == OP_SEND) {coverage_0x0dbb89fa(0x78bf91698f597967abf79a2c04b999a3e40a5a8475623589bff45bea3468759e); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x4898afe28739b3ecfab5e09149ad515cf4f071b0d7d521fb32dfc0a181227f02); /* line */ \n            coverage_0x0dbb89fa(0xc3c1cd1e119458aa004e8ab9a3b55e712d5cafc34c6be9a3e229f21a51a74b93); /* statement */ \nreturn (1, 0, 100, executeSendInsn);\r\n        } else {coverage_0x0dbb89fa(0xb01c32c5a20a4b6becd8b1141c2c27a09bed334060dacc06d5bc91bc21fe589a); /* statement */ \ncoverage_0x0dbb89fa(0x9d7e6b3cc73811ca04a60c30a585471bf1729eaf39b9dd0053e573d55038f0d6); /* branch */ \nif (opCode == OP_INBOX_PEEK) {coverage_0x0dbb89fa(0x4026282a13147f8eec992ef06e6025b191ee014fe6ec2248998ad5a8d65875b7); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x08595405cfbb58266f1a8dfba8f9160d8397e46140818b5a4cf20cd8abaad2c7); /* line */ \n            coverage_0x0dbb89fa(0x47880d21a98cd221d10159d27f76854bfb27bfecbdc560dc8c6612771883e8d2); /* statement */ \nreturn (1, 0, 40, executeInboxPeekInsn);\r\n        } else {coverage_0x0dbb89fa(0x39e5715d281c7b0288b93ca4b792f9eaf4368198c455a9b06c43f7959cd316f4); /* statement */ \ncoverage_0x0dbb89fa(0xe6cc09411bae4ec2a61e6e064fac8ffd77885d687ad6ea811fb85a0a9e2dd1b3); /* branch */ \nif (opCode == OP_INBOX) {coverage_0x0dbb89fa(0x7bcfdbd32cc71e3064d164da93936c71b345c46c05349ff58c37dc41306f7c6a); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x49fe6cd96cf55213223efe3ff4ac30f271f92ef61e5e87b07298e924c524bf35); /* line */ \n            coverage_0x0dbb89fa(0x0df08fcbbcdad68b36f80be680e8cd7d3c49800f639486cdce23743c16042276); /* statement */ \nreturn (0, 0, 40, executeInboxInsn);\r\n        } else {coverage_0x0dbb89fa(0xb8d113f81fbab316c00b7c97fa2fffca3a29c61cc09d63b1d5983a29f34d26ad); /* statement */ \ncoverage_0x0dbb89fa(0x9da5e0c52a7c5dd3f300f1b4f7100ecfc26d0768e479c262cd7a3db61d839ddd); /* branch */ \nif (opCode == OP_ERROR) {coverage_0x0dbb89fa(0xd78aa6aca7ad7cc1b860b16c82fb2726b020b896a291b43b446dedf2f9cbde35); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x1f5da02773ec558de0e865aaba625d63b3e09f8099767892c666a9f0aed634d9); /* line */ \n            coverage_0x0dbb89fa(0x71c5e8a653e04a63e845888bc02bde94331f0931afc0ed1dc5d15d3329717186); /* statement */ \nreturn (0, 0, 5, executeErrorInsn);\r\n        } else {coverage_0x0dbb89fa(0xf6b3283a8fe719d44e0fe0a33261d913beade559160aeabf11124fe07371ea89); /* statement */ \ncoverage_0x0dbb89fa(0xbac936ec6c41abd258048d45a52d2e98aa9f1d08b92aa8fd3986bc7bae9c8048); /* branch */ \nif (opCode == OP_STOP) {coverage_0x0dbb89fa(0x5e44e7af6658559b061dc9bde38d32b236a17d3f5ce4b3eaa4974cdf46dde7ed); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xbfcb932e6339bcc1f9e0d1d19e06a7670a1740ddd63b0ecd064664f4e7dd2b01); /* line */ \n            coverage_0x0dbb89fa(0xe649199a49464833ecd630153637b180fa75bb04037b228e715ca0db6e80c3ff); /* statement */ \nreturn (0, 0, 10, executeStopInsn);\r\n        } else {coverage_0x0dbb89fa(0x2553eca24e0624dad7cf93b70885f1f6e56f85b3822834e16a5b9ef5020af17a); /* statement */ \ncoverage_0x0dbb89fa(0xb3d32aee6bc0f94e59655916da8072af007b5043d33d74e0541cae346c1adb0d); /* branch */ \nif (opCode == OP_SETGAS) {coverage_0x0dbb89fa(0x0db6f92c3af02b9ee92838c48110a278791665a1633ed69edc60438c8a66693d); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x14e48de3d9630a58264bac0410aa06a98c24e8d2cb48bf73ff52d4a76487a8d6); /* line */ \n            coverage_0x0dbb89fa(0x64cffc6279f296c655fda3c9dad0924ff9e4675484256ffe1ea96bc30661c028); /* statement */ \nreturn (1, 0, 0, executeSetGasInsn);\r\n        } else {coverage_0x0dbb89fa(0xe532317e7b20555438076ce7d82a5893367599b45bac869d2c2fea408f47b569); /* statement */ \ncoverage_0x0dbb89fa(0xd3f19acc35fc965468218832bcd4921f1bb39bb2a1699b9150d8bb70c36356c5); /* branch */ \nif (opCode == OP_PUSHGAS) {coverage_0x0dbb89fa(0x65acce1f9613dca0660a962da01cb9c865c8faa07b38ae95d07c8fbbb185a2cc); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xd0798c6c17366edf22b2764745a08846b6a16d3441be8a5f08946d3c78e76172); /* line */ \n            coverage_0x0dbb89fa(0xcf2ccddb6c61321c6743dfe336dafe457d840f57844580e616ca56625078fefb); /* statement */ \nreturn (0, 0, 1, executePushGasInsn);\r\n        } else {coverage_0x0dbb89fa(0xaf64820282868b39e73942403592fea5d0211eae0c1711a214c731e2edf50ad7); /* statement */ \ncoverage_0x0dbb89fa(0x9f8bd4347beab650c339afcab667963de30d7bc2567ef8af81ae924737b33157); /* branch */ \nif (opCode == OP_ERR_CODE_POINT) {coverage_0x0dbb89fa(0x1c59d0d2d777753ba9de6f6c14c30488a6bb47baa1260bc99b6eb58c28ffd59e); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x34dc1d41cb10a759d458509ba552cf3272b585d557e042a061fba3886361d83d); /* line */ \n            coverage_0x0dbb89fa(0xeda884c91da65b0f772443eb9ff8352089eb4b04eb380b840ff18bd5bbcd011f); /* statement */ \nreturn (0, 0, 25, executeErrCodePointInsn);\r\n        } else {coverage_0x0dbb89fa(0xb61910bb75bc19a25ef67d5dd8cf846c31cc171c5e41289bf12228a034ff81a7); /* statement */ \ncoverage_0x0dbb89fa(0xe8fd14ff7a45eea598bf6b0dfb9e8cca8c387e1170d3614e67a8b7c760bbfe79); /* branch */ \nif (opCode == OP_PUSH_INSN) {coverage_0x0dbb89fa(0x3d8372a5867e4b76e7e174bd0c93cfb617459d3d0cbfdbf1bd7a94564510c035); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xe7a04032b0dd4867ac7c11250a3c8dbb56c99a3e7ab747f8fa0fa0dda4a85a3d); /* line */ \n            coverage_0x0dbb89fa(0xce17fb3809fd8b270ad567b6b11338ce490977c3b62410dc8fbb5f160bd5f8c9); /* statement */ \nreturn (2, 0, 25, executePushInsnInsn);\r\n        } else {coverage_0x0dbb89fa(0xcda3d72c8b3dac28c6aadf9ace2e89ebfc320b45c2b229d7c0bfc076c679f868); /* statement */ \ncoverage_0x0dbb89fa(0x65c45977a269b47e1920dfa195b51a823361826653f2f3ae6346c49d25a86d4a); /* branch */ \nif (opCode == OP_PUSH_INSN_IMM) {coverage_0x0dbb89fa(0x451e6b6380de20603911df1fe29672b109ba95cb152a8659bc70a3fa7a44b172); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xa1fd62f085f106f390f462fe66aa2148760e9ca9909d9c655283bc419cd334b0); /* line */ \n            coverage_0x0dbb89fa(0x7d54ffb55f3df7c5e6f091dfb409e7eb97a40284650d458768fc157ee54dbaf7); /* statement */ \nreturn (3, 0, 25, executePushInsnImmInsn);\r\n        } else {coverage_0x0dbb89fa(0x80456d4b400c4ac789d353bfdca905e5e668d99352e9e18f88df57cfc4c230b1); /* statement */ \ncoverage_0x0dbb89fa(0x0466cbf007595805cd137f481b8500a9f8982ba1715dca9ca324036f66afc016); /* branch */ \nif (opCode == OP_SIDELOAD) {coverage_0x0dbb89fa(0x37a816d089d291fed4be400ba69919c177bd6698c704c1b1acecda325851028a); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x8b38ef07999b757d0c02406cbe2379d3a56de398d23dbd8911dca2d98cfdcddc); /* line */ \n            coverage_0x0dbb89fa(0x08d1958d838e0b476731a1b0e5e5170f7cc93e433140a05fc154374231c7dc46); /* statement */ \nreturn (0, 0, 10, executeSideloadInsn);\r\n        } else {coverage_0x0dbb89fa(0xd2983df506453e57820ce590782f05d65f52268b9d83de2a478ec094b2842758); /* statement */ \ncoverage_0x0dbb89fa(0x99fac86ea408a10f4fc32f5ab3bc7cbb3f6812707bb78be7c006c967a7bae187); /* branch */ \nif (opCode == OP_ECRECOVER) {coverage_0x0dbb89fa(0xe04dfe405847f3ab9b0bd13647fd11e4f673816998f10ef2083c464dda86fcf9); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xa106efd0273d412230552f92edc2ac736478def5da43ae995b605f05dcbcdb1e); /* line */ \n            coverage_0x0dbb89fa(0x0660395b7689161f0df980db8c54872539dae6eebdfc06d3ea1cc5ee87ea2a10); /* statement */ \nreturn (4, 0, 20000, executeECRecoverInsn);\r\n        } else {coverage_0x0dbb89fa(0x52e4bdef2d78cd8d5cfc3a1860081ac2f3f8623b3f3a7118cd038e587dccd2a1); /* statement */ \ncoverage_0x0dbb89fa(0x9ce18b5378ead69574c4447ce106ab77310aae74b5310692688ce806321da700); /* branch */ \nif (opCode == OP_ECADD) {coverage_0x0dbb89fa(0x34828c0d61b4b011da800c44c8440964840f67c06e0aa4133df96e2a54305140); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x7d03a213d406847cedb12997f446c243662c2f74484259d4dff2ed3e44a42339); /* line */ \n            coverage_0x0dbb89fa(0x7b374755a12058c0f7320e4f6629d0707b592fb77bf192c66f81fe40e72f3f57); /* statement */ \nreturn (4, 0, 3500, executeECAddInsn);\r\n        } else {coverage_0x0dbb89fa(0xc6c2caa46d42cbe66ba1d02e9372f2e01ea0a1be2d98eed578fc7fe3d25f6eb0); /* statement */ \ncoverage_0x0dbb89fa(0xf591279137103fdbffdf4cd2a9aa0c2cf8b9cd5eb9fc638ee81fc9067532746e); /* branch */ \nif (opCode == OP_ECMUL) {coverage_0x0dbb89fa(0xf642e92d7d31e1b72540d46a9d76af1797cf9c8569b3a853d9dc7821d6c3137a); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x0cf8904ae06dc32e05bade2d0869baf8cdff26c1efabf788cb2acd3fc7115667); /* line */ \n            coverage_0x0dbb89fa(0x263316986e3bb0db428be037188c313264ff085d8d6e7d2ac16d6ffc670b5922); /* statement */ \nreturn (3, 0, 82000, executeECMulInsn);\r\n        } else {coverage_0x0dbb89fa(0x7684813c951e4e23cf6425892aa5373c0208fc957bfdc98223f5f48f16609c1c); /* statement */ \ncoverage_0x0dbb89fa(0x608250042af19043d690d8f0e5b560a5a3c6211807099df50b0bc0a83b8d07aa); /* branch */ \nif (opCode == OP_ECPAIRING) {coverage_0x0dbb89fa(0xc621df914cac87f62f333e29ac1a75b406157994d2e2af45b8bdc4bf7fba6385); /* branch */ \n\r\ncoverage_0x0dbb89fa(0xdd0d119f69f078679b5ca02eae36102f5c8e1be858d45d29783a4d933220425e); /* line */ \n            coverage_0x0dbb89fa(0x1413c16f0b3e63e500cf8e26f5667c1f97e8e80535cb1e08d1c1607e099cd2ae); /* statement */ \nreturn (1, 0, 1000, executeECPairingInsn);\r\n        } else {coverage_0x0dbb89fa(0x56f8a36428cc5934bddabdcdca269d025512ec2276919c75de67e26713f2f135); /* branch */ \n\r\ncoverage_0x0dbb89fa(0x05e939631c8a94a9349ceba5d678888fec7b032a979002708eb8fa6c300bc884); /* line */ \n            coverage_0x0dbb89fa(0x90f9adc8e62deb8c7da404dba5b7c37dd39b9242682b3aedc8ee761ef5e093d5); /* statement */ \nreturn (0, 0, 0, executeErrorInsn);\r\n        }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/inbox/Messages.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../arch/Value.sol\";\r\nimport \"../arch/Marshaling.sol\";\r\nimport \"../libraries/BytesLib.sol\";\r\n\r\nlibrary Messages {\nfunction coverage_0x112a22e7(bytes32 c__0x112a22e7) public pure {}\n\r\n    using BytesLib for bytes;\r\n\r\n    function messageHash(\r\n        uint8 kind,\r\n        address sender,\r\n        uint256 blockNumber,\r\n        uint256 timestamp,\r\n        uint256 inboxSeqNum,\r\n        bytes32 messageDataHash\r\n    ) internal pure returns (bytes32) {coverage_0x112a22e7(0xb607609e01277c2faec014eb8c11d180f4e3d9d4fe2ee79c9cbf552b26081813); /* function */ \n\r\ncoverage_0x112a22e7(0x52b037405632ae0aef47f6a6ecc54e660149b49b784c86665ecd4bfbfa414b9d); /* line */ \n        coverage_0x112a22e7(0x6efb7bb4374e48615f32e88854c3bd17f73f634bdbe14e57db02a570b6011745); /* statement */ \nreturn\r\n            keccak256(\r\n                abi.encodePacked(kind, sender, blockNumber, timestamp, inboxSeqNum, messageDataHash)\r\n            );\r\n    }\r\n\r\n    function messageValue(\r\n        uint8 kind,\r\n        uint256 blockNumber,\r\n        uint256 timestamp,\r\n        address sender,\r\n        uint256 inboxSeqNum,\r\n        bytes memory messageData\r\n    ) internal pure returns (Value.Data memory) {coverage_0x112a22e7(0x9fb600c428fa8a0c0bc82776412431a70c11d76cd440af36e33b685dc1cf5c90); /* function */ \n\r\ncoverage_0x112a22e7(0xd3835091a09bd94edbeede6e0e3d2a254304dd2d62c77028072ab0ebc4cdfd75); /* line */ \n        coverage_0x112a22e7(0xafc79726164532298d69718c3491530dedbb9e4ecec492a7a41c88936a158314); /* statement */ \nValue.Data[] memory tupData = new Value.Data[](6);\r\ncoverage_0x112a22e7(0x0d011d3ee2851606c4ff8d97c411e910093955ac180b6acdba81aca2adfe8658); /* line */ \n        coverage_0x112a22e7(0x24f64a7c48e955e0da930355af525fd8d93840480a1d669ee3d635cc0ec47eaa); /* statement */ \ntupData[0] = Value.newInt(uint256(kind));\r\ncoverage_0x112a22e7(0xf43209c4d7e106d9a4fc2ae5a0aa207d13c47fb6f34abab793b7ba07786a897b); /* line */ \n        coverage_0x112a22e7(0xb06123880eff8a6b5672b44f21f2b97538947e98f8af39372b23b6680a1ba167); /* statement */ \ntupData[1] = Value.newInt(blockNumber);\r\ncoverage_0x112a22e7(0x9258ca6c00be54fdb3141388d26911422940d3b047141bcf9598182f6ad32e3f); /* line */ \n        coverage_0x112a22e7(0x8402a1f238a1022ad77e7876cef9164d6fa7f87e3ada1b2ccbbae445a51b3aa5); /* statement */ \ntupData[2] = Value.newInt(timestamp);\r\ncoverage_0x112a22e7(0xfa1fe75d17ca90c3dfeecfbb8ce4b9539331e46d3500609b51d9e208dc865a06); /* line */ \n        coverage_0x112a22e7(0x672a062c7d35299ab416d27fba4107dba6308eb530f5be976a5267074ed31cbf); /* statement */ \ntupData[3] = Value.newInt(uint256(sender));\r\ncoverage_0x112a22e7(0xe552c1b2ee96f6a9964ff04bfa844e2ecf399c7371007b1456d413054c1442b4); /* line */ \n        coverage_0x112a22e7(0xac2934997e942af3a82ad10f8b367ae88aa0a08955e634e093c8079562e03f17); /* statement */ \ntupData[4] = Value.newInt(inboxSeqNum);\r\ncoverage_0x112a22e7(0xa37f4d72dd51e8e90b9b61f089a9797231a2d3a77d2863525b505babe1cf2e1c); /* line */ \n        coverage_0x112a22e7(0x864f384719c58c296ca57467b1c4baa86761ef30d5781cae44c05879ad65531a); /* statement */ \ntupData[5] = Marshaling.bytesToBytestack(messageData, 0, messageData.length);\r\ncoverage_0x112a22e7(0x073c03061d7e1ec5a73e8d88a211109088b943125d5578f45b0a408b44d1b864); /* line */ \n        coverage_0x112a22e7(0x21a401a03778af30b785014c2e13f5c768b24b6247077c1871a04c6627189e32); /* statement */ \nreturn Value.newTuple(tupData);\r\n    }\r\n\r\n    function addMessageToInbox(bytes32 inbox, bytes32 message) internal pure returns (bytes32) {coverage_0x112a22e7(0x12a4114fe1d55e290387576d0c61f1347967cf6b90964e3b6af25ffa71a0f193); /* function */ \n\r\ncoverage_0x112a22e7(0x7dc3c96def723e1209634366082d3e4963144b6568758a1e769f7d1beb3cb84a); /* line */ \n        coverage_0x112a22e7(0x7cc7854ba171c33cf5b157681c1264684338ef56b6847fb6b149ddc37d153a84); /* statement */ \nreturn keccak256(abi.encodePacked(inbox, message));\r\n    }\r\n\r\n    struct OutgoingMessage {\r\n        uint8 kind;\r\n        address sender;\r\n        bytes data;\r\n    }\r\n\r\n    struct EthMessage {\r\n        address dest;\r\n        uint256 value;\r\n    }\r\n\r\n    struct ERC20Message {\r\n        address token;\r\n        address dest;\r\n        uint256 value;\r\n    }\r\n\r\n    struct ERC721Message {\r\n        address token;\r\n        address dest;\r\n        uint256 id;\r\n    }\r\n\r\n    uint256 private constant ETH_MESSAGE_LENGTH = 20 + 32;\r\n    uint256 private constant ERC20_MESSAGE_LENGTH = 20 + 20 + 32;\r\n    uint256 private constant ERC721_MESSAGE_LENGTH = 20 + 20 + 32;\r\n\r\n    function unmarshalOutgoingMessage(bytes memory data, uint256 startOffset)\r\n        internal\r\n        pure\r\n        returns (\r\n            bool valid,\r\n            uint256 offset,\r\n            OutgoingMessage memory message\r\n        )\r\n    {coverage_0x112a22e7(0x77c47c949cbb3c44d9574fbc12d549e6c86da5c41b0710f931225a1378a02155); /* function */ \n\r\ncoverage_0x112a22e7(0xd637b81d8d943fc610087ce80b165e5e1308ec9e5b2ec1d2a6353e9baa2f5952); /* line */ \n        coverage_0x112a22e7(0x1f066d60e1ddc882188264d215bb1fd6c637f1831d5d12f5f1bec249080f5dab); /* statement */ \noffset = startOffset;\r\ncoverage_0x112a22e7(0x99bfe6cfe978737b11ec21e223804f3482d7d641621786d6196f2ab99add9597); /* line */ \n        coverage_0x112a22e7(0xae98d114b7ecdfc5d6469dbd4e945813168d8792ead9c1ca91806fc1cfc60679); /* statement */ \nuint8 valType = uint8(data[offset]);\r\ncoverage_0x112a22e7(0x7ae6efd8fc2aa9dfc907ba97932b9d8a66f7818d8a68e3bc1c348d2c9496f747); /* line */ \n        offset++;\r\n\r\ncoverage_0x112a22e7(0x643bb8fd1b7a8c9e2ebfccc38c63c3b68f7b13e0491c7bcba18c84d27650f1a4); /* line */ \n        coverage_0x112a22e7(0xa010690752d2288f7497abe97d125f8e49a83bb6c0ab106604351c9c95934b63); /* statement */ \nif (valType != Value.tupleTypeCode() + 3) {coverage_0x112a22e7(0x6812f9f1c5c56e883605d61a624cac114d2d44afa1d6d1b4d036b13937a75b6d); /* branch */ \n\r\ncoverage_0x112a22e7(0x6374fcda839b9d48d68f673efcb5ecb6f3f7953de02cb1ff52abd3b2b0fb2ea6); /* line */ \n            coverage_0x112a22e7(0x4be39e2b78a9b5001a74d608022ecd8c7ab56447def79aa979cd5a4ddb03556d); /* statement */ \nreturn (false, startOffset, message);\r\n        }else { coverage_0x112a22e7(0x689e42564cc438624fce28e4eec749b67c2ddb49587f4de577856948821d588e); /* branch */ \n}\r\n\r\ncoverage_0x112a22e7(0x71536edd07cc27cdfd364f06d5dde322862fc08b806a89381b3fc7f6217f348d); /* line */ \n        coverage_0x112a22e7(0xccb693e7b3de5f9a2563572311407c1e640865e886d325f71580d5aaf147bae2); /* statement */ \nuint256 rawKind;\r\ncoverage_0x112a22e7(0x4b5e557a64669ed88ba888de4339133aea537d858b68cb265221427e8a36f63e); /* line */ \n        coverage_0x112a22e7(0x81ed17aed0ea8da10886cc30a8981889d5e63e3e633726b73ff1cd95a5ed5536); /* statement */ \n(valid, offset, rawKind) = Marshaling.deserializeCheckedInt(data, offset);\r\ncoverage_0x112a22e7(0xffa0fd141489053e7b115f8ca79332c9dae846a373fbdc5eea939975ef4a8b89); /* line */ \n        coverage_0x112a22e7(0x4f4ec06aae43855e3511d2fab83fa37fb3928eb33179f0c77a7bb356295fffcb); /* statement */ \nif (!valid) {coverage_0x112a22e7(0x1988a2ccb639fcc2377cc527740b7e2c753f66fb8471047f8f7c7a3615332cac); /* branch */ \n\r\ncoverage_0x112a22e7(0xb9c268920d62e674464223412f123205c88c40d1520051780433dc3f8e920053); /* line */ \n            coverage_0x112a22e7(0x10e8ef8f14172a5aae51f6c42a095664822b7e9eec474923aa28e3cd5de21ec4); /* statement */ \nreturn (false, startOffset, message);\r\n        }else { coverage_0x112a22e7(0xc70fe8a076c17f5f94c05479d42b3305c27a90d3354a0f2e27018765e1cdb743); /* branch */ \n}\r\ncoverage_0x112a22e7(0x3860c952aaeade8ab1aec9910b7a5d0f9f78978c4fa72a24c805248cfb692dd7); /* line */ \n        coverage_0x112a22e7(0xb69a14b90d14cefceca359bc1ef80eae3c06146d1c4ece0c0f35e5285dc0f061); /* statement */ \nmessage.kind = uint8(rawKind);\r\n\r\ncoverage_0x112a22e7(0x62abd32c1b22039813dc888eac20e3996162c44cbfc2a21b26c66aaa86df9a18); /* line */ \n        coverage_0x112a22e7(0xcfef1d0f475d70e79adab2ea094be314f30b78e079488d1c531f21ad5480a4d0); /* statement */ \nuint256 senderRaw;\r\ncoverage_0x112a22e7(0x52a6c21ebf1550da336583048c7c13c55850a137d4b57464ef4b829a032c0a3d); /* line */ \n        coverage_0x112a22e7(0x90eb2d782d8cbfeca324aa4bb38946b32e2a966dee2d6394050ac139adb802cb); /* statement */ \n(valid, offset, senderRaw) = Marshaling.deserializeCheckedInt(data, offset);\r\ncoverage_0x112a22e7(0x0ac9c288bce7eecc157267ea4e4db4c2509cd198975ca4a9d049f1d744dc1685); /* line */ \n        coverage_0x112a22e7(0x2b7ebd5562583159d38fbdb702830ec0507eff34ab30c81fb710523e9d6ea23c); /* statement */ \nif (!valid) {coverage_0x112a22e7(0x83f3a743f81adc67e8863844fed78d507201d8211548f8f0afc72cc4f641c717); /* branch */ \n\r\ncoverage_0x112a22e7(0xb74f156c3d2e315e64716c11be652ff54578b23e3d8ae89e27e3df18fbfb8919); /* line */ \n            coverage_0x112a22e7(0x70a732c2832a86ea6b9afaf38cf03455652547bffe41cf6c241866112c62ed95); /* statement */ \nreturn (false, startOffset, message);\r\n        }else { coverage_0x112a22e7(0x5c4e0568a469794407fdbfd7ced76389da3c19061d876b52e62ae1bba842f73d); /* branch */ \n}\r\n\r\ncoverage_0x112a22e7(0xb0863271e3248babcce39f09a12877fb258b60c657b299fdfeae42549ca0a2e5); /* line */ \n        coverage_0x112a22e7(0x42ce83a3b3adc33f6b9956e0a974af7c52d5d86783573d6adbd65b5697f3eb36); /* statement */ \nmessage.sender = address(uint160((senderRaw)));\r\ncoverage_0x112a22e7(0x7739f4c7eb3447db6ea91358b83f9d7770bf3a30452432ad0b2ca2e76d83d9fe); /* line */ \n        coverage_0x112a22e7(0x8948b870c85204d137a4640733adfc3ea8f7c43d413eaa57368ac9d4831378c5); /* statement */ \n(valid, offset, message.data) = Marshaling.bytestackToBytes(data, offset);\r\ncoverage_0x112a22e7(0x33970472b2305531b1da5cf74603e24b2a367ad7b37afb207034b375a1e33743); /* line */ \n        coverage_0x112a22e7(0x6196620eb2560ff9188d3bd020220156e308649608dd2d9e75e46d8cb01a3717); /* statement */ \nif (!valid) {coverage_0x112a22e7(0x9fc65918ff2050024bb7ec3e577c0348cdcd0607da3ba0b73caa42c7bf606ff0); /* branch */ \n\r\ncoverage_0x112a22e7(0x3a514220cd4fc9b21b50bf3cd461a9bd3df863f5e89867eea0286abf367be7af); /* line */ \n            coverage_0x112a22e7(0x5825395947a13b8c8e42d6a0edd2ecde277a985af5992469979b3c01db10243d); /* statement */ \nreturn (false, startOffset, message);\r\n        }else { coverage_0x112a22e7(0x7ab057674cd84ce57cb9fdcdea0100c097a10ca6b49f75f1f56c40e306908c5e); /* branch */ \n}\r\n\r\ncoverage_0x112a22e7(0xdd46f6c9aafba59cc504755844ee9fcd17d96434d013156b0dcb82f0b3e481f4); /* line */ \n        coverage_0x112a22e7(0x6c2b2a37ac185b5144c43cf65fcd7f90bcc4f485993b6675e18bb123071b87fe); /* statement */ \nreturn (true, offset, message);\r\n    }\r\n\r\n    function parseEthMessage(bytes memory data)\r\n        internal\r\n        pure\r\n        returns (bool valid, Messages.EthMessage memory message)\r\n    {coverage_0x112a22e7(0x411316f90f3ab92c587ef2f6653c12f13c700469278dcc816c830b012408fa5e); /* function */ \n\r\ncoverage_0x112a22e7(0x3ec00ff9c1bb28cfbd551d32165e45376dd6df0bf1a790f44362bc73f91b16c2); /* line */ \n        coverage_0x112a22e7(0x3d714214b1cd315d2f343a7e82d31aa27f10895267890bd6273593d7a986ba4d); /* statement */ \nif (data.length < ETH_MESSAGE_LENGTH) {coverage_0x112a22e7(0x33875b472330cdb23d02dc78998be926423482b57cf4a03a087296e85a3a8689); /* branch */ \n\r\ncoverage_0x112a22e7(0x8622cec6ef2fc4c97f438e2104e2350015b57ee0ae59c3661a39331476ec2c09); /* line */ \n            coverage_0x112a22e7(0xcbe4da50892bd37cd1437db683dad6c770932632a4e90f497b442e5a53e2a742); /* statement */ \nreturn (false, message);\r\n        }else { coverage_0x112a22e7(0x490720cc76cc863e9b1caf59c4877e2c9a79fa27f0aba47363bfeaef93392fb3); /* branch */ \n}\r\ncoverage_0x112a22e7(0x4353c61071178e8e4fbb08de922c3ec92c745f7788da5120afc2102d5dbfb3a7); /* line */ \n        coverage_0x112a22e7(0xfe64833d4d21188a47e7658e0a73ee42670bc7dff2df6a6ba6904ee38c36d31d); /* statement */ \nuint256 offset = 0;\r\ncoverage_0x112a22e7(0x54d9f5303ede64b8fe1e05d61a3052c2095f6ca2ee7bdcddb3c8a015f870484d); /* line */ \n        coverage_0x112a22e7(0x10f52cf4ea9d2346fae0de95852d325d2f4d5d605940c5a369555d271e4c6bbb); /* statement */ \noffset += 12;\r\ncoverage_0x112a22e7(0xc09efe084c4624fd2fbf1ef08b9bd1246d9f7eba456f683604aa4e6bc1b7038a); /* line */ \n        coverage_0x112a22e7(0x77e6ff07b54310fe10e1fcee96aee76975fe71b7b139ac3d3555ce0c46bc11e5); /* statement */ \nmessage.dest = data.toAddress(offset);\r\ncoverage_0x112a22e7(0x2c5c5699d1e57472aa7b0470550f3d40ad664e396d7972d2c4a9891f37efe886); /* line */ \n        coverage_0x112a22e7(0x8b9bce5900c8bbc054ab011a75081515dd334206325fe68ccd9bcc95c00dad40); /* statement */ \noffset += 20;\r\ncoverage_0x112a22e7(0x65fa193be8b5ba5157834aab9c9346113f787ed3acd35c6b65584cba20eb35ab); /* line */ \n        coverage_0x112a22e7(0x987802c98db6776799b9a9b02f6adf53ce284d8baeaa64380fd80c1a46b4ed95); /* statement */ \nmessage.value = data.toUint(offset);\r\ncoverage_0x112a22e7(0xa6bc9d97a104c47788786b600177d6f55bf0b0532d691600a2a4fa66191450d3); /* line */ \n        coverage_0x112a22e7(0x6d7f5e27933cc0b39a58796853ebf325a5565f01d2c3c24be814c71c9634fe91); /* statement */ \nreturn (true, message);\r\n    }\r\n\r\n    function parseERC20Message(bytes memory data)\r\n        internal\r\n        pure\r\n        returns (bool valid, Messages.ERC20Message memory message)\r\n    {coverage_0x112a22e7(0x6cdb25e316195ae6b42ed7e1b9a98a70fe7f28b74ecfc47bba6cb981bfd844f4); /* function */ \n\r\ncoverage_0x112a22e7(0xc7bf714f1febd0c6414d60839260b04637080ecf4150844e3cd9c5767a29a746); /* line */ \n        coverage_0x112a22e7(0x49053fba94949e7f7b590db6756adf859231dc81f7b289a2f2f2b636e99f7042); /* statement */ \nif (data.length < ERC20_MESSAGE_LENGTH) {coverage_0x112a22e7(0xd86b128a42aad0357b34ce98c8f473ef2aba220f465c7e85f23b44722a5cb1dc); /* branch */ \n\r\ncoverage_0x112a22e7(0x3bde016ad86c8366d00645d8070d556ecbd8af2ae27b2091d60d2ae861f80bd6); /* line */ \n            coverage_0x112a22e7(0x80220a351dd2b7dc814591c94c069d062fec435afd5d986e9db37c4246928890); /* statement */ \nreturn (false, message);\r\n        }else { coverage_0x112a22e7(0x750662111bff6700ef7bb723824d4301a1b6619ff04db2f51fdeb242472ffc45); /* branch */ \n}\r\ncoverage_0x112a22e7(0x7828c41f4a7b1da45254322baf98cafc519afd3cf570e3871127aa45df96f579); /* line */ \n        coverage_0x112a22e7(0xbcf5da5b050e5a8b936a30e3475c7728826aeed86d32fae01a0b60ccbcbe8135); /* statement */ \nuint256 offset = 0;\r\ncoverage_0x112a22e7(0x0bf6d2e9077ee229122c9df9f26b4d33c1aa184ee1a925fb7174f672dc0fd4e1); /* line */ \n        coverage_0x112a22e7(0x964f66abfe0ba9986b313b70b79bb004360a26a21a16204dee79292215d6beed); /* statement */ \noffset += 12;\r\ncoverage_0x112a22e7(0xdf8e3bfe6552a67ac665df52ec1c8d088941b0da30d7449cfa32aab0f2b4722c); /* line */ \n        coverage_0x112a22e7(0x39bf070c2a1ed1743fdccd0677cb1e0611013d8c13794773459f697e78933a85); /* statement */ \nmessage.token = data.toAddress(offset);\r\ncoverage_0x112a22e7(0xc4ef220e24a6af77f9a99ef14057c4ec83d965130bc80045e177d6b967997661); /* line */ \n        coverage_0x112a22e7(0xf5764abe2e34ddec154db63994e0d71f2465d35e4b0a036c15368f178bd97222); /* statement */ \noffset += 20;\r\ncoverage_0x112a22e7(0xf7f1a76e814cab9c3d9f18a4c4533e0c99658a5737d4d9c9937d4ef182d10b4e); /* line */ \n        coverage_0x112a22e7(0xe54aac95467be16794546ce845a8caf6ed2b06d4d309836b78924c6c3588d170); /* statement */ \noffset += 12;\r\ncoverage_0x112a22e7(0xd6080a995461dcc8862dcc4dec0a69cbcdc84fecf513e5fb101e6835ecbcc6f0); /* line */ \n        coverage_0x112a22e7(0xb07a130898f23090d58d60dae6b6473efbdc9d41c24dbd258232d162375b1d3f); /* statement */ \nmessage.dest = data.toAddress(offset);\r\ncoverage_0x112a22e7(0x3e65845acbf23d028e06753d735f8b7c7929244d5334e44e0a33d929df8ff8bd); /* line */ \n        coverage_0x112a22e7(0x9271f86c9c0615c7a993152917fcba2587322b943c8af877a2beb43c0e1930cb); /* statement */ \noffset += 20;\r\ncoverage_0x112a22e7(0x5631d36c5a7c4c6a996c93cd2c9bc60e5b4a7310580dbe2a4b02462418c683c0); /* line */ \n        coverage_0x112a22e7(0x014463f048755014d2db8a89dc939f3432ad17aa08fdd1d5c6ab3c02c5f963b7); /* statement */ \nmessage.value = data.toUint(offset);\r\ncoverage_0x112a22e7(0x8983e908f2c3cbda44cc5522c9f0de7057508c2dae56bb04a599f8d2e20bd6b3); /* line */ \n        coverage_0x112a22e7(0x037de4cd48bcfabe99a9580e65bfb90325f2e23353f21ce8ab17b99df5a4a81d); /* statement */ \nreturn (true, message);\r\n    }\r\n\r\n    function parseERC721Message(bytes memory data)\r\n        internal\r\n        pure\r\n        returns (bool valid, Messages.ERC721Message memory message)\r\n    {coverage_0x112a22e7(0x7c8b16c1bdf02f3e36f8d81be7685c664e50d251a8fde5571a86dcc6443d6181); /* function */ \n\r\ncoverage_0x112a22e7(0xa3c978ba918f652d4f0fc0ee7db5d9bc7ee2a61e98835f46e15e556a4bfe348a); /* line */ \n        coverage_0x112a22e7(0xf75492cd7333b68369c134778a8e2e35ca3d912befa3c3628a53cf9e9143d54d); /* statement */ \nif (data.length < ERC721_MESSAGE_LENGTH) {coverage_0x112a22e7(0xac5e8583679dcd951f054dbd04f564d57e13755b4d545b3cd0dcc92ad1b50158); /* branch */ \n\r\ncoverage_0x112a22e7(0x83523bc94b503cf74a94465fb8d812f05510b3396b1b9f2285aaa85018a97b22); /* line */ \n            coverage_0x112a22e7(0xe01b45a5f9cae01e9cae6813ff6bd87ed933deac06b743ce6f99962d515af252); /* statement */ \nreturn (false, message);\r\n        }else { coverage_0x112a22e7(0x0fe8a7d8b86d22bee992f7f55c1832bdcdf93ffa090189331ebfd21dba3b8466); /* branch */ \n}\r\ncoverage_0x112a22e7(0x96543088e25ea94130bdafec6a64feca07ae52e28aef98df19562fc4c68ae803); /* line */ \n        coverage_0x112a22e7(0x8b6aed299a243490a53ce837803ee4f3424e49ff91ba084e8a3e10b0f85b8856); /* statement */ \nuint256 offset = 0;\r\ncoverage_0x112a22e7(0x78fba2dbaf3e56b9916ebfcb7e30c0d15ea296fbddabb7a1734549173e76b33b); /* line */ \n        coverage_0x112a22e7(0x1bd470d9fb20cac20010d7c12b1e2d4c2a15a2df8bbfcf8724ca16e10726430b); /* statement */ \noffset += 12;\r\ncoverage_0x112a22e7(0xd2b46cb2c0379554266a9b4752cfda2f3d95fbf6d4e455bc2456795b482d0759); /* line */ \n        coverage_0x112a22e7(0xe852985869ad66042173ee37a5cbf39af4c3e6ad27d2b0581108956750b2138e); /* statement */ \nmessage.token = data.toAddress(offset);\r\ncoverage_0x112a22e7(0xc2ea733e8914b5e7602854b6bc80401755000dbcfd5d2aebd3c8a4534ca0215b); /* line */ \n        coverage_0x112a22e7(0x8d335d7cb50d172d518f0baf040be9801da93851e08a5029c9050292ae244713); /* statement */ \noffset += 20;\r\ncoverage_0x112a22e7(0x4e9a61126df732184baa24485bb42006996b404d1aa3af3c89a6810d0bfea7b7); /* line */ \n        coverage_0x112a22e7(0x572e5a4eaf3167fdb9c27cb30270fd9cffc00f3759a31f44d0fcf3a480c5fe3b); /* statement */ \noffset += 12;\r\ncoverage_0x112a22e7(0xd08f94e0e7d3af355e8b3ba5a25aded4a2527260f23cbc625a219997f3ab0318); /* line */ \n        coverage_0x112a22e7(0x8ff824c96092ec71321af553f2caf346712cbc07b1f47e39c65a7362ca5eb531); /* statement */ \nmessage.dest = data.toAddress(offset);\r\ncoverage_0x112a22e7(0x182aa1afdfeb226821d59f91f7b9679efa2dce75db5dd7570510696b3e9e7a9a); /* line */ \n        coverage_0x112a22e7(0x415053379961642ab8250381bb79b8df1657c262bc4db82625722a41ad75abf9); /* statement */ \noffset += 20;\r\ncoverage_0x112a22e7(0x8ec352ba8ed14f1391b101c7afeb3a7763351bc8972611fc292c835cf34ada4c); /* line */ \n        coverage_0x112a22e7(0x8e7a5a92797bb1d0476cf079e9c4a13af803f7c1a72ea107faf411bf489ff276); /* statement */ \nmessage.id = data.toUint(offset);\r\ncoverage_0x112a22e7(0x7e77d7695ff3d34412911767c7d23a9103152c54a9c538de798dd0389e6c82d6); /* line */ \n        coverage_0x112a22e7(0xe6f0a8a89401818fb3684cce56711e6a83b9f7afe3223f580dd2a04bd99e76d6); /* statement */ \nreturn (true, message);\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/libraries/Precompiles.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\n///      This algorithm has been extracted from the implementation of smart pool (https://github.com/smartpool)\r\nlibrary Precompiles {\nfunction coverage_0xb85a875a(bytes32 c__0xb85a875a) public pure {}\n\r\n    function keccakF(uint256[25] memory a) internal pure returns (uint256[25] memory) {coverage_0xb85a875a(0x7ba4e3d3a5b64e8fdb894275bff135c8aee2575dc0fadad3f4831a7286edd9b0); /* function */ \n\r\ncoverage_0xb85a875a(0xde6f876c0184b1e4a21f9006f16e2e58d8c2ac6816c2c480b99f0f6679177fc4); /* line */ \n        coverage_0xb85a875a(0xbd71636885456394cfaa758e669a77d952a1515855361bdd3c124f2e3c23e115); /* statement */ \nuint256[5] memory c;\r\ncoverage_0xb85a875a(0x1b43bcfd15e03d626faae016e06f55c840c52b8f3aab509d80dbc94e69572160); /* line */ \n        coverage_0xb85a875a(0xc9933223242d9c86f76fe08125d1a6fd3ab53c7d3ec9e04b02ed40ff83a704c6); /* statement */ \nuint256[5] memory d;\r\n        //uint D_0; uint D_1; uint D_2; uint D_3; uint D_4;\r\ncoverage_0xb85a875a(0x0f740e2cc4c33554ac69266d4e276acc296ee1b475ea226b9147cca757b25e82); /* line */ \n        coverage_0xb85a875a(0x93c5563a69dcf9908720a9123011b9b0d3a2a74ddc958adcdc84b99e7db04a05); /* statement */ \nuint256[25] memory b;\r\n\r\ncoverage_0xb85a875a(0xca9a57825e9a00ee9a5496b27eae603121d6a72a17240520e5d93bd1ea8e4dde); /* line */ \n        coverage_0xb85a875a(0x4adfc9180d7c7a1b292af3165136838784ec0209db2764b75c221ca31c46a0aa); /* statement */ \nuint256[24] memory rc = [\r\n            uint256(0x0000000000000001),\r\n            0x0000000000008082,\r\n            0x800000000000808A,\r\n            0x8000000080008000,\r\n            0x000000000000808B,\r\n            0x0000000080000001,\r\n            0x8000000080008081,\r\n            0x8000000000008009,\r\n            0x000000000000008A,\r\n            0x0000000000000088,\r\n            0x0000000080008009,\r\n            0x000000008000000A,\r\n            0x000000008000808B,\r\n            0x800000000000008B,\r\n            0x8000000000008089,\r\n            0x8000000000008003,\r\n            0x8000000000008002,\r\n            0x8000000000000080,\r\n            0x000000000000800A,\r\n            0x800000008000000A,\r\n            0x8000000080008081,\r\n            0x8000000000008080,\r\n            0x0000000080000001,\r\n            0x8000000080008008\r\n        ];\r\n\r\ncoverage_0xb85a875a(0xc79351e1a482f31a5f77104e9dd9cbc25e4ed8b098a1a82b8ef10a9fbc1b609f); /* line */ \n        coverage_0xb85a875a(0x2a69fee9adbec1978ac7a46ac4ebc6b3f413e95fcb8d186283c08b8642838775); /* statement */ \nfor (uint256 i = 0; i < 24; i++) {\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                C[x] = A[5*x]^A[5*x+1]^A[5*x+2]^A[5*x+3]^A[5*x+4];\r\n            }*/\r\n\r\ncoverage_0xb85a875a(0xafcb1527de0fbf036f0aefa786de179e8972e08f8afacf3004816fb995088305); /* line */ \n            coverage_0xb85a875a(0xb9b87ec3431ccdbce8dab3f30183686dd1cd69e4bef7b5e5a273ae0e2008ac5e); /* statement */ \nc[0] = a[0] ^ a[1] ^ a[2] ^ a[3] ^ a[4];\r\ncoverage_0xb85a875a(0x13d82418923303394f2573cd363f3255060180139fcfb6e3de2f9d48a38c8e0d); /* line */ \n            coverage_0xb85a875a(0xca747fcfa8983f48bfcf5c03cf09155aa923096e310e0a6e164a77f15a54d2aa); /* statement */ \nc[1] = a[5] ^ a[6] ^ a[7] ^ a[8] ^ a[9];\r\ncoverage_0xb85a875a(0x72100de1625018a8a7c32134edd0a52e8f38b524bce4e0b016725d45fe7f0037); /* line */ \n            coverage_0xb85a875a(0xae26920d0a87e451938172591afc3177950c5bd414669002dd8d6122a435213f); /* statement */ \nc[2] = a[10] ^ a[11] ^ a[12] ^ a[13] ^ a[14];\r\ncoverage_0xb85a875a(0x55ad76a3c52ebd9aba5670f9a1bd8c436d176a5270c413c3f20b4ebbeb3ad0d8); /* line */ \n            coverage_0xb85a875a(0xfc75074f07550457a3bbafa61b551a92b639b2ccf19a1bf594942eb279c52c9a); /* statement */ \nc[3] = a[15] ^ a[16] ^ a[17] ^ a[18] ^ a[19];\r\ncoverage_0xb85a875a(0xd2877bcf0c1ae38efbe06a385803de7ce0d9a24cb85f130a13f89ff48a65beef); /* line */ \n            coverage_0xb85a875a(0x393bf2603422df524a2694ddcce53ba6b34db6924d3a167ccfc71e2ba03cbb37); /* statement */ \nc[4] = a[20] ^ a[21] ^ a[22] ^ a[23] ^ a[24];\r\n\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                D[x] = C[(x+4)%5]^((C[(x+1)%5] * 2)&0xffffffffffffffff | (C[(x+1)%5]/(2**63)));\r\n            }*/\r\n\r\ncoverage_0xb85a875a(0x0cdd9dc78cd012c119babbb88dfa6261e685c13c76e1febe1c08cb52c875eabb); /* line */ \n            coverage_0xb85a875a(0xd7ca4feb7b73ea71704e2c4301c1e1eee30e21a919aff609c774f1ec5e9ffafd); /* statement */ \nd[0] = c[4] ^ (((c[1] * 2) & 0xffffffffffffffff) | (c[1] / (2**63)));\r\ncoverage_0xb85a875a(0x6261bdb19a9c36e2a292e8c29e916a4df83fce3c20514c105576d0f9899bb96c); /* line */ \n            coverage_0xb85a875a(0xf3c8016adfcbb6bf94e70fb1d41bf00a29c0d032ebb8bac9d13a5102bd609551); /* statement */ \nd[1] = c[0] ^ (((c[2] * 2) & 0xffffffffffffffff) | (c[2] / (2**63)));\r\ncoverage_0xb85a875a(0x78b11b93a357d80623c45a85d071668e73232c3950a8b87299a2c69488fb0afb); /* line */ \n            coverage_0xb85a875a(0xb6e109b02e5075730607dd8dedecb26f7d13ac0b24c6c8ea0abe819fedef4026); /* statement */ \nd[2] = c[1] ^ (((c[3] * 2) & 0xffffffffffffffff) | (c[3] / (2**63)));\r\ncoverage_0xb85a875a(0x4b3004ed94900fc2078b3d4a1f4b99a95e7a5b112c03a2accb53b0fdadf6cc75); /* line */ \n            coverage_0xb85a875a(0x63a527559bd87a4a23046e5fd2f258eb26e692e8a64bdd945de9174b0ab8d83a); /* statement */ \nd[3] = c[2] ^ (((c[4] * 2) & 0xffffffffffffffff) | (c[4] / (2**63)));\r\ncoverage_0xb85a875a(0x7ce11002fadff3c923299a538dc1c4d66f73651889dd6c033e1d92bf862df121); /* line */ \n            coverage_0xb85a875a(0x32179ac40f1c1b302e879e9b519a5aad56060b099f3828efe5a1a45e7ecb89aa); /* statement */ \nd[4] = c[3] ^ (((c[0] * 2) & 0xffffffffffffffff) | (c[0] / (2**63)));\r\n\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                for( y = 0 ; y < 5 ; y++ ) {\r\n                    A[5*x+y] = A[5*x+y] ^ D[x];\r\n                }\r\n            }*/\r\n\r\ncoverage_0xb85a875a(0x8cae53e2d23de34cc07e4cba3ee746442b8b1274c8433dcd53b56d5eedaa08f1); /* line */ \n            coverage_0xb85a875a(0x621a76b180108154afd51841b013b771a07fdf033d50d71e74ba679970179b09); /* statement */ \na[0] = a[0] ^ d[0];\r\ncoverage_0xb85a875a(0xba742dc48882e9072aaa92bb6d18dbef4f7d42c10f16e2208ffd8ec86e697f14); /* line */ \n            coverage_0xb85a875a(0x91f06719326b0486d23ccf8e729304c1e0730484a68f7959b7e29b453ad838cb); /* statement */ \na[1] = a[1] ^ d[0];\r\ncoverage_0xb85a875a(0xfb1b84b66db316f9a828d88a319b80d3de6c2a5dbacc81813d95d729b725467f); /* line */ \n            coverage_0xb85a875a(0xd198cf11c7d26e8cdcec293309573926ee0101a69c006a4ae06de679f07e10aa); /* statement */ \na[2] = a[2] ^ d[0];\r\ncoverage_0xb85a875a(0xab65ccb46e71c48e76ca48dba3cea84214c36c20377b4ed3317d0c4ba47f40bf); /* line */ \n            coverage_0xb85a875a(0x299bd7eb1e668fbec830933352a8ac36f563de033989d6bbf9d96686ede9df3f); /* statement */ \na[3] = a[3] ^ d[0];\r\ncoverage_0xb85a875a(0x8d23b1aa59e7f76a5c3f84f1505dfd95282586940c98db1a8cbb26db9f8d47d6); /* line */ \n            coverage_0xb85a875a(0x472cbee431cd8c69dd8c350ddae077e03bd25b32ccce920082fc0afc115160f0); /* statement */ \na[4] = a[4] ^ d[0];\r\ncoverage_0xb85a875a(0xe87a2f266c8762798d12bc4db142a9e2f353713d9f7c6156bb81f155b376b685); /* line */ \n            coverage_0xb85a875a(0x2447455e3e27ceafb20d9d2a978507cac877a447a804609b3716c52c42e4b214); /* statement */ \na[5] = a[5] ^ d[1];\r\ncoverage_0xb85a875a(0x4604605449baba651dea3efa91b01e3a2c345ce1b1f4cd7c0df59c1ac200fea4); /* line */ \n            coverage_0xb85a875a(0xf58220c9e35c470028683292b78eab8dfdf982388922433f9a9962ed43d9e3d9); /* statement */ \na[6] = a[6] ^ d[1];\r\ncoverage_0xb85a875a(0x92c20d6d4595011cc1d8f89150841f3c70eaaf643dc41beae8426f9fe35b2719); /* line */ \n            coverage_0xb85a875a(0x1cc7720f94afed78aface87625469922066857ea13300d7db429163c5afd8c0a); /* statement */ \na[7] = a[7] ^ d[1];\r\ncoverage_0xb85a875a(0x8ac34741d8188d83162b4288164d9211cab7cd9435a8cd7241de0bcf8944d7e0); /* line */ \n            coverage_0xb85a875a(0x07f9e18d6f8878c2f58045996dbbd4953b7b7e083eb55c85e5e42ecbd8ddc174); /* statement */ \na[8] = a[8] ^ d[1];\r\ncoverage_0xb85a875a(0x336ce1beb54641c5ec1751986869eef1488b6e586e30a5d936221f961a0b1330); /* line */ \n            coverage_0xb85a875a(0xecdadd44ae5899073a2a93a1137844ff1a0535aaca5d67e0e85c2b8265721a0f); /* statement */ \na[9] = a[9] ^ d[1];\r\ncoverage_0xb85a875a(0x796753d41b399e954477de9128f9974803e5580e8c0c7fac4467007d6719a94b); /* line */ \n            coverage_0xb85a875a(0xb7692926826fc93216e56ef794c8ee5fcb346841184d93a2d6d34c7f3bfe2686); /* statement */ \na[10] = a[10] ^ d[2];\r\ncoverage_0xb85a875a(0x55594b1e15c4ee2b8780e01d1179d65a861fc639ef88e94daf8c0d304256d3dc); /* line */ \n            coverage_0xb85a875a(0xb8eb423b0d19f2cc63ad1fe7699cfa082f909080f563dff9be7c04072df83624); /* statement */ \na[11] = a[11] ^ d[2];\r\ncoverage_0xb85a875a(0xbf8535e43e8b00e0c67d651cb370196eb830aad8aa65b17e5c300c5eff45c7a4); /* line */ \n            coverage_0xb85a875a(0x98ceb35cd40b1d50320ed6a27fd2c50c5356e82a0b2e0e3853a76063e7ab500c); /* statement */ \na[12] = a[12] ^ d[2];\r\ncoverage_0xb85a875a(0x6b1bb572d9f0f5360292352ec34009f3829a5397a85425f180a6caaf3cb6e511); /* line */ \n            coverage_0xb85a875a(0xf2597fc744d811066baf82ea6ca62c118a7052fd73b6ec5f1a57b41c20566cc4); /* statement */ \na[13] = a[13] ^ d[2];\r\ncoverage_0xb85a875a(0x64219d9a529433f0af2dbe1e25f6742a3820d6716930a793b62be115eaec3282); /* line */ \n            coverage_0xb85a875a(0x160e5dc257cf4f9e551aee1f33c4e88d76b6b42497547f9ed075e340871746d1); /* statement */ \na[14] = a[14] ^ d[2];\r\ncoverage_0xb85a875a(0x82fec34b5a033b0b0954b1e5d024dcab6785b5c1e82c831fafdbba7301a0084d); /* line */ \n            coverage_0xb85a875a(0x1bf9ba63e51d2a57ec1644bfb22d8935e0708cd118a9f33e5a0b0108d6d230cf); /* statement */ \na[15] = a[15] ^ d[3];\r\ncoverage_0xb85a875a(0x182fc68e0360e26701aa24cdc634ac9f51722093b7c4d722ae1d4dd78c397361); /* line */ \n            coverage_0xb85a875a(0xa746f6ab2a432ea61ca532c4d84145ed9558383e597fa67ca68849ef640cf6d3); /* statement */ \na[16] = a[16] ^ d[3];\r\ncoverage_0xb85a875a(0xc2cfcf4dae4e124d5658185f903f878bbe93117136574aed099308a00e03490b); /* line */ \n            coverage_0xb85a875a(0x50e77a116101e600897e125d7aca490a0c0121ba31b017f6661d4c96f9a227f2); /* statement */ \na[17] = a[17] ^ d[3];\r\ncoverage_0xb85a875a(0xc68cb7360fd0f991f4fc267b55c2094899253a4179c202965bd2b4e2a1cee95a); /* line */ \n            coverage_0xb85a875a(0xc94f29d0917b1c3c8e2a4ba02f9f6f427617bc9a099c6fba74196279dba4b16c); /* statement */ \na[18] = a[18] ^ d[3];\r\ncoverage_0xb85a875a(0x89d731617671de53b5e0574474fc30025da354d1ff21f4b8e9f32f272261eefc); /* line */ \n            coverage_0xb85a875a(0x9ceaff47fd8b4deb4fc0cb259e0ec39b9a3dda180c933b4cc426dba3d6429419); /* statement */ \na[19] = a[19] ^ d[3];\r\ncoverage_0xb85a875a(0xeca8f61e22fa76161c8f1efca8071d71cdb5d98c505951ccf835604ea4f6c588); /* line */ \n            coverage_0xb85a875a(0xe6c27f0ed2e14c57d8a3f397e475f4a94b197a490ee0d419174a0a4adbe2af8b); /* statement */ \na[20] = a[20] ^ d[4];\r\ncoverage_0xb85a875a(0xfff748260f75d8c760f2db83013a69d7bc423617ee1b4bd543917664ec22b9a8); /* line */ \n            coverage_0xb85a875a(0x7aebfa18e23f45c523f2b06ad30e3879f136914b22d97b1c81347d3fd359e0df); /* statement */ \na[21] = a[21] ^ d[4];\r\ncoverage_0xb85a875a(0x9dfa448579fa2e5ac307c78fa41fc98a9e65a7951132f4edaeb1fb3ef7aac98d); /* line */ \n            coverage_0xb85a875a(0xd6c5ec83a24b9c13ec5a0a7208daf8e4a8f1a2804dbd7d99e1e28e9ac29ebe60); /* statement */ \na[22] = a[22] ^ d[4];\r\ncoverage_0xb85a875a(0xb92f46b98bfce970182c2174d370acdcd1c006c8037b41d42f2538659ba8b3dc); /* line */ \n            coverage_0xb85a875a(0xff6609165117cba52fa24f01edc3098b425acc5aba7d9d13bb6644b0f405a774); /* statement */ \na[23] = a[23] ^ d[4];\r\ncoverage_0xb85a875a(0x94e96c454d2b7d6017fcfb29fb40f0233baa6eec288ec8b53bad351ba628be57); /* line */ \n            coverage_0xb85a875a(0x4f4e193c337b2ec25562183d665a77023870c73aec9034850e58d9453e38cc9d); /* statement */ \na[24] = a[24] ^ d[4];\r\n\r\n            /*Rho and pi steps*/\r\ncoverage_0xb85a875a(0x75a01e5085411d73f784af3ccffc06b6cb3950a5cd49cc4ac91792f3d6a9095f); /* line */ \n            coverage_0xb85a875a(0x7e041c87e7100761715fec40df57c9077213ef046f570525b4186e01a8b39430); /* statement */ \nb[0] = a[0];\r\ncoverage_0xb85a875a(0x2323cb9097c002704627c5f923302fac777e9f61b65d6a79601a80b7ebfd66aa); /* line */ \n            coverage_0xb85a875a(0xac2e80fb17d2445b99007b140d6ef1d87d22cdc71a23a397af41bb19ce0610a9); /* statement */ \nb[8] = (((a[1] * (2**36)) & 0xffffffffffffffff) | (a[1] / (2**28)));\r\ncoverage_0xb85a875a(0x51a948e6ea0d53bab9c04f3559ef4f245c4b4fa64cda3a8776a1a471af7c8e39); /* line */ \n            coverage_0xb85a875a(0x36c5dbe9062a759e838602b7ded678c162c2b46931e8eb2a6b4c597cc9b0c2ab); /* statement */ \nb[11] = (((a[2] * (2**3)) & 0xffffffffffffffff) | (a[2] / (2**61)));\r\ncoverage_0xb85a875a(0xdbdd42413573edc774c8e12020f24b710c6db0055a0e70fe769b51ba811f5d63); /* line */ \n            coverage_0xb85a875a(0x907f7ef7b53a191813dd691c8e53817c7650f538a5bbf1b373ce8ef302597862); /* statement */ \nb[19] = (((a[3] * (2**41)) & 0xffffffffffffffff) | (a[3] / (2**23)));\r\ncoverage_0xb85a875a(0x87b289c51e5ad6d0e5858fe65b676c579567de1d716269aa8b46029ed5ad4a50); /* line */ \n            coverage_0xb85a875a(0xf0f73ed2f5f014c98d52cb329119c4f9a09b0f7d648bba17621fae7bf73554b0); /* statement */ \nb[22] = (((a[4] * (2**18)) & 0xffffffffffffffff) | (a[4] / (2**46)));\r\ncoverage_0xb85a875a(0x1a8ae037ecf862c43709187ce3f47a96d8b88fb55fc8d3cdeaaaeaaba2e818e3); /* line */ \n            coverage_0xb85a875a(0x2028144ab05b24adddc189c3b53f06035c2aabf8cbed8621953ad57746c4173e); /* statement */ \nb[2] = (((a[5] * (2**1)) & 0xffffffffffffffff) | (a[5] / (2**63)));\r\ncoverage_0xb85a875a(0xbefe945a3bf03e13c5d6b52916726baa2af078d21fc95039d5b987c5da432ba1); /* line */ \n            coverage_0xb85a875a(0x0b415dbccf1f73e5a6b6b7adf8192551b263e1c567bd59b769dd1d196542ce40); /* statement */ \nb[5] = (((a[6] * (2**44)) & 0xffffffffffffffff) | (a[6] / (2**20)));\r\ncoverage_0xb85a875a(0x781055bae44b6bcaa2690770e46c288981b2ad47e6c33188a7b9f5c18a13301f); /* line */ \n            coverage_0xb85a875a(0x3d0f63de069817816d38c64bafae985532cf9767f2565892443675c7df7320d1); /* statement */ \nb[13] = (((a[7] * (2**10)) & 0xffffffffffffffff) | (a[7] / (2**54)));\r\ncoverage_0xb85a875a(0xe60e3ba50f73e8d0c028c85a8d987f6c5e2fa04b881814f552a1e71035543dba); /* line */ \n            coverage_0xb85a875a(0xc5537b55890f327851d617b8b5b79f7597f21d7b070b89024c01aab150f8b7ce); /* statement */ \nb[16] = (((a[8] * (2**45)) & 0xffffffffffffffff) | (a[8] / (2**19)));\r\ncoverage_0xb85a875a(0x999334385100b4af0b7b02d0c75a6a9e0923f4916f214d152457328b63c377cd); /* line */ \n            coverage_0xb85a875a(0xc34ee20937bafed7c52353bae30eb7e72cd9b8ef873ffa5f243a6197317e5257); /* statement */ \nb[24] = (((a[9] * (2**2)) & 0xffffffffffffffff) | (a[9] / (2**62)));\r\ncoverage_0xb85a875a(0x1950ab47ee2acbab225d9abaff3deb893380318f757ccacfdb528c26af222298); /* line */ \n            coverage_0xb85a875a(0xd80a3fbfdebfe16fdef25029103164158be2b730d1eb11b6279903183424ce26); /* statement */ \nb[4] = (((a[10] * (2**62)) & 0xffffffffffffffff) | (a[10] / (2**2)));\r\ncoverage_0xb85a875a(0x7b75ad09da90dfea7f4fa97a6c4ea5c642b76c7b8a589e6775798a4fe58036fd); /* line */ \n            coverage_0xb85a875a(0xe3ee65c7d805a580137d81aad82ba8344c5aecc2dd6390d971463ea5bd72c18c); /* statement */ \nb[7] = (((a[11] * (2**6)) & 0xffffffffffffffff) | (a[11] / (2**58)));\r\ncoverage_0xb85a875a(0xb44dffe0bd5a7c76dd177fdfff8054334868b87239c03ae8d08bd0d46ae9542e); /* line */ \n            coverage_0xb85a875a(0x0e49cd33f9eb55406fdb143efb3db24424a9ab8efcd271c9033144921dca4583); /* statement */ \nb[10] = (((a[12] * (2**43)) & 0xffffffffffffffff) | (a[12] / (2**21)));\r\ncoverage_0xb85a875a(0xbc84af1213ce01207209be1d7f875374bd4979f87beb533b09a7909a5a79a2ed); /* line */ \n            coverage_0xb85a875a(0x89e4e32abf70033e73ee66514e70fc2a0e04ff1184c956a83d8a2f8b74ce8750); /* statement */ \nb[18] = (((a[13] * (2**15)) & 0xffffffffffffffff) | (a[13] / (2**49)));\r\ncoverage_0xb85a875a(0xfe53757894c5af56640a4541513df9e658e7a2195c1815b14130624522429527); /* line */ \n            coverage_0xb85a875a(0x7109ac5eadfbbe5ae6119f98ff3a95280816135e4676a0909ecf2a2ebe35b367); /* statement */ \nb[21] = (((a[14] * (2**61)) & 0xffffffffffffffff) | (a[14] / (2**3)));\r\ncoverage_0xb85a875a(0x79492f99e4275ddf73760197c7f3f0859a1ab39fa5ac9dabafab83f222640f5d); /* line */ \n            coverage_0xb85a875a(0x8d130e113b29d311247422a8254530508ca54a0befb64d95072f645776be4275); /* statement */ \nb[1] = (((a[15] * (2**28)) & 0xffffffffffffffff) | (a[15] / (2**36)));\r\ncoverage_0xb85a875a(0x011a55acd39b7471ebc47546aec6cf5f02eec9f0e4db99ad3265f72bf49230d4); /* line */ \n            coverage_0xb85a875a(0x99a6a8b10276d07239cc9fed737cf70f4bd8e0b1a692a89508905339cb9d7a0b); /* statement */ \nb[9] = (((a[16] * (2**55)) & 0xffffffffffffffff) | (a[16] / (2**9)));\r\ncoverage_0xb85a875a(0x137d12491e8f176e6c57b9b67d22bbd59ae9217836209cb584c2ba334d055c28); /* line */ \n            coverage_0xb85a875a(0x6a69ba76e353dd0b42fa3428f1da19c343fb0c1fe9c34511dcbf00a754357843); /* statement */ \nb[12] = (((a[17] * (2**25)) & 0xffffffffffffffff) | (a[17] / (2**39)));\r\ncoverage_0xb85a875a(0x3a2297ffee128835468602a23231cb42f5c72abe9e4505229c37f4004dcfef32); /* line */ \n            coverage_0xb85a875a(0xa35fc9eff0401c73562aa842bfbf403778057d6161fd94427fe1ab297a8d0c52); /* statement */ \nb[15] = (((a[18] * (2**21)) & 0xffffffffffffffff) | (a[18] / (2**43)));\r\ncoverage_0xb85a875a(0xfc6e5e56752f92e9b9e10dd882568961115e369cefc65de9f2c2433ef1cb33a5); /* line */ \n            coverage_0xb85a875a(0x5470559d581168e337c3a585dc8233ba8a9b22fb0febcae01d77bba7346ccdaf); /* statement */ \nb[23] = (((a[19] * (2**56)) & 0xffffffffffffffff) | (a[19] / (2**8)));\r\ncoverage_0xb85a875a(0x335b6d69ff8011501bd0e78c173c7d8be196ed77cfa656b53c9a99f0f2ebb234); /* line */ \n            coverage_0xb85a875a(0x22985450b51e34a6fb0f533d6d4df4f6b72d44c6dea1b1ed2f2d9cdbd86b1576); /* statement */ \nb[3] = (((a[20] * (2**27)) & 0xffffffffffffffff) | (a[20] / (2**37)));\r\ncoverage_0xb85a875a(0x90e70b15cceb32306b325b83fa4b361ce7cc2e0fdee7126bfe478af257d4b1a4); /* line */ \n            coverage_0xb85a875a(0xd058407ccfdafcd2bcb95257f8a0bd9d3dc6c12bd92a20c7a7889f26308e421b); /* statement */ \nb[6] = (((a[21] * (2**20)) & 0xffffffffffffffff) | (a[21] / (2**44)));\r\ncoverage_0xb85a875a(0x768e9a24b57a2de0fac5419a22df9996b5f99df4ce62138b0304b6f0b87a3012); /* line */ \n            coverage_0xb85a875a(0xc0dce3515bfa4037b3b0ce0cf5b975dcc27a9f03a96fe4e8cac68086082f4b41); /* statement */ \nb[14] = (((a[22] * (2**39)) & 0xffffffffffffffff) | (a[22] / (2**25)));\r\ncoverage_0xb85a875a(0x16ae10cc07c107aaba374b9fe90a92cc308ad2385aff4ab501d244ee50afe9fa); /* line */ \n            coverage_0xb85a875a(0xd387474069fecc062d38622746816cd4bf60fa5ab0be5ddb9d90058f37bd0349); /* statement */ \nb[17] = (((a[23] * (2**8)) & 0xffffffffffffffff) | (a[23] / (2**56)));\r\ncoverage_0xb85a875a(0xf4c3482a6142083c69d1838d8439447397c60533fa3712a16835884bbf285d97); /* line */ \n            coverage_0xb85a875a(0x04e2c7458eb08d14fe0b1be9a012f9cea489ddee2e295449db38f077d5773230); /* statement */ \nb[20] = (((a[24] * (2**14)) & 0xffffffffffffffff) | (a[24] / (2**50)));\r\n\r\n            /*Xi state*/\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                for( y = 0 ; y < 5 ; y++ ) {\r\n                    A[5*x+y] = B[5*x+y]^((~B[5*((x+1)%5)+y]) & B[5*((x+2)%5)+y]);\r\n                }\r\n            }*/\r\n\r\ncoverage_0xb85a875a(0xd1e8eace71e494bb52998b5d0d4b3961d0ee716dfb0be7f246b2e0282b10cab6); /* line */ \n            coverage_0xb85a875a(0x15b542c844a062ffacf2b7d00673513c26bc128b069549da6d347d1f52409c90); /* statement */ \na[0] = b[0] ^ ((~b[5]) & b[10]);\r\ncoverage_0xb85a875a(0x3b63e65859160f35c316ef483c6793b977819964cdf70695af7c06236500d186); /* line */ \n            coverage_0xb85a875a(0x637d50fe9858a8fef9911440fef5fc8930d4efdce47d102d05d9fddc97783aae); /* statement */ \na[1] = b[1] ^ ((~b[6]) & b[11]);\r\ncoverage_0xb85a875a(0x41c72078936f85fa0211e7916c05dcdb0204be3073d7716244d7fded2dc9edac); /* line */ \n            coverage_0xb85a875a(0x64c36e1fd279f5b43efbfd1d562be071577c45dc191a0fb4d0a63c90faf48f08); /* statement */ \na[2] = b[2] ^ ((~b[7]) & b[12]);\r\ncoverage_0xb85a875a(0x7a5514573d617b6013285d63e28e09c22827f320dbd0a37812eb9a664f11bc06); /* line */ \n            coverage_0xb85a875a(0x8f361febfeb38a0ddcfea9595b83941c550b6839d1b183cc7605589ed3ed3624); /* statement */ \na[3] = b[3] ^ ((~b[8]) & b[13]);\r\ncoverage_0xb85a875a(0xfd4fec4d96649d474209fdd24fb6cafe1d19419a8b5dd04e922294609325afa2); /* line */ \n            coverage_0xb85a875a(0x4f118721ae7ab6537ddcf429fc680aeb9b9e0271bd539fc678af520b1ee209ed); /* statement */ \na[4] = b[4] ^ ((~b[9]) & b[14]);\r\ncoverage_0xb85a875a(0x0cf65367144e455b853803bb4a9eb2c347df5456f6086c68280bcc874370ab35); /* line */ \n            coverage_0xb85a875a(0x46d60baa67bd69613666bb3905eee358f7782a0b71ef3771a59c13e699adabc8); /* statement */ \na[5] = b[5] ^ ((~b[10]) & b[15]);\r\ncoverage_0xb85a875a(0x5794ed7a78a2b44e408d046ca53d6d227f96b580bf3ec10ccf2b7ab4e054762e); /* line */ \n            coverage_0xb85a875a(0x14599a82d65c805abf511754884f57de91a0e542d18ec085a2cc3eea7bd33e78); /* statement */ \na[6] = b[6] ^ ((~b[11]) & b[16]);\r\ncoverage_0xb85a875a(0x705fd608464a1424e0128f5d7265c3924904a8ca374436fbd67814fabde45aa8); /* line */ \n            coverage_0xb85a875a(0xa8c13a67dfd2915f69306d8652fe2d6fd4490edf75850c5d4cdf62c08d74ca91); /* statement */ \na[7] = b[7] ^ ((~b[12]) & b[17]);\r\ncoverage_0xb85a875a(0x9e2fce6a6465dcbb2b86ee7cd7e2747de2b98f081c074d4320ca6dfb8d0b12ad); /* line */ \n            coverage_0xb85a875a(0x1c9517c6c52abd8122dcc38069e494a460454b66fe94ed3e8b73f645f99c9a1e); /* statement */ \na[8] = b[8] ^ ((~b[13]) & b[18]);\r\ncoverage_0xb85a875a(0x4dc3d732d33d8fc26969c047baa0b30b21c2afb3bb738f131d57c0f945b9c26e); /* line */ \n            coverage_0xb85a875a(0xea267bb96bf12137bb29d78d61daebf89d06a1219b4035413e49c788903d3538); /* statement */ \na[9] = b[9] ^ ((~b[14]) & b[19]);\r\ncoverage_0xb85a875a(0x6c9bbad5941e2c5d3e5f3f6672c1eff78b6b65f028d709cf80ab2cbc34ada6f9); /* line */ \n            coverage_0xb85a875a(0x966903d15a36c0ab0851d42fdd4db8808f00ea438ab0023ee103ed43fae3ebdc); /* statement */ \na[10] = b[10] ^ ((~b[15]) & b[20]);\r\ncoverage_0xb85a875a(0xdbd97c3cf3dcaeed5e9cc5d6e1f4ea44f7625289e349a25057a75578a1768a0d); /* line */ \n            coverage_0xb85a875a(0x9df85bbc177a34f625a372c8ead09853b119ba8e8dad37df78e742dd0cdf8ba2); /* statement */ \na[11] = b[11] ^ ((~b[16]) & b[21]);\r\ncoverage_0xb85a875a(0xe7f09b22867d9ec16c32c7e29748c71e4afee8f3cde7849372956243800fa7fc); /* line */ \n            coverage_0xb85a875a(0x98d7e7cfa10a7c430906c1f53317a0e8decbdd7db969a040ae6256ba65b300a3); /* statement */ \na[12] = b[12] ^ ((~b[17]) & b[22]);\r\ncoverage_0xb85a875a(0xd5a6c0502dd6abf0eaf89ced929d9c068d0bb3778821907478cf47a666fcf3db); /* line */ \n            coverage_0xb85a875a(0x7e0870aa5ffe99af473ad1e48114576dbe1e5f7122d31cd64ef473528770a828); /* statement */ \na[13] = b[13] ^ ((~b[18]) & b[23]);\r\ncoverage_0xb85a875a(0x79dc293a3a5e927476bef3cf0a0d572b946ebe907c7f0c7a4175203e42622ec7); /* line */ \n            coverage_0xb85a875a(0xb3e2b0660f6656c93e5ec8e26dea8bcd63b619dcf7fad2ac1b4c046d4966a78a); /* statement */ \na[14] = b[14] ^ ((~b[19]) & b[24]);\r\ncoverage_0xb85a875a(0xb6c6aea3eab4c0900acde48f15d5ac39cb4c796e43e72a81ea54c7734914c5cf); /* line */ \n            coverage_0xb85a875a(0x3357fd66810d6d6573ffce43e0de2ecfcb013372e54c39c48c75b280d63e80f6); /* statement */ \na[15] = b[15] ^ ((~b[20]) & b[0]);\r\ncoverage_0xb85a875a(0xa3963102be592a8fd3133d717b0acf62542a901b1f4a4572b06e807217dce87b); /* line */ \n            coverage_0xb85a875a(0x19bdc583f7e89e33a05216d00d53ebf69dabafc2b559c9fedba81d090822e0e4); /* statement */ \na[16] = b[16] ^ ((~b[21]) & b[1]);\r\ncoverage_0xb85a875a(0x862477b5251f8024dd80b9b0b3fffce425dee945d743da961729ebb568c5b867); /* line */ \n            coverage_0xb85a875a(0xb430cb5ce10482359e035ef12b56efd978a125bf0cfadcde6535c2ae189d8b0d); /* statement */ \na[17] = b[17] ^ ((~b[22]) & b[2]);\r\ncoverage_0xb85a875a(0x943747f5cb1f1003bcf0f3400c252141e409f0c832cfda3b58f489142195a7be); /* line */ \n            coverage_0xb85a875a(0x2310e727e712f7c4d6c12b55d2328ae76b7e0208f10f91a97f7dc327c58ee26e); /* statement */ \na[18] = b[18] ^ ((~b[23]) & b[3]);\r\ncoverage_0xb85a875a(0xf7474b2669a84c293f35b8872ee8d6c6d4914fa85b74881074d42530452ebf89); /* line */ \n            coverage_0xb85a875a(0x2b25d5f15af54a558c2029b0b17dc1bd9bdd74df16e883a14805b581ae39766d); /* statement */ \na[19] = b[19] ^ ((~b[24]) & b[4]);\r\ncoverage_0xb85a875a(0x700ec3812b81e5e75fd2d7993bd3dd26b715b97006af895ee98f0e994e9daf3d); /* line */ \n            coverage_0xb85a875a(0x2604f4605a1d50feb680c7743607aa21cbbcde17274b481f856496fb09d14392); /* statement */ \na[20] = b[20] ^ ((~b[0]) & b[5]);\r\ncoverage_0xb85a875a(0x8dba1877e5f6c9495fd74d27edc6fb8d76945c6082eec9e1f446b8a84c5c6987); /* line */ \n            coverage_0xb85a875a(0x9773bd5ed9b867fbf645448c0e695a7d3f85ab171402b0f2cd83227b8222d51c); /* statement */ \na[21] = b[21] ^ ((~b[1]) & b[6]);\r\ncoverage_0xb85a875a(0x8b5448f8bc290e895aad158a7287a0ef248df861bf255c7d68816091187c4f7d); /* line */ \n            coverage_0xb85a875a(0xd41e388facf3e5850a4e6f31e8f281a61921782420541fc1598f9a334f84c97c); /* statement */ \na[22] = b[22] ^ ((~b[2]) & b[7]);\r\ncoverage_0xb85a875a(0x71485506865bc64268d8406d2e904eb727495deddc5f9af8469bcf8fc717245d); /* line */ \n            coverage_0xb85a875a(0x9f9e6daf8e3541e9486e5ff324d92d4ad9bc5b0274c349a49ee9bb11a7725e11); /* statement */ \na[23] = b[23] ^ ((~b[3]) & b[8]);\r\ncoverage_0xb85a875a(0x3b9b2b4efd7b3664f88162a97d39dcac055f4c63a26b3feb1658726b9d1e0ff7); /* line */ \n            coverage_0xb85a875a(0xac5539adf21233b4100450dbccff9bae4f5cbdcbd237329d15c9c35b1362c519); /* statement */ \na[24] = b[24] ^ ((~b[4]) & b[9]);\r\n\r\n            /*Last step*/\r\ncoverage_0xb85a875a(0xbcb680689e418cdbb867ffbb3faf2e21af830ad124f95b85b4907f5e7e40c3bb); /* line */ \n            coverage_0xb85a875a(0xb99d1b8b0d340ab6291bc79457a92d2ee06478b673abfb3314d2303452ecba85); /* statement */ \na[0] = a[0] ^ rc[i];\r\n        }\r\n\r\ncoverage_0xb85a875a(0xa444041f30dd86569c353b5abe4cc9e6d7c2d256473fb5d7e743216e68e81a0d); /* line */ \n        coverage_0xb85a875a(0xea6d7cc4c228008e8e3d9393bbd103f7c1fa66f55ef697d06cd5d3a8f900edce); /* statement */ \nreturn a;\r\n    }\r\n\r\n    function rightRotate(uint32 x, uint32 n) internal pure returns (uint32) {coverage_0xb85a875a(0xa4ad537425d7813784a679a9ed986cfc203592e2763640c30403d76cca61c6f5); /* function */ \n\r\ncoverage_0xb85a875a(0xd8c3e9199ff130318cd78668a23ef5a7a3edfbd4475c03ccec7d91a72283496a); /* line */ \n        coverage_0xb85a875a(0x79b8a24828a0ea9f6b28c7ebe6f98a6db7997ec6a5a3fb96bfdc3b89cdefd81c); /* statement */ \nreturn ((x) >> (n)) | ((x) << (32 - (n)));\r\n    }\r\n\r\n    function CH(\r\n        uint32 e,\r\n        uint32 f,\r\n        uint32 g\r\n    ) internal pure returns (uint32) {coverage_0xb85a875a(0x10170d4ba4fcf75bf35737546831a60af2dadb75ef973a2eb1c27bbc3845996e); /* function */ \n\r\ncoverage_0xb85a875a(0xb02f6e23ddfff29161c68942d1f744561cb1ebcc5bf92c649009ed1ba78e8d02); /* line */ \n        coverage_0xb85a875a(0x20c87661b6eaaf5d422e6b73c2d258b8e8cc42d080ffd1084cb631a01923aa65); /* statement */ \nreturn ((e & f) ^ ((~e) & g));\r\n    }\r\n\r\n    // SHA256 compression function that operates on a 512 bit chunk\r\n    // Note that the input must be padded by the caller\r\n    // For the initial chunk, the initial values from the SHA256 spec should be passed in as hashState\r\n    // For subsequent rounds, hashState is the output from the previous round\r\n    function sha256Block(uint256[2] memory inputChunk, uint256 hashState)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {coverage_0xb85a875a(0x851011a98d712290bb99ab5e98b46edc6963c7f40acb10cbd0900c23d27e6b38); /* function */ \n\r\ncoverage_0xb85a875a(0xc8c43f2de94326451b1e02438a6dfa3e80497c14fb2d00842933ad5e6ba92cc2); /* line */ \n        coverage_0xb85a875a(0x5adc1f951e8829a83d5d1a78a0733186ed8f10df105cb7ca24eb670d23513999); /* statement */ \nuint32[64] memory k = [\r\n            0x428a2f98,\r\n            0x71374491,\r\n            0xb5c0fbcf,\r\n            0xe9b5dba5,\r\n            0x3956c25b,\r\n            0x59f111f1,\r\n            0x923f82a4,\r\n            0xab1c5ed5,\r\n            0xd807aa98,\r\n            0x12835b01,\r\n            0x243185be,\r\n            0x550c7dc3,\r\n            0x72be5d74,\r\n            0x80deb1fe,\r\n            0x9bdc06a7,\r\n            0xc19bf174,\r\n            0xe49b69c1,\r\n            0xefbe4786,\r\n            0x0fc19dc6,\r\n            0x240ca1cc,\r\n            0x2de92c6f,\r\n            0x4a7484aa,\r\n            0x5cb0a9dc,\r\n            0x76f988da,\r\n            0x983e5152,\r\n            0xa831c66d,\r\n            0xb00327c8,\r\n            0xbf597fc7,\r\n            0xc6e00bf3,\r\n            0xd5a79147,\r\n            0x06ca6351,\r\n            0x14292967,\r\n            0x27b70a85,\r\n            0x2e1b2138,\r\n            0x4d2c6dfc,\r\n            0x53380d13,\r\n            0x650a7354,\r\n            0x766a0abb,\r\n            0x81c2c92e,\r\n            0x92722c85,\r\n            0xa2bfe8a1,\r\n            0xa81a664b,\r\n            0xc24b8b70,\r\n            0xc76c51a3,\r\n            0xd192e819,\r\n            0xd6990624,\r\n            0xf40e3585,\r\n            0x106aa070,\r\n            0x19a4c116,\r\n            0x1e376c08,\r\n            0x2748774c,\r\n            0x34b0bcb5,\r\n            0x391c0cb3,\r\n            0x4ed8aa4a,\r\n            0x5b9cca4f,\r\n            0x682e6ff3,\r\n            0x748f82ee,\r\n            0x78a5636f,\r\n            0x84c87814,\r\n            0x8cc70208,\r\n            0x90befffa,\r\n            0xa4506ceb,\r\n            0xbef9a3f7,\r\n            0xc67178f2\r\n        ];\r\n\r\ncoverage_0xb85a875a(0x88fc3e0791922d152fcced4cd82fbe988304840b8a3e2157a0b9eae8aaf79aa3); /* line */ \n        coverage_0xb85a875a(0x5b232b851174a4f347b4748c6ef7f317e160ecf6e7bda41b9e3fcab5bc6f3d2c); /* statement */ \nuint32[64] memory w;\r\ncoverage_0xb85a875a(0x2cea31d31481738b1443c71ab9a956c4fb823d5d07e39fc19160b473caf50e7c); /* line */ \n        coverage_0xb85a875a(0x376c374362c7f011da76b1cf59b4505c703456edb24b54028d262d29823c47f7); /* statement */ \nuint32 i;\r\ncoverage_0xb85a875a(0x21777891c7eb9871194daee6f7939829a7e6703e09f644f8f3fada0b78094ae0); /* line */ \n        coverage_0xb85a875a(0x85afd68f47830e450620fc0fea79e0af1d174214a8b9edbb305314ebc65a318d); /* statement */ \nfor (i = 0; i < 8; i++) {\r\ncoverage_0xb85a875a(0x7206995096133b144a28931a25519a632c1ef8f8eca739be08588e29c7840f76); /* line */ \n            coverage_0xb85a875a(0xc657815a99e22d8ff0b2c6eca86a0c8ccae0eb3b89ceeef4e753c6daf4964c4f); /* statement */ \nw[i] = uint32(inputChunk[0] >> (224 - (32 * i)));\r\ncoverage_0xb85a875a(0xc525230d50f161335a0848ac2480cb0e3d049b7b0a5d6392760a0b9dacc7efd3); /* line */ \n            coverage_0xb85a875a(0xd511788df4e3edd3609f7b4099f8b7de75373793bbc4b34ac067c55b9e933902); /* statement */ \nw[i + 8] = uint32(inputChunk[1] >> (224 - (32 * i)));\r\n        }\r\n\r\ncoverage_0xb85a875a(0xdabe8a3c293f3d55f9136a5a86d5efb19b6f463823beae9a1cb1f8893dd6b7bb); /* line */ \n        coverage_0xb85a875a(0x106748756aff5a842fac4cd4a26abaa71c215eb1dc64f79f0b4a82f5cca43aa7); /* statement */ \nuint32 s0;\r\ncoverage_0xb85a875a(0xbd5ab0c47c091dda1213c7b90d6ff58b4ca5bb17e3df792bad65c93f29c291e6); /* line */ \n        coverage_0xb85a875a(0x365be132a92b818eb39033198abf672d302faac8422923e0b6e48a31cbc31edd); /* statement */ \nuint32 s1;\r\ncoverage_0xb85a875a(0x61dcb2d6c973c4cfcec54d57b9dbb5bc84bdaf5d31b73178da475b23b8f5d662); /* line */ \n        coverage_0xb85a875a(0x9fad29ad550f195fd68dd942a286f8a4c5e2733125083ac4ca928ed1e0a7e4ee); /* statement */ \nfor (i = 16; i < 64; i++) {\r\ncoverage_0xb85a875a(0xdb270ba135adbfca0c1eb03765bd74159a6cdf22ef4f99e5cdcd572e7a39a2e9); /* line */ \n            coverage_0xb85a875a(0x096d4dda584c87d05606d3b6308714473a55c4df83f20fa89614283a91fc5881); /* statement */ \ns0 = rightRotate(w[i - 15], 7) ^ rightRotate(w[i - 15], 18) ^ (w[i - 15] >> 3);\r\n\r\ncoverage_0xb85a875a(0x194bd4adb5d0aa444d98ed0816cb86404d658189764fba2f08a7702730378b60); /* line */ \n            coverage_0xb85a875a(0xbb7f5addb068c1dcf66d45df9ee6681ee64cfb1dfa5078ce41d1fcdad4a7e48b); /* statement */ \ns1 = rightRotate(w[i - 2], 17) ^ rightRotate(w[i - 2], 19) ^ (w[i - 2] >> 10);\r\ncoverage_0xb85a875a(0x2e9c242880a9963bb6f165b9f9ec574d0f880d68a55d1b4a0aaf2129dd72330e); /* line */ \n            coverage_0xb85a875a(0xba035f60d936bfb5909423ae606870bf2a477a41cad018cb10eb0eff774f8ab6); /* statement */ \nw[i] = w[i - 16] + s0 + w[i - 7] + s1;\r\n        }\r\n\r\ncoverage_0xb85a875a(0x5c4e9bfb6fcc30945076742842bee75c26e293bdfeca9edcff5c12d0f2163c92); /* line */ \n        coverage_0xb85a875a(0xe564499b5b03977e30acef4f9049cfb05e6c17488bb8ea610624f4bc40d00313); /* statement */ \nuint32[8] memory state;\r\n\r\ncoverage_0xb85a875a(0x0928ef15fe2d333529f4a01a6425aaf060014cc101cc2b90d38569b69bffd6df); /* line */ \n        coverage_0xb85a875a(0x81a68e8f9546edddd9cdcea085e6c2d42868220599d7cc910e95b237ecf094c6); /* statement */ \nfor (i = 0; i < 8; i++) {\r\ncoverage_0xb85a875a(0x2faaafc6904668acccaf589a83353e8a631294f7de0eb17596147193e7efa569); /* line */ \n            coverage_0xb85a875a(0x60eb4951275038d8b88fcf4fb85a882ad915c3d8d1ba00034542fc71f0c6ed7e); /* statement */ \nstate[i] = uint32(hashState >> (224 - (32 * i)));\r\n        }\r\n\r\ncoverage_0xb85a875a(0xd5107fb270ebeb6b212d1209e117f9b82a0339a7ac593ae1f669713b8482746c); /* line */ \n        coverage_0xb85a875a(0xaaa331385d9c48b2ede33d140ed21baf27919e71147a3032249112a03df088be); /* statement */ \nuint32 temp1;\r\ncoverage_0xb85a875a(0xb4b787facfaacb54f7c1bde202c40dd724b5607a630c3ce647365d4cbd84b281); /* line */ \n        coverage_0xb85a875a(0xb60563cda6829cb6d7dade7f0a20255de967ab0749699361b874bece07434051); /* statement */ \nuint32 temp2;\r\ncoverage_0xb85a875a(0x7eabde35ad3de1e756040038e9a3be203cde632aa76d968094ea00b5b83c23c1); /* line */ \n        coverage_0xb85a875a(0x3d6dd55f1ea00e4964e6fe8ded8d25088eb2609a073fadc03aada8400f4f7f4f); /* statement */ \nuint32 maj;\r\n\r\ncoverage_0xb85a875a(0xec27ec35884109ff25d148ccb2b46d4eceacd841211a3fcb641b67136e16b1fd); /* line */ \n        coverage_0xb85a875a(0x367906754c47d41686efb697e177f40e0483af3d03fa6bbab307d9d666cd6fbd); /* statement */ \nfor (i = 0; i < 64; i++) {\r\ncoverage_0xb85a875a(0x0995ee55aa900b53dd63b8aad08fd6ac08cdfbf036d41cd4b90bf9e83f1b8ff4); /* line */ \n            coverage_0xb85a875a(0xcaeda584c7dec93809e80d0e4d44111ed19514365d91716035b24da477d038fa); /* statement */ \ns1 = rightRotate(state[4], 6) ^ rightRotate(state[4], 11) ^ rightRotate(state[4], 25);\r\ncoverage_0xb85a875a(0x89ab315607c73dbeef2f0621d1ea39841c877a40da13ac00f638427d9fa5f63f); /* line */ \n            coverage_0xb85a875a(0xc306d1f542b23dd182ed51f5d6ddf604fa3ba58f7f512791510b8dc7793e4c31); /* statement */ \ntemp1 = state[7] + s1 + CH(state[4], state[5], state[6]) + k[i] + w[i];\r\ncoverage_0xb85a875a(0xedbeffa58f46374527ee41f1dd63d8e6849e027a93c12288367ed2b9d752ab1e); /* line */ \n            coverage_0xb85a875a(0x6658a61ed455edf5ba7406158047a5e017f8cbba389675cccd9ddb210a3e0776); /* statement */ \ns0 = rightRotate(state[0], 2) ^ rightRotate(state[0], 13) ^ rightRotate(state[0], 22);\r\n\r\ncoverage_0xb85a875a(0xa7fca160b8fa3b8b853e4140d542ad7896a3f77b84c0187957a10e129bcb6cd8); /* line */ \n            coverage_0xb85a875a(0xc0c7e98cabfcc4bf3b1c6eb3da5b05270aaea5e651470cb08cabd51da56b0577); /* statement */ \nmaj = (state[0] & (state[1] ^ state[2])) ^ (state[1] & state[2]);\r\ncoverage_0xb85a875a(0x5af753759fa976fcad663d3d4f4bf75532463bc374218bd10b264c8b7abb0893); /* line */ \n            coverage_0xb85a875a(0x25355008630e9d3cd00ac6c63d76efb58b8888c1ceeb38c7c18eaa938b8b7b5f); /* statement */ \ntemp2 = s0 + maj;\r\n\r\ncoverage_0xb85a875a(0x85873d94610707feaa9db24bc722fff8651ffa025585ac764f1bd33dd615a332); /* line */ \n            coverage_0xb85a875a(0xc62b8e05a607e64cc4a2931bf530546e2652bdcb5c8c8fd8871367d422288f69); /* statement */ \nstate[7] = state[6];\r\ncoverage_0xb85a875a(0x076b35d60811e6aaf4d8ffda1da7c5067452c2b4d3893925603abeb5e24156f4); /* line */ \n            coverage_0xb85a875a(0xcc900f9d3fc00a9a4a5684cc07574228d21d676d7e654fff6a525bea1ef5d227); /* statement */ \nstate[6] = state[5];\r\ncoverage_0xb85a875a(0x95a6c38822020579e2ad5b68cfecf8a3c2fdc8dd0bd126c311bc3c650ebccbce); /* line */ \n            coverage_0xb85a875a(0xfc3dcfc4cb9d716f7f6c20a1e7deff2b3e307f40beed66ab389633bc4ccde236); /* statement */ \nstate[5] = state[4];\r\ncoverage_0xb85a875a(0x88f9a1ddf874da6981f6c6a109c84f5a59de0414ada7d41aa52132ba00a915d8); /* line */ \n            coverage_0xb85a875a(0xe0567dc7e3d1adda9e4cffda3ff4dfea8f126f1ee9fe754314e0541a34f583c7); /* statement */ \nstate[4] = state[3] + temp1;\r\ncoverage_0xb85a875a(0xfab8f0002a3c6e90804f9f18579d3f6230437b38fb48b7c28146d1fde3ace159); /* line */ \n            coverage_0xb85a875a(0xe5a0cf0d804f31edbd940ccf03cffaf08ad78bf98a19eb22561f093186fccc3b); /* statement */ \nstate[3] = state[2];\r\ncoverage_0xb85a875a(0x661166ff8d8fcbcac717c85d1aa148f5e98f6970e4123fc2a689d434c57be141); /* line */ \n            coverage_0xb85a875a(0x26689357c4062e62f1ef5a6e3f379a0ddf5255c05389a5374182551256814c61); /* statement */ \nstate[2] = state[1];\r\ncoverage_0xb85a875a(0x7826c448451d2d7bdebafcef80e65f47b05c6684bb927122e8897c2370095c48); /* line */ \n            coverage_0xb85a875a(0x886d05733c4cb8f5a3a6df800e8a1dab1b1cc7ef77775a04cd37c2115080beee); /* statement */ \nstate[1] = state[0];\r\ncoverage_0xb85a875a(0x2bc5c2179c5e32aa0ce5aa708b888bc19d89c1cb37be247aac07ec8bddd097db); /* line */ \n            coverage_0xb85a875a(0x01a724859f4bbd931f8bc78a0fe5e3e947481de6f779c409b201696e97b36da4); /* statement */ \nstate[0] = temp1 + temp2;\r\n        }\r\n\r\ncoverage_0xb85a875a(0xed86c9240768a41c6a618a253a882e5a000754922d476ee06bff935f4c3c1052); /* line */ \n        coverage_0xb85a875a(0x9f1505cacd80c822cfb2e7429d6730110b61ae486a4aec41cd9086d939d33d5f); /* statement */ \nfor (i = 0; i < 8; i++) {\r\ncoverage_0xb85a875a(0x1f6047e5845f523188eb41f30ef73cd5d1523231a7db987a0633325e9d0ee209); /* line */ \n            coverage_0xb85a875a(0xdc5694066bcc8c07380f245f6a3467437b3eb60aa13870a2e979c552146c7152); /* statement */ \nstate[i] += uint32(hashState >> (224 - (32 * i)));\r\n        }\r\n\r\ncoverage_0xb85a875a(0x64af4f4f85cd8fac5588560398c5f7becc555ba2e092acd602801a248a65db15); /* line */ \n        coverage_0xb85a875a(0x1b0f2a43aeb575a20a19b1a943cb2e925a67fb2c7c7d3c290492912499eeb8b6); /* statement */ \nuint256 result;\r\n\r\ncoverage_0xb85a875a(0x5ccb03833eeb6784fe74e7a07ef086aeef6ab6f5e17e72c8d6047d0c13585909); /* line */ \n        coverage_0xb85a875a(0x3313952c37d1ead5389494c78151b46218661c9318181f09e8df5359a97f3fd9); /* statement */ \nfor (i = 0; i < 8; i++) {\r\ncoverage_0xb85a875a(0x900696fdaf505d0337ca17d5ae6fca31e69a1f60b32e7bb6a0135f72a6951673); /* line */ \n            coverage_0xb85a875a(0xeb7f8ef2fbff90fe9bf38afaf75b05852e67edb6aa94108bec76eb32f0997c96); /* statement */ \nresult |= (uint256(state[i]) << (224 - (32 * i)));\r\n        }\r\n\r\ncoverage_0xb85a875a(0x62a1bdc8d749b8f930176bb9533a25024bf2fe4a16006277e80d307f6a51cb98); /* line */ \n        coverage_0xb85a875a(0xc1cf51083b380c45cd4d77c238551ec01be50458562a5bd1281f8bc98d8b57e1); /* statement */ \nreturn result;\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/challenge/BisectionChallenge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"./Challenge.sol\";\r\nimport \"./IBisectionChallenge.sol\";\r\n\r\nimport \"../libraries/MerkleLib.sol\";\r\n\r\ncontract BisectionChallenge is IBisectionChallenge, Challenge {\nfunction coverage_0xd237be53(bytes32 c__0xd237be53) public pure {}\n\r\n    event Continued(uint256 segmentIndex, uint256 deadlineTicks);\r\n\r\n    // Incorrect previous state\r\n    string private constant BIS_PREV = \"BIS_PREV\";\r\n\r\n    // Incorrect previous state\r\n    string private constant CON_PREV = \"CON_PREV\";\r\n    // Invalid assertion selected\r\n    string private constant CON_PROOF = \"CON_PROOF\";\r\n    // Incorrect previous state\r\n\r\n    // After bisection this is an array of all sub-assertions\r\n    // After a challenge, the first assertion is the main assertion\r\n    bytes32 private challengeState;\r\n\r\n    function initializeBisection(\r\n        address _rollupAddress,\r\n        address payable _asserter,\r\n        address payable _challenger,\r\n        uint256 _challengePeriodTicks,\r\n        bytes32 _challengeState\r\n    ) external {coverage_0xd237be53(0xed569db8fae6f33858ddc33e7709609db42e83f6a0282a642ec0283ecd2b4088); /* function */ \n\r\ncoverage_0xd237be53(0x15626b63772430419b20e81d57a32031c8c22ed05c3c5f4b3df52a7dd4e8f5ee); /* line */ \n        coverage_0xd237be53(0xd67aa9b83fa6596bf5817c8c340e9dbd58fd3720c925e3e360e7950078a95f0d); /* statement */ \nChallenge.initializeChallenge(\r\n            _rollupAddress,\r\n            _asserter,\r\n            _challenger,\r\n            _challengePeriodTicks\r\n        );\r\ncoverage_0xd237be53(0x342c248440d251be7f33b7974bf6a72e2373210272ca8d16e6e1bd0f815e5a00); /* line */ \n        coverage_0xd237be53(0xb3cb5b8eb33182afc069d7c7478b1271ce5e3d46c0c24471475f52d06662b327); /* statement */ \nchallengeState = _challengeState;\r\n    }\r\n\r\n    function chooseSegment(\r\n        uint256 _segmentToChallenge,\r\n        bytes memory _proof,\r\n        bytes32 _bisectionRoot,\r\n        bytes32 _bisectionHash\r\n    ) public challengerAction {coverage_0xd237be53(0xf09805e73de6e44e3e288d6f26e3e6755c4c942ad56995d9894a1ac4bcf44932); /* function */ \n\r\ncoverage_0xd237be53(0x58cc3d00f9b6805cf4a3acf0fa289f9f47d8a6e3eda5162ccd8fb63a67079d1b); /* line */ \n        coverage_0xd237be53(0x2ee1b051353601464e043e0cdfd92304b232ae231e57db9046a5a1e61d5ad79e); /* assertPre */ \ncoverage_0xd237be53(0x7f7efb09f3e46f3f68e4e754bc3df39fbbb7638f9c1bbb68556ff1329d0614fc); /* statement */ \nrequire(_bisectionRoot == challengeState, CON_PREV);coverage_0xd237be53(0x75bbcc753d85e5c25d27214f77ad8ca3cc2bd6c0bebda5952b793e8e52aef40c); /* assertPost */ \n\r\ncoverage_0xd237be53(0x7ead284189ff935a5d7c174442d33f88a8722ce2d990dfb54da0334ba8e7d6f5); /* line */ \n        coverage_0xd237be53(0x6f22d2aba5e1f187a352ee38914149a61376ce82f148c707079f1a537d15a7d9); /* assertPre */ \ncoverage_0xd237be53(0x92385db04b657f2bfa8afa289f3fd514e17fc44f81e3451e49648c8e9169e81c); /* statement */ \nrequire(\r\n            MerkleLib.verifyProof(_proof, _bisectionRoot, _bisectionHash, _segmentToChallenge + 1),\r\n            CON_PROOF\r\n        );coverage_0xd237be53(0x2e72dabc0cdc0f4bfa9a4e046f774387c0f30649ed7d5fa8aa2a2e27d31046ac); /* assertPost */ \n\r\n\r\ncoverage_0xd237be53(0xdd06e3b0ecd15a71346080bbc8eccfc546258657b0eda7ec2b229018a08d7df6); /* line */ \n        coverage_0xd237be53(0x152005e239b9bd68076a292086ea4ed9a0770089efeb4794c553ef2694a95353); /* statement */ \nchallengeState = _bisectionHash;\r\n\r\ncoverage_0xd237be53(0x3a9f0e9e187b9397dca33022717ee0f2741c92d2b8835dab6e6852075842462a); /* line */ \n        coverage_0xd237be53(0x3b47685509011b0823e46706c52f24f5fb6c781fa9907034e6d33d05513c7bf9); /* statement */ \nchallengerResponded();\r\ncoverage_0xd237be53(0x1f770c4584e61e36e070160b4fa5df94a6536daa890bf1da5d2cdd108d86139e); /* line */ \n        coverage_0xd237be53(0x61a10934255b49d5c65da0a3139601b0a7421f33f12403fcf589534f2cfbdf11); /* statement */ \nemit Continued(_segmentToChallenge, deadlineTicks);\r\n    }\r\n\r\n    function commitToSegment(bytes32[] memory hashes) internal {coverage_0xd237be53(0xeee50ce5301f3dbd1593d1aa1ace489f62de6e82c668b0d86f166e0c7dade81b); /* function */ \n\r\ncoverage_0xd237be53(0x3d222b6747a7e0448a807cd6db730c95dfaa440e4316a554416bfa232cca3366); /* line */ \n        coverage_0xd237be53(0xfd367f662386aa8c0dbfe0b3960d6cdbf6c3ea5b7874a833bfa0092058833c77); /* statement */ \nchallengeState = MerkleLib.generateRoot(hashes);\r\n    }\r\n\r\n    function requireMatchesPrevState(bytes32 _challengeState) internal view {coverage_0xd237be53(0xb2aaf7ac141332c336200af5a87c069ba04e5e4d3f0b2ef6fe07f756badbd0fc); /* function */ \n\r\ncoverage_0xd237be53(0x1301867a9411c2e7fb315aebe8d264fbab15511e9ee1aad5b1b2f36896d35db0); /* line */ \n        coverage_0xd237be53(0x1f276d667d1b7d3e78393a84382cee6a07b58dd8742d4faa6b4cb95171b809ec); /* assertPre */ \ncoverage_0xd237be53(0x304776e48fdc2c6c2eb20a877606708b7c9943ac845ce0ed9e1a776f0223dbdc); /* statement */ \nrequire(_challengeState == challengeState, BIS_PREV);coverage_0xd237be53(0xcf24270c81234f204a3cde8376914380d49787de8e3da888522a722442a4bce2); /* assertPost */ \n\r\n    }\r\n\r\n    function firstSegmentSize(uint256 totalCount, uint256 bisectionCount)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {coverage_0xd237be53(0x4becd8eac75021a495badfdc92ea4d1e60d67a4da4c6d3c232f60306d458f76d); /* function */ \n\r\ncoverage_0xd237be53(0x35650cd04379c58a1ca872772a33b6520c7e1800c28e9b9853cadb81e4cb7fbc); /* line */ \n        coverage_0xd237be53(0x5b744dacd66ff2eee967b5875f0c3177ee4b781ae25b5dd81f7cec0c53c75b63); /* statement */ \nreturn totalCount / bisectionCount + (totalCount % bisectionCount);\r\n    }\r\n\r\n    function otherSegmentSize(uint256 totalCount, uint256 bisectionCount)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {coverage_0xd237be53(0xe551847ff0921a515bb70ee32007902bbdd3363034fd356246c01d24cb44c49f); /* function */ \n\r\ncoverage_0xd237be53(0x28df3d5445e1101a79b62f74d340338d4f6f174c56962cfe4bd2c66f5fe72289); /* line */ \n        coverage_0xd237be53(0x7f155f8bd16bdabbc0689c5f70c6dce3a83757f0332a0e524b75b5f68df02f96); /* statement */ \nreturn totalCount / bisectionCount;\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/challenge/Challenge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../rollup/IStaking.sol\";\r\nimport \"../libraries/RollupTime.sol\";\r\nimport \"../libraries/Cloneable.sol\";\r\n\r\ncontract Challenge is Cloneable {\nfunction coverage_0x94099878(bytes32 c__0x94099878) public pure {}\n\r\n    enum State { NoChallenge, AsserterTurn, ChallengerTurn }\r\n\r\n    event InitiatedChallenge(uint256 deadlineTicks);\r\n\r\n    event AsserterTimedOut();\r\n    event ChallengerTimedOut();\r\n\r\n    // Can online initialize once\r\n    string private constant CHAL_INIT_STATE = \"CHAL_INIT_STATE\";\r\n    // Can only continue challenge in response to bisection\r\n\r\n    string private constant CON_STATE = \"CON_STATE\";\r\n    // deadline expired\r\n    string private constant CON_DEADLINE = \"CON_DEADLINE\";\r\n    // Only original challenger can continue challenge\r\n    string private constant CON_SENDER = \"CON_SENDER\";\r\n\r\n    // Can only bisect assertion in response to a challenge\r\n    string private constant BIS_STATE = \"BIS_STATE\";\r\n    // deadline expired\r\n    string private constant BIS_DEADLINE = \"BIS_DEADLINE\";\r\n    // Only original asserter can continue bisect\r\n    string private constant BIS_SENDER = \"BIS_SENDER\";\r\n\r\n    address internal rollupAddress;\r\n    address payable internal asserter;\r\n    address payable internal challenger;\r\n\r\n    uint256 internal deadlineTicks;\r\n\r\n    // The current deadline at which the challenge timeouts and a winner is\r\n    // declared. This deadline resets at each step in the challenge\r\n    uint256 private challengePeriodTicks;\r\n\r\n    State private state;\r\n\r\n    modifier asserterAction {coverage_0x94099878(0x79ab23f2143a6a8ca8d6c4d5642fd401dd90cc7e50c95d8a8798e285345989a3); /* function */ \n\r\ncoverage_0x94099878(0x86b884d9c7a129d4a0cd0ebb827780835898f7cbb82258b4f27e88bd9cf0e2ee); /* line */ \n        coverage_0x94099878(0x1aababbcac14d9e17f16bd52db7d8838cf9945bb770c342f3c003fbb1faccd70); /* assertPre */ \ncoverage_0x94099878(0xfa956a146223ab88fe2c1008eb12b96dcb90d41d406db9426c581a2025a452ce); /* statement */ \nrequire(State.AsserterTurn == state, BIS_STATE);coverage_0x94099878(0x29429996041215e928cff3dd224e1e179fb109732d1412aefb61706873c84ae5); /* assertPost */ \n\r\ncoverage_0x94099878(0x8111fd943191138004756054da5619e05344bb44662b96180f537dd05e5d21ea); /* line */ \n        coverage_0x94099878(0xc1ce7800cd3c08e6cde790f78b3089d9083a6591182cdc9302e9abff7738475a); /* assertPre */ \ncoverage_0x94099878(0x5b5bf1fe303ff9f6a3afe7b9e764532e2630deb0ba5f25478da73bb343ea110f); /* statement */ \nrequire(RollupTime.blocksToTicks(block.number) <= deadlineTicks, BIS_DEADLINE);coverage_0x94099878(0x68420c746762a57899286e094024a7e8128d83e2a7a8f04109a6f5a92bdc5390); /* assertPost */ \n\r\ncoverage_0x94099878(0x4f1f4ef02e4dddc82a9a3cfd04b5bd5ead9ce93b761a2367e3bb03ce4c641947); /* line */ \n        coverage_0x94099878(0xe22158e27ea200ecb9704dfa1e01374c51ef39093b66b2bac7dfa9b530893be5); /* assertPre */ \ncoverage_0x94099878(0x97e10826099f4aa8dcfdead6fec404b7ebbd5270a0ca07b18b4a94f516c438c0); /* statement */ \nrequire(msg.sender == asserter, BIS_SENDER);coverage_0x94099878(0xa94fa5da93ae2c94c061a508267d2c7f5e8bea54ff23e7fdd8a92466d1fafab1); /* assertPost */ \n\r\ncoverage_0x94099878(0x768c19ef1e56e4319ddb5409f0ad667f67bc02125a920a77a3601932cc9e13fc); /* line */ \n        _;\r\n    }\r\n\r\n    modifier challengerAction {coverage_0x94099878(0x70447a903ec2dbdbd0b290bf9e27d8339738bf1555ccf055719d91f224b5277b); /* function */ \n\r\ncoverage_0x94099878(0x1f36bf56f046d87f1d6265b19ddd7d248455015ece707ee1a291f4fbd1af9402); /* line */ \n        coverage_0x94099878(0xe4dbfcec5e208648b627c86d1b7036f875fb0aa504034854709c3c3256725c16); /* assertPre */ \ncoverage_0x94099878(0x8df4609066fe21be05234a1db9621a91210b3689263c690d759435b95f7e803e); /* statement */ \nrequire(State.ChallengerTurn == state, CON_STATE);coverage_0x94099878(0x7cac51119cbe8e8c7a8044b18303b69df638521f92ddd68d5698bc80f4c482ef); /* assertPost */ \n\r\ncoverage_0x94099878(0xa522a437283ffee2ba8865a2e72d8ffae95eb26ef5cd36d4be0cc76d893f6119); /* line */ \n        coverage_0x94099878(0x91996bb8db225284ef59f2b4fb5e93772a2e013d12ba9619beddfe74a1d3e68c); /* assertPre */ \ncoverage_0x94099878(0xf20b827f7be0176a323d0a2daff643cbc57b2959bfce3fae0c67a23dbd372302); /* statement */ \nrequire(RollupTime.blocksToTicks(block.number) <= deadlineTicks, CON_DEADLINE);coverage_0x94099878(0x141ad90e74af1a208c87fbfa90407cbb04a7b0cf9c05997f231e85bc49b50c51); /* assertPost */ \n\r\ncoverage_0x94099878(0x4ebb698965ab6c501dbfe71713cb73510163209560cf501c4235b69392b8871d); /* line */ \n        coverage_0x94099878(0xd2abfa20ac28928010a18dd2ce0ae597183bd7cb35e984ffa11bf3715c545e47); /* assertPre */ \ncoverage_0x94099878(0x6452ee466626eee6466e8f145c42b383d48b86bb01e07abf587d35a07fd447c8); /* statement */ \nrequire(msg.sender == challenger, CON_SENDER);coverage_0x94099878(0x0b639263ba75a48f248cea320129d9609d6eeaf7d99e6c943f695882b2f23f5d); /* assertPost */ \n\r\ncoverage_0x94099878(0x203ca3a05d8cc98c5d41b12d37e03839360515ec47acc0fd20e9f53b9d5a8b39); /* line */ \n        _;\r\n    }\r\n\r\n    function timeoutChallenge() public {coverage_0x94099878(0xe2f4bbf2cac39b28aef6a02cc1e72a2ddf5a3c5f4809131c34bfc5a1eaaa1565); /* function */ \n\r\ncoverage_0x94099878(0x593d0e49af4719c7fedc2e859d4b4bb96fffa8ca8aba8dfd41e417adb1a2c1ed); /* line */ \n        coverage_0x94099878(0x31c262c4bd1f268e6abdabd0b1eea144b86b5354d8473c50651efef0214115d9); /* assertPre */ \ncoverage_0x94099878(0x136008ba2391122bb1b1cc6690fefd6283afaabde1996ed85baf1f753455c330); /* statement */ \nrequire(RollupTime.blocksToTicks(block.number) > deadlineTicks, \"Deadline hasn't expired\");coverage_0x94099878(0x3a27f10a1f6cc851ad71ea7c7b74fa84f812918f0117aa690c1483b052d14948); /* assertPost */ \n\r\n\r\ncoverage_0x94099878(0x731cafa7ceadcc94eb9ee8591b23600ced93eb7092ad8f80336dada9a6faf401); /* line */ \n        coverage_0x94099878(0xeb0c4054648375d1762b41dd3c815f1e45c4e65ac1a5a6a70f30281090d74e28); /* statement */ \nif (state == State.AsserterTurn) {coverage_0x94099878(0xeafab1b02a28958719e354b8e037213475ac1c170790257e0b783d1c30f93128); /* branch */ \n\r\ncoverage_0x94099878(0xb79926d9bd93e1a583bfc056c94690b555926eee6c4c03dbfe294b257760dfc1); /* line */ \n            coverage_0x94099878(0xabc28c3d42525f0b26332a919567d3511ece64ae0da8202af443221a6cb16d33); /* statement */ \nemit AsserterTimedOut();\r\ncoverage_0x94099878(0x86c92c0794adf626630f66c280e06cca33de9444b7c89f5cfa8f485724887dee); /* line */ \n            coverage_0x94099878(0x90a0ab64737c238fb023eb3c1050e27571f8471e0edbab4c8005b0173e8ff968); /* statement */ \n_challengerWin();\r\n        } else {coverage_0x94099878(0xd199b608950cb36e3f748f8693b936a699efdd4c5d3beb90be97e0529acbb8cc); /* branch */ \n\r\ncoverage_0x94099878(0x453eca53da93f219905514e40e37000f1df97b192da6e7199cc2eb667589fac8); /* line */ \n            coverage_0x94099878(0x1fecca3952e5ccfc5d21c1ad7f1a070145b5aa4a79f2efd58e9f372ec9a46e29); /* statement */ \nemit ChallengerTimedOut();\r\ncoverage_0x94099878(0x4b331b74cc42a37ceb4e6ba773ea8311d5eaa60d1f56b7ef7336ffded78be048); /* line */ \n            coverage_0x94099878(0xbe44dbf458d93e5739ef5f80092d5a49c860244b86314c808b25d105762cf2a8); /* statement */ \n_asserterWin();\r\n        }\r\n    }\r\n\r\n    function initializeChallenge(\r\n        address _rollupAddress,\r\n        address payable _asserter,\r\n        address payable _challenger,\r\n        uint256 _challengePeriodTicks\r\n    ) internal {coverage_0x94099878(0x5efa226100427600aa4f3e389af00433b68dc7b20ada0f401c50ca571858c528); /* function */ \n\r\ncoverage_0x94099878(0x7f2e0ca6fa607462642e3781e16a3b8e5364935845656b98da38cb55187ad135); /* line */ \n        coverage_0x94099878(0x3a9d34cc96a7688ba8021a9002d41a44dd7be62358b10bd04fb83175e191faaf); /* assertPre */ \ncoverage_0x94099878(0x7917fa5f90fabf64f18a6f6a314e4e48230659392b26d23bbd51bc24894bcad0); /* statement */ \nrequire(state == State.NoChallenge, CHAL_INIT_STATE);coverage_0x94099878(0x9925b5348d7d85c0aa09d987d9a39674ffca11cf5f4b8d68646b69ff62cc84f5); /* assertPost */ \n\r\n\r\ncoverage_0x94099878(0x414691c33945fea9e3a12df927aad04e539ab0a382f24f48d21cce9dca88a3c8); /* line */ \n        coverage_0x94099878(0x1ec7391cb00cd00eb74c78d84b95a81a85556fc23072fe17b0911b3dc57fde8f); /* statement */ \nrollupAddress = _rollupAddress;\r\ncoverage_0x94099878(0x7248caf6fb2a0d295e050095f69cc4a882229c833b2ccead7e9e3f4251f40e8c); /* line */ \n        coverage_0x94099878(0x82a36e78da53f065eff7d15f8e47666e55c61ccf00332acf9abbea022de7ac73); /* statement */ \nasserter = _asserter;\r\ncoverage_0x94099878(0xcb40f6fd124a6290af4f23f8f4f799a9700b716bb64b64070eaa1f9e151931ac); /* line */ \n        coverage_0x94099878(0xadfe1a46d7190b5cd88947989f98bfdcdb72dc8fec43f7a33d8fada64f46590f); /* statement */ \nchallenger = _challenger;\r\ncoverage_0x94099878(0xba1192146fce7502f885155989b69eba91f1f4d46e3aeb3bed370310979abda3); /* line */ \n        coverage_0x94099878(0x9dd57a8e78566ef15b8fd684d84511dd28c86eb8d440885026e495024a887d49); /* statement */ \nchallengePeriodTicks = _challengePeriodTicks;\r\ncoverage_0x94099878(0x06f9a8fabf9744ab17c5efe84a7da81adbfe70d6dc69646b9dd7ff5c95c2ee2d); /* line */ \n        coverage_0x94099878(0x299d7c4aa30b3c4226481ec927330bd02ae53ffbbecfbc9183c09c81c8e06c00); /* statement */ \nstate = State.AsserterTurn;\r\ncoverage_0x94099878(0x34913b2696ccb0bd44f399ff3d50aa78d7e659d1bb363a196b9c1d2cf675f517); /* line */ \n        coverage_0x94099878(0xfa73060dcf702e850ba2bb018e59f90d7237879cbc4470d0a84e078ee21f77d1); /* statement */ \nupdateDeadline();\r\n\r\ncoverage_0x94099878(0xee54f02568a9dfb815508e557360737e335ac2219e598e18a946bb24983e1b14); /* line */ \n        coverage_0x94099878(0xfba96379c066c71a3d17d66c10ba88d48bf8c98a6613dceea1944e4d4e19b0bd); /* statement */ \nemit InitiatedChallenge(deadlineTicks);\r\n    }\r\n\r\n    function updateDeadline() internal {coverage_0x94099878(0xc6a81e0cb898dc3738d65eb072876281a8bff08f2657cbf7963d19a67580e9b5); /* function */ \n\r\ncoverage_0x94099878(0x09f5cdd275ea43537d81277b79adf37b1d6f24b43a309f0a4658e9675e32dde8); /* line */ \n        coverage_0x94099878(0xeadae6d2ea828c8a2306a1cc4dd966a244bc0e31ff49072cd839770ce5509055); /* statement */ \ndeadlineTicks = RollupTime.blocksToTicks(block.number) + challengePeriodTicks;\r\n    }\r\n\r\n    function asserterResponded() internal {coverage_0x94099878(0xd057e321aa46a06b8196d50c40e152d69c6b2570d224e98b8aa5bdd2ef4d3080); /* function */ \n\r\ncoverage_0x94099878(0x11a8f4fc2ae706c6ac3dd09618ea8eba6c373ed3c252d166d988599014896a8d); /* line */ \n        coverage_0x94099878(0x42e19cf10865da05fdada1bedc1962a99b89131f20aaa5c724030eabd18fc3db); /* statement */ \nstate = State.ChallengerTurn;\r\ncoverage_0x94099878(0xb4b2af746b989f1b5943cc9c53c41bd7223450d2a5d03ed30f5a5a35a0387f57); /* line */ \n        coverage_0x94099878(0xf4b1085604302a6f3e4608e84b28be11985af427436700be22cf43c65aaef096); /* statement */ \nupdateDeadline();\r\n    }\r\n\r\n    function challengerResponded() internal {coverage_0x94099878(0x187db1d01c864283cd168cad9a9825aaa024e2ec3c51b0927c2a810d73d7fd36); /* function */ \n\r\ncoverage_0x94099878(0x6b304771d59994189e09325f38e256dece88fc5aa562f6827c9843ea3a8ad8dd); /* line */ \n        coverage_0x94099878(0x2b1c037fb9b9c632376a69ea265b864c31d3383f08f4ca2493b084a5ab456c41); /* statement */ \nstate = State.AsserterTurn;\r\ncoverage_0x94099878(0xf9f5cd6bc60339ddf4b5bb18af260e50d7046ca6b1fa953c1e6cbfea167bb62b); /* line */ \n        coverage_0x94099878(0x31226d9a49f6210dfe2b1b7e8161f651a173c5f2adbfaba9a43364f06b2b5e12); /* statement */ \nupdateDeadline();\r\n    }\r\n\r\n    function _asserterWin() internal {coverage_0x94099878(0x0f5a9dcbcc9e6fb0506cc734c55b54e4934c8699f756e5be19830f10ab8b3cc9); /* function */ \n\r\ncoverage_0x94099878(0xd0f45fbccf4a1dcc5cbab16e036942efcb4a30639bcefc06be7d4d26100cf63c); /* line */ \n        coverage_0x94099878(0x2756e23e33166154fa3015fcaa520407888514147b14d5540e3bef6c52b628bc); /* statement */ \nIStaking(rollupAddress).resolveChallenge(asserter, challenger);\r\ncoverage_0x94099878(0x20a4bd2e6bc84a107e9f18287c1db946faebc9d3a55000f129335567b42c68c5); /* line */ \n        coverage_0x94099878(0xe301329b0abb04410a781f2edbd89376db5940addeb6fc45fe90f90550995862); /* statement */ \nsafeSelfDestruct(msg.sender);\r\n    }\r\n\r\n    function _challengerWin() internal {coverage_0x94099878(0x2b27c45758b7e60bface8716bf7ea57b5bf85898da5446049f9243055de36642); /* function */ \n\r\ncoverage_0x94099878(0xc30042442809afb35a0d2045878b73a90879ce553d1f6b39fb860b19d1bca75f); /* line */ \n        coverage_0x94099878(0x99f0e488015f82d048819ac709bf520030975fbbb6fc0f76b7168a550202f83f); /* statement */ \nIStaking(rollupAddress).resolveChallenge(challenger, asserter);\r\ncoverage_0x94099878(0xc5ba11d10afefb79310557ff40159226648133430ada1e72a4b898253cafc0fb); /* line */ \n        coverage_0x94099878(0x0ef5cd676a159bec399dd8c6ef7ecb887d54a5b492d3819d74f766f8a82dc662); /* statement */ \nsafeSelfDestruct(msg.sender);\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/rollup/IStaking.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\ninterface IStaking {\r\n    function resolveChallenge(address payable winner, address loser) external;\r\n}\r\n"
    },
    ".coverage_contracts/libraries/RollupTime.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nlibrary RollupTime {\nfunction coverage_0xce4be7f5(bytes32 c__0xce4be7f5) public pure {}\n\r\n    uint256 private constant TICKS_PER_BLOCK = 1000; // 1 tick == 1 milliblock\r\n\r\n    function ticksToBlocks(uint256 ticks) internal pure returns (uint128) {coverage_0xce4be7f5(0xb23bdd60d90744c75c5abd9561c79b753e62d145fda00ad6b807011b1751a68a); /* function */ \n\r\ncoverage_0xce4be7f5(0x8be42158f7b8267a82895bf462dc579ec4b19ba41f8e4de24df169f4e3583bc4); /* line */ \n        coverage_0xce4be7f5(0x1bdecfcec32dd6a01a1f71a651d4f3672c9298ae66d93daa0d1cb33cc6e734f7); /* statement */ \nreturn uint128(ticks / TICKS_PER_BLOCK);\r\n    }\r\n\r\n    function blocksToTicks(uint256 blockNum) internal pure returns (uint256) {coverage_0xce4be7f5(0x4d2453f533f007d13e85277051a4d4b1880c87c4fc2d61ee6c7d4512bf6d7a9a); /* function */ \n\r\ncoverage_0xce4be7f5(0xea54fa7687f3c475222c56fc2e7f53884737459099d53ec6013570a58829966a); /* line */ \n        coverage_0xce4be7f5(0xa0cf63d6c9505f8b38a2d019c4f8dcee66bb02df290ac379dcb80bb522d6c690); /* statement */ \nreturn uint256(blockNum) * TICKS_PER_BLOCK;\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/libraries/Cloneable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"./ICloneable.sol\";\r\n\r\ncontract Cloneable is ICloneable {\nfunction coverage_0xa4cceb08(bytes32 c__0xa4cceb08) public pure {}\n\r\n    string private constant NOT_CLONE = \"NOT_CLONE\";\r\n\r\n    bool private isMasterCopy;\r\n\r\n    constructor() public {coverage_0xa4cceb08(0x7f06c7f27b956d6cb0eca807cf096a993464679913cd678b30b173aac50e079b); /* function */ \n\r\ncoverage_0xa4cceb08(0x5aef7f0f10cb58021ec31d9246b9e96bfcee2c67419803fbe37932587c170ba6); /* line */ \n        coverage_0xa4cceb08(0xb2ed7cd8bf1d6897586819f7a7e7e072fc3517faea07e3c1469bc03476422d10); /* statement */ \nisMasterCopy = true;\r\n    }\r\n\r\n    function isMaster() external view returns (bool) {coverage_0xa4cceb08(0xee2e99190279b0d1519fd5eda5732201e786a5a79000b3e76c6570aa4d82a971); /* function */ \n\r\ncoverage_0xa4cceb08(0xb277b4265ed49ebcb908f4d613b23806e820efad2be64bd84c84d54bf65b43f1); /* line */ \n        coverage_0xa4cceb08(0x7e93f21ccd4ccd97d1e7b2f12fe982e33890ef757ab8eeb3aedaf30915e1b5f0); /* statement */ \nreturn isMasterCopy;\r\n    }\r\n\r\n    function safeSelfDestruct(address payable dest) internal {coverage_0xa4cceb08(0x071318d2858a8fdd71e34781ea4fac667b66f646223c2b1fc6c2802c10edae8d); /* function */ \n\r\ncoverage_0xa4cceb08(0x27bb68b4de882b395efad7fc3348c7598630c55a01eeff2f9a2f1a51f7ad092e); /* line */ \n        coverage_0xa4cceb08(0x3cd6b29a693149baca2518439c7e6121330e1e480f4bc8dc5887255017400fc3); /* assertPre */ \ncoverage_0xa4cceb08(0x54cb7281941c38ecfe5a1cad45afc6d6d5f6ac264822109794f077bbc7138f47); /* statement */ \nrequire(!isMasterCopy, NOT_CLONE);coverage_0xa4cceb08(0x30cf640ec6853e0b374ba39a47f74b37c3cbcdbafba234489c099eb05b090f9b); /* assertPost */ \n\r\ncoverage_0xa4cceb08(0x312d6a59e83c3b6beb1e777ad6c4ad2bf877b5680d94d0a1d9a5fbd0528e916e); /* line */ \n        coverage_0xa4cceb08(0x24e02ff370120c594d6456aa69314fd3e012a3004b977b72111b962170fdfb52); /* statement */ \nselfdestruct(dest);\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/libraries/ICloneable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\ninterface ICloneable {\r\n    function isMaster() external view returns (bool);\r\n}\r\n"
    },
    ".coverage_contracts/challenge/IBisectionChallenge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\ninterface IBisectionChallenge {\r\n    function initializeBisection(\r\n        address _rollupAddress,\r\n        address payable _asserter,\r\n        address payable _challenger,\r\n        uint256 _challengePeriodTicks,\r\n        bytes32 _challengeState\r\n    ) external;\r\n}\r\n"
    },
    ".coverage_contracts/libraries/MerkleLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nlibrary MerkleLib {\nfunction coverage_0x8d8db0d7(bytes32 c__0x8d8db0d7) public pure {}\n\r\n    function generateAddressRoot(address[] memory _addresses) internal pure returns (bytes32) {coverage_0x8d8db0d7(0x0734ad0739cbab21c8c2c8325a9155bde33d0b5d23c032ab80fc6cb75f2eced2); /* function */ \n\r\ncoverage_0x8d8db0d7(0xf9fca17adba72f0c08e4ddf4a4fee18fdf238cf193e390c7022f302e3b9cde4d); /* line */ \n        coverage_0x8d8db0d7(0xde70082cac920b6fa94a185a8eb5db0a29513d14c787ccd2a5ca327b81016c9f); /* statement */ \nbytes32[] memory _hashes = new bytes32[](_addresses.length);\r\ncoverage_0x8d8db0d7(0x9499b2886f54f5ab2d21d895567b1338486a54905eb0a6e3c4aa44ef5b4105ce); /* line */ \n        coverage_0x8d8db0d7(0x3fdc4973c303e41402009af8d12677adfd0dda3c7d9dfa8fefc44af0e57bf25c); /* statement */ \nfor (uint256 i = 0; i < _addresses.length; i++) {\r\ncoverage_0x8d8db0d7(0x908f93eabc9666268b451e7f843d91547485633df953542e573f8f664f5e2c78); /* line */ \n            coverage_0x8d8db0d7(0x6b9a4b1e942764fd1d136a9ba802914f758e936d8d3f2b7f37daa8398b6a8adb); /* statement */ \n_hashes[i] = bytes32(bytes20(_addresses[i]));\r\n        }\r\ncoverage_0x8d8db0d7(0x4956ca81d2df9d6bf037ba3ca3b7c71e7e685db6b590ac89e63cb0383d9e879b); /* line */ \n        coverage_0x8d8db0d7(0x73d07fd8958f6ef9c23eeb8cb8a39aaca3dfa796009db653ad7ec8f523be69ce); /* statement */ \nreturn generateRoot(_hashes);\r\n    }\r\n\r\n    function generateRoot(bytes32[] memory _hashes) internal pure returns (bytes32) {coverage_0x8d8db0d7(0x3c33cf32a1e361796a7bcd83044af2b2c448dd95063a67c107d855cc7c6f1be3); /* function */ \n\r\ncoverage_0x8d8db0d7(0x433681f81a4cfcda34705fdf1d6b9ec1b27b32b6d11da7fae27695457be1c4fc); /* line */ \n        coverage_0x8d8db0d7(0xf9f23212a8796899248f1c215767764252bf4d76e173582bd709e344bb274fe4); /* statement */ \nbytes32[] memory prevLayer = _hashes;\r\ncoverage_0x8d8db0d7(0x585f8eb0c273a63ebe369da0e01fa0f39698ec37ff15b90f04b8182a72cb0259); /* line */ \n        coverage_0x8d8db0d7(0x9d785665d2dd44a856f6788c43abce41dc118052ee6d3f4f08a356d4f1dad3c8); /* statement */ \nwhile (prevLayer.length > 1) {\r\ncoverage_0x8d8db0d7(0xa39abd5fef05b25d193ae228da924ccbe11f2c090781c45188e9fc4362ff2ab5); /* line */ \n            coverage_0x8d8db0d7(0xc6075f9e13bf34c7ca74d97053b706fb9b522c6cad02f12289eee061b84af71e); /* statement */ \nbytes32[] memory nextLayer = new bytes32[]((prevLayer.length + 1) / 2);\r\ncoverage_0x8d8db0d7(0xee7d7d1d39257d1dbec21d54fdd392359c7adc1ab8f211dad90c5ad1f94a591f); /* line */ \n            coverage_0x8d8db0d7(0xd608f071123f481751c67c376d90ff56574a72b9e6b27cf872e2038e957c9a27); /* statement */ \nfor (uint256 i = 0; i < nextLayer.length; i++) {\r\ncoverage_0x8d8db0d7(0x93f28f86eb880917f603094ef91b6c2a603af0f35d336fbb9e0ef2de8783f471); /* line */ \n                coverage_0x8d8db0d7(0x393753ac5034743b886c160748f43d69b669240f033c9912b64b12afb7c07432); /* statement */ \nif (2 * i + 1 < prevLayer.length) {coverage_0x8d8db0d7(0x20e0063e77640c1a1d91fbb656aaff4593df39619597cc341707a7ccd8995473); /* branch */ \n\r\ncoverage_0x8d8db0d7(0x69a64d20e06b1917d7e77bfc18f782cfd3c5e3545b846330d0d15e54510b623e); /* line */ \n                    coverage_0x8d8db0d7(0xfe98d107c04f5688d5ca85f17b168b530fda17e1bc128d678e18010a729d55ac); /* statement */ \nnextLayer[i] = keccak256(\r\n                        abi.encodePacked(prevLayer[2 * i], prevLayer[2 * i + 1])\r\n                    );\r\n                } else {coverage_0x8d8db0d7(0xfd62ec9f2d2319f5c17d4b306fbb9a68acbed7d805cff64dd0eb66634b787307); /* branch */ \n\r\ncoverage_0x8d8db0d7(0xca430e5fd0e3f9c28f45a0600bfd4953359a3712f3a192ea54599bd194ee1f98); /* line */ \n                    coverage_0x8d8db0d7(0x714b59dda099b21c03e4b876701739292f12c6375886f4aed7e9dc4700da9e61); /* statement */ \nnextLayer[i] = prevLayer[2 * i];\r\n                }\r\n            }\r\ncoverage_0x8d8db0d7(0x4602c77652dacdb0faea4877fcf1f9b6941afdd95c577a233e5487aea26b41e1); /* line */ \n            coverage_0x8d8db0d7(0x5d4049162ea39e14b404044e465d31df90046fe0db8dd5d43ccedd099e21a8be); /* statement */ \nprevLayer = nextLayer;\r\n        }\r\ncoverage_0x8d8db0d7(0x62e80b5fee669b9ac3f613004a9acd4f85086b308cac9629510aa955afdc8568); /* line */ \n        coverage_0x8d8db0d7(0x265d040ddc44ec37b8eec1bd02f911d73a7f44a07848dfbd7e7645b9478f9636); /* statement */ \nreturn prevLayer[0];\r\n    }\r\n\r\n    function verifyProof(\r\n        bytes memory proof,\r\n        bytes32 root,\r\n        bytes32 hash,\r\n        uint256 index\r\n    ) internal pure returns (bool) {coverage_0x8d8db0d7(0x06bcadff5068b7700d03a209d3e648694cb6c1a5682fedaf49e37bd2a6112daa); /* function */ \n\r\n        // use the index to determine the node ordering\r\n        // index ranges 1 to n\r\n\r\ncoverage_0x8d8db0d7(0xc0a1d9ec074695d14441e2deb3acc06103fa3d7dc78891647b3dea5a9ce1c036); /* line */ \n        coverage_0x8d8db0d7(0xcb7ce8c0bc6ffcc1c650b3f187d4faffbf4934a2d0bf3a7278357ebf494a3559); /* statement */ \nbytes32 el;\r\ncoverage_0x8d8db0d7(0xd11f8f1377bfa98243ef8f0ade3cd8f1af7d17cba8caafbdbb01ccd7ec1659c5); /* line */ \n        coverage_0x8d8db0d7(0x7938eaecd3663924a9a331043445bf6287ecd71643865e7ad5081ed9c143771c); /* statement */ \nbytes32 h = hash;\r\ncoverage_0x8d8db0d7(0xfc6675ebff1fb58c07ab0e36e9defe591384ddffd0102406c03c6087750a7258); /* line */ \n        coverage_0x8d8db0d7(0x68950ccdb05c0294b163d465e9e49662836e4ab3e646bc1e9fd3165acb1b2673); /* statement */ \nuint256 remaining;\r\n\r\ncoverage_0x8d8db0d7(0xbc617d9a2d9a069f2e76bee91fe6e1bb081aea62dac4badef2ccef3eb5dc358a); /* line */ \n        coverage_0x8d8db0d7(0x7efc1ff32c83596e9a539aae3d05adf2918c23f700efc1c7a6e75b1e320354d1); /* statement */ \nfor (uint256 j = 32; j <= proof.length; j += 32) {\r\n            // solhint-disable-next-line no-inline-assembly\r\ncoverage_0x8d8db0d7(0x42659a588b0d6f178cc1471b6f894eed98f6d6711cfc3bce2fa7b55018815fd6); /* line */ \n            assembly {\r\n                el := mload(add(proof, j))\r\n            }\r\n\r\n            // calculate remaining elements in proof\r\ncoverage_0x8d8db0d7(0x54103726a32f4c4e8ab6c15f8ce52aeaac2ccca7878c941c6a43dcf3504655ac); /* line */ \n            coverage_0x8d8db0d7(0x0b6b9126d219cca7c24f4c014ec690034b8c18ed876b634a100082b486fac313); /* statement */ \nremaining = (proof.length - j + 32) / 32;\r\n\r\n            // we don't assume that the tree is padded to a power of 2\r\n            // if the index is odd then the proof will start with a hash at a higher\r\n            // layer, so we have to adjust the index to be the index at that layer\r\ncoverage_0x8d8db0d7(0x881e45fad000c55924104ca70decc3a4a34d4085b1de6caad2c1403b2c51b7fc); /* line */ \n            coverage_0x8d8db0d7(0x078d01057b923de9b1e982e6b71d7822cf0ab34b05f93980654078a146d25ffc); /* statement */ \nwhile (remaining > 0 && index % 2 == 1 && index > 2**remaining) {\r\ncoverage_0x8d8db0d7(0x1ff1ffd5b7fe6202c3bfa7e16cd7a9d59a9b8bfcf94885f4141cb69999646297); /* line */ \n                coverage_0x8d8db0d7(0x42be2ab98b82b0af54eb414f3efc27870381919f2f2ac5646d71485c01e09b9f); /* statement */ \nindex = uint256(index) / 2 + 1;\r\n            }\r\n\r\ncoverage_0x8d8db0d7(0xa2045e81ed910d4318083f7a26b77443fcc71c136d8dc0fedd28f7b785783d21); /* line */ \n            coverage_0x8d8db0d7(0x00c524a521d9387afb52f578c61dbaae05d5036fc01675ddfa23e4a0803c3915); /* statement */ \nif (index % 2 == 0) {coverage_0x8d8db0d7(0x669c849132526f6ad21ba74663c226aefb83f8ca4149fc691898b8dc5d535825); /* branch */ \n\r\ncoverage_0x8d8db0d7(0x41fa7fa76074b11b5dbc7bd9ca8260b6f700dc9618f345694e4d8cd278c6c47b); /* line */ \n                coverage_0x8d8db0d7(0x4bc650277d3e124cccbf4007cf325a50b59cc992a4ca83be3fa1827272a4cb67); /* statement */ \nh = keccak256(abi.encodePacked(el, h));\r\ncoverage_0x8d8db0d7(0xb2cd9192ef6c93f7ba1c6ace171312e7336953523775e2aca1f7763461f428c8); /* line */ \n                coverage_0x8d8db0d7(0xd83bbd2d4a55c7bc7b9b0d0bd4305cb4aa739c5d5e738009d5b929e9874aea6c); /* statement */ \nindex = index / 2;\r\n            } else {coverage_0x8d8db0d7(0xc5e1a4f9751c1f4e18009de156a053b3a966416f2f1d7c24230e35fc318948bb); /* branch */ \n\r\ncoverage_0x8d8db0d7(0xe0cd0829f1e330aba88602894aa8fc6d158dc7f17bb719c4cf2a598197d30198); /* line */ \n                coverage_0x8d8db0d7(0xeb4b0ca22c6ee7ad030aaa1b94982dfe7d698f36bf50ab4c1d874fbbdb4462f1); /* statement */ \nh = keccak256(abi.encodePacked(h, el));\r\ncoverage_0x8d8db0d7(0x9d81e7432b188cbbdb8aec87f856e6876719ada81bf68a9f5270169618f9d24c); /* line */ \n                coverage_0x8d8db0d7(0x44b104ceaf746b820b86356fdde32a3d12a25ecedc1de221aa0d306965b73f95); /* statement */ \nindex = uint256(index) / 2 + 1;\r\n            }\r\n        }\r\n\r\ncoverage_0x8d8db0d7(0xdd8c63424391bb6705a9888c10fdc6411b8c8ac90d3aaccaca2a07395c17468d); /* line */ \n        coverage_0x8d8db0d7(0x4f90b56ab9bb42363d636a67e4a3361708d244a72790e0ad04e41793ab31673c); /* statement */ \nreturn h == root;\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/challenge/ChallengeFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../libraries/CloneFactory.sol\";\r\n\r\nimport \"./IChallengeFactory.sol\";\r\nimport \"./IBisectionChallenge.sol\";\r\nimport \"./IExecutionChallenge.sol\";\r\nimport \"./ChallengeUtils.sol\";\r\n\r\ncontract ChallengeFactory is CloneFactory, IChallengeFactory {\nfunction coverage_0x42c12958(bytes32 c__0x42c12958) public pure {}\n\r\n    // Invalid challenge type\r\n    string public constant INVALID_TYPE_STR = \"INVALID_TYPE\";\r\n\r\n    ICloneable public inboxTopChallengeTemplate;\r\n    ICloneable public executionChallengeTemplate;\r\n    address public oneStepProofAddress;\r\n\r\n    constructor(\r\n        address _inboxTopChallengeTemplate,\r\n        address _executionChallengeTemplate,\r\n        address _oneStepProofAddress\r\n    ) public {coverage_0x42c12958(0x7f6fd6d1d02e8885105b1501ed4cd9151391df9c42002fa3018174954eec408a); /* function */ \n\r\ncoverage_0x42c12958(0x4f2ca1386668bc483cd8227805dd3c016136b8f573e8ea6a5fe17d865c30f0c8); /* line */ \n        coverage_0x42c12958(0x366029d4730b46f6287758f81da00944b26098f0359e7496e681d08dd7d78be7); /* statement */ \ninboxTopChallengeTemplate = ICloneable(_inboxTopChallengeTemplate);\r\ncoverage_0x42c12958(0xfc7a55fca1e25d73618068012ec855de71cca2d64af80b32b3188c233f1de5d7); /* line */ \n        coverage_0x42c12958(0xf1f4352925e5b9efc2e36afa63b8b1cf3c8bb539dd2f4ca0531146ba11c01582); /* statement */ \nexecutionChallengeTemplate = ICloneable(_executionChallengeTemplate);\r\ncoverage_0x42c12958(0x7fefc5480c744c05d5757ae81c92e683763b165b6e3d9f397cba4d03bb4d982a); /* line */ \n        coverage_0x42c12958(0x10d44a7d8d3f4aea202ab3f1f5c2f045072630efbc175f8d64582beb7ca0dbd5); /* statement */ \noneStepProofAddress = _oneStepProofAddress;\r\n    }\r\n\r\n    function generateCloneAddress(\r\n        address asserter,\r\n        address challenger,\r\n        uint256 challengeType\r\n    ) public view returns (address) {coverage_0x42c12958(0x5de4de8172b5cc7c19f696e33984c162f4c7ca918eca86e3e1e5b69af5450b4c); /* function */ \n\r\ncoverage_0x42c12958(0xa60f7978a524fb9194cb4c13f87db4bc631dd4ac7f122ae525b2c7745e5ad9c0); /* line */ \n        coverage_0x42c12958(0xc84d2a3f5db0db92fa6dad54365b83069e9fc776a7ebd25e73dada3ab1bdd8ff); /* statement */ \nreturn\r\n            address(\r\n                uint160(\r\n                    uint256(\r\n                        keccak256(\r\n                            abi.encodePacked(\r\n                                bytes1(0xff),\r\n                                address(this),\r\n                                generateNonce(asserter, challenger),\r\n                                cloneCodeHash(getChallengeTemplate(challengeType))\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n    }\r\n\r\n    function createChallenge(\r\n        address payable _asserter,\r\n        address payable _challenger,\r\n        uint256 _challengePeriodTicks,\r\n        bytes32 _challengeHash,\r\n        uint256 challengeType\r\n    ) external returns (address) {coverage_0x42c12958(0xdb3ed5c6a38aa895260a6bc6d57054dc5369ff1f1f75deb855fc833626efd870); /* function */ \n\r\ncoverage_0x42c12958(0x133d8029704b493bcf4de3339958bc4cafe5d2a67890f4a6ddafe908def89450); /* line */ \n        coverage_0x42c12958(0x6761ebbc6eae908eaddf86e84ba6fd074006f2104b4f949facb9543be6fcf029); /* statement */ \nICloneable challengeTemplate = getChallengeTemplate(challengeType);\r\ncoverage_0x42c12958(0xe7374abef977655ad2228fc1c918ab313197b31b4b41facc8fdf90354c8e9427); /* line */ \n        coverage_0x42c12958(0xc5819f8049d7aec4045c8ce52ab5c5abb7080dc9d6b60d4bf2eab2107d3dad23); /* statement */ \naddress clone = createClone(challengeTemplate);\r\ncoverage_0x42c12958(0x43dbeb3b58a59c761afa2c4c124046ceb04ada6acabd9d529c2e6c0dcd12d282); /* line */ \n        coverage_0x42c12958(0x453bea87b305c12c15bf47eac804e9ba3b6d80cf0b1ec1830bd6e5119d62ee40); /* statement */ \nIBisectionChallenge(clone).initializeBisection(\r\n            msg.sender,\r\n            _asserter,\r\n            _challenger,\r\n            _challengePeriodTicks,\r\n            _challengeHash\r\n        );\r\n\r\ncoverage_0x42c12958(0xd8cdd808a8c7038a9fe0af3038aca17404ba24b255475e05c04b41c7fe1c947f); /* line */ \n        coverage_0x42c12958(0x34c30396085e7daa8bc61bd769ed62fa2fc3924ff359fda49f0cab092cf5cca2); /* statement */ \nif (challengeType == ChallengeUtils.getInvalidExType()) {coverage_0x42c12958(0xe238e7d10dba3eac67b29e724f678798019ca31389d880934814e5df07610cdf); /* branch */ \n\r\ncoverage_0x42c12958(0x0a1caad2a4f8c780a1aea107501dc2c85f9348ed7dca9a21b72bb695bcd322a6); /* line */ \n            coverage_0x42c12958(0xf91a32be7301d67f8f13691e3c2088e6f5bfc3c6a037aa4ccde2c0f6ab50b728); /* statement */ \nIExecutionChallenge(clone).connectOneStepProof(oneStepProofAddress);\r\n        }else { coverage_0x42c12958(0x7e6df2deabf6c93562b7b493b12eece2a6bc8ec6c8e215d72d858530e57a678c); /* branch */ \n}\r\ncoverage_0x42c12958(0xca8c382fec76c01b9c08cbd45d0562ca72ff8ef46867efeb1e6d0ffa81432c82); /* line */ \n        coverage_0x42c12958(0x6276935d90494ec3489d046595a8fbc6ab300698f84f9783c8eb875eda1a84f8); /* statement */ \nreturn address(clone);\r\n    }\r\n\r\n    function generateNonce(address asserter, address challenger) private view returns (uint256) {coverage_0x42c12958(0x49928dca2b92225666318f3b4d0d6c3bad64198b849b159f778097714b208f30); /* function */ \n\r\ncoverage_0x42c12958(0xd233bf48f4ae8665f4816ab92fd9394b330550a5d53fb7596e91915542b05f47); /* line */ \n        coverage_0x42c12958(0x5ed7252ce4dd59d36dd8a113fb091dc7507ae0f9387480f1a5bb0a8c0761e2f8); /* statement */ \nreturn uint256(keccak256(abi.encodePacked(asserter, challenger, msg.sender)));\r\n    }\r\n\r\n    function getChallengeTemplate(uint256 challengeType) private view returns (ICloneable) {coverage_0x42c12958(0xc52d5e2b5bee25f56ae05453945afb21c2534d32367b3fa7f5c83ac46544d37f); /* function */ \n\r\ncoverage_0x42c12958(0xe76c969ce55c1e10e595deb0fa9df48448c267c86aaff398e8a74608c3365ec4); /* line */ \n        coverage_0x42c12958(0x41c9b57fee5ada00caa84dc9cc95163c1d609ab3de2c958b7474a0af2260f4c2); /* statement */ \nif (challengeType == ChallengeUtils.getInvalidInboxType()) {coverage_0x42c12958(0xf9e11f3655f8f00d0cf99e966a4acec0554fa23c188fcfac9593e43a25278c9a); /* branch */ \n\r\ncoverage_0x42c12958(0x627ff51335a517502ccd38111eea5cd8d32940183329c136444acaf498cf99c8); /* line */ \n            coverage_0x42c12958(0xeeab48c55fec1db1806d86cf05c07ede9a2ab0959308a7edf66b66d4dbf1e7f1); /* statement */ \nreturn inboxTopChallengeTemplate;\r\n        } else {coverage_0x42c12958(0xe8a2990c2dee6d8f608d44c76c32056dfbca535e0d203b4d43aeb57f72fda37f); /* statement */ \ncoverage_0x42c12958(0xdaf01872af4623664cc34d57b9266c2fa81e1baf80e38fee5ccc27c611da178a); /* branch */ \nif (challengeType == ChallengeUtils.getInvalidExType()) {coverage_0x42c12958(0x058e1840fb3d57a7c2d3fd8daf7cea4d04668f697617496b6e91633df72d19a9); /* branch */ \n\r\ncoverage_0x42c12958(0xf9abb32577ef9474650cc93ea4a4659e43ac3056ee5ba7d6dd22ed42c23547a1); /* line */ \n            coverage_0x42c12958(0xdff102452e0dc649caf9f96a1abad8a0e4cfdbab2a7b29c9736faf2620c63ffd); /* statement */ \nreturn executionChallengeTemplate;\r\n        } else {coverage_0x42c12958(0xbbcd17c85a6faa2cf1d4ed4eab5294fd241dff7c07bbe7678552a08370740b85); /* branch */ \n\r\ncoverage_0x42c12958(0xf08e74666c9db74417fd60515043f746b660d4912987e67689f7f84bda8f7833); /* line */ \n            coverage_0x42c12958(0x79cca702cc35c23aba8d163dc07ed018719a700e7805719d677d4979f319f6cd); /* assertPre */ \ncoverage_0x42c12958(0xf47d9fef41e3f3638b97c52afb2a7b53934f3821abb26e552926e77676794710); /* statement */ \nrequire(false, INVALID_TYPE_STR);coverage_0x42c12958(0xfe55df12a186dad1ad857e7e9bbe4088caa772ff87f2638f6fba800b3416d0c8); /* assertPost */ \n\r\n        }}\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/libraries/CloneFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n// Taken from https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2018 Murray Software, LLC.\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n//solhint-disable max-line-length\r\n//solhint-disable no-inline-assembly\r\n\r\nimport \"./ICloneable.sol\";\r\n\r\ncontract CloneFactory {\nfunction coverage_0x1c465d00(bytes32 c__0x1c465d00) public pure {}\n\r\n    string private constant CLONE_MASTER = \"CLONE_MASTER\";\r\n\r\n    function createClone(ICloneable target) internal returns (address result) {coverage_0x1c465d00(0x957e71d89ca73c93e8f445ee81774d3516cb72a2d24c3ef8c68d5ea95e8f8986); /* function */ \n\r\ncoverage_0x1c465d00(0x8a2b34f4d7cfafcf8b1b56af5c425ac15c504bb2aa0b5bf6e9cd8ab7caef6ce8); /* line */ \n        coverage_0x1c465d00(0xe6c5316e33723fd66c4c2698a58f0f9c5e69eae08fbab9fbafd651ecb2ba74ee); /* assertPre */ \ncoverage_0x1c465d00(0x537256a85cb7a02ddfdc6997d3bcd1e31d689e9a47e1aba78c5f2cb04557b867); /* statement */ \nrequire(target.isMaster(), CLONE_MASTER);coverage_0x1c465d00(0x0615383ee871f40de35de4354026fc5fd71e1a3803ff5ae1afb7fbdd0510c85c); /* assertPost */ \n\r\ncoverage_0x1c465d00(0x9c857e62c3242ef34bbc2e981437300f97cf9f678e174c756c66c04af76c438b); /* line */ \n        coverage_0x1c465d00(0xccdec83cf1dd88004a78653f414e07e8b67275b06f503a16393e88b4b8f3118f); /* statement */ \nbytes20 targetBytes = bytes20(address(target));\r\ncoverage_0x1c465d00(0x6dfc997c60b70ced87da2eb379d4a06078e2e4a42ec224e43de3208655248d63); /* line */ \n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(\r\n                add(clone, 0x28),\r\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n            )\r\n            result := create(0, clone, 0x37)\r\n        }\r\n    }\r\n\r\n    function create2Clone(ICloneable target, bytes32 salt) internal returns (address result) {coverage_0x1c465d00(0x63860ed830c9e6d677294a1ca50c6564583e42bfb92fac5408c2534b34c87729); /* function */ \n\r\ncoverage_0x1c465d00(0x1e8a0504e681fdb214568137c46c689b8be3df7acaa3aa05bfac3ae5f14948d3); /* line */ \n        coverage_0x1c465d00(0x39f757416ed67e95aa45e444448e74e65d21d6f3460e5d16443aa208f465acbb); /* assertPre */ \ncoverage_0x1c465d00(0x536ff565c37bbab71e9d4a89e02a739cdbd425277d7147f728741fb43ea6dfe0); /* statement */ \nrequire(target.isMaster(), CLONE_MASTER);coverage_0x1c465d00(0x6aded29a877f48895f56234e59b659d5f0d3a7d12343df18447d7368e2d323cb); /* assertPost */ \n\r\ncoverage_0x1c465d00(0x7355885c3eb17f76e11b4635df909957cf7771779938e60b2811755b39de14b0); /* line */ \n        coverage_0x1c465d00(0x9c5bcda7b6d94823875fa4954b28addc8820d06dbaecd6186968826552b3ef9f); /* statement */ \nbytes20 targetBytes = bytes20(address(target));\r\ncoverage_0x1c465d00(0xced5b5f9c92408e5140afaf95967c42d428a950884c7913065463482cef34899); /* line */ \n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(\r\n                add(clone, 0x28),\r\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n            )\r\n            result := create2(0, clone, 0x37, salt)\r\n        }\r\n    }\r\n\r\n    function isClone(ICloneable target, address query) internal view returns (bool result) {coverage_0x1c465d00(0xf99697daafe74a232ad7aaa0e91bf2a2b04b7a227ea04f376c1b9d4a2bc45765); /* function */ \n\r\ncoverage_0x1c465d00(0x9c41d33766ae81cf135ed8ba1da6ceea189349321a882ab276fb3ec5de21dc89); /* line */ \n        coverage_0x1c465d00(0x986856db34794308dc15b924dc7ae84aa643864e6ab0a5a89dc27b7d328596d3); /* statement */ \nbytes20 targetBytes = bytes20(address(target));\r\ncoverage_0x1c465d00(0xa656c3f627f8fd7569aa8383e8b2b6bef09bace983dc80bbf7e7a91876b42992); /* line */ \n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\r\n            mstore(add(clone, 0xa), targetBytes)\r\n            mstore(\r\n                add(clone, 0x1e),\r\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n            )\r\n\r\n            let other := add(clone, 0x40)\r\n            extcodecopy(query, other, 0, 0x2d)\r\n            result := and(\r\n                eq(mload(clone), mload(other)),\r\n                eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\r\n            )\r\n        }\r\n    }\r\n\r\n    function cloneCodeHash(ICloneable target) internal pure returns (bytes32 result) {coverage_0x1c465d00(0xf2ead90fb2d45940e0b733ded7b39425606309aeb6131a4d4bb5a1e666c410f2); /* function */ \n\r\ncoverage_0x1c465d00(0x36e99b9bf009e82dbb6e8fa3bc6819e5ad66b95fb9dd5a2a34caf6bb6f87606c); /* line */ \n        coverage_0x1c465d00(0x476314c952853fb1984e52455e3117d764101f472c554f5dd8e34ccbc76d8e1c); /* statement */ \nbytes20 targetBytes = bytes20(address(target));\r\ncoverage_0x1c465d00(0xcf0e91cbda9d59f6ec3bc21db0acb4b7f5628bb2d03df73765e4f6d559da74f1); /* line */ \n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(\r\n                add(clone, 0x28),\r\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n            )\r\n            result := keccak256(clone, 0x37)\r\n        }\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/challenge/IChallengeFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\ninterface IChallengeFactory {\r\n    function createChallenge(\r\n        address payable _asserter,\r\n        address payable _challenger,\r\n        uint256 _challengePeriodTicks,\r\n        bytes32 _challengeHash,\r\n        uint256 challengeType\r\n    ) external returns (address);\r\n\r\n    function generateCloneAddress(\r\n        address asserter,\r\n        address challenger,\r\n        uint256 challengeType\r\n    ) external view returns (address);\r\n}\r\n"
    },
    ".coverage_contracts/challenge/IExecutionChallenge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\ninterface IExecutionChallenge {\r\n    function connectOneStepProof(address oneStepProof) external;\r\n}\r\n"
    },
    ".coverage_contracts/challenge/ChallengeUtils.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nlibrary ChallengeUtils {\nfunction coverage_0x84104f58(bytes32 c__0x84104f58) public pure {}\n\r\n    uint256 public constant INVALID_INBOX_TOP_TYPE = 0;\r\n    uint256 public constant INVALID_EXECUTION_TYPE = 1;\r\n    uint256 public constant VALID_CHILD_TYPE = 2;\r\n\r\n    function getInvalidInboxType() internal pure returns (uint256) {coverage_0x84104f58(0x6a67646a2625981085d879f42be358955b165cef60418e4e84b78f4fb70a72f6); /* function */ \n\r\ncoverage_0x84104f58(0x96c4a7354fa4937a511997861091e86385e63c3eb67e5f5d8abb9154fff6087c); /* line */ \n        coverage_0x84104f58(0xd593cfe5ffb6a4a6819fa2922aa77daaee0d56dc9709037a86c4ab811ed57af5); /* statement */ \nreturn INVALID_INBOX_TOP_TYPE;\r\n    }\r\n\r\n    function getInvalidExType() internal pure returns (uint256) {coverage_0x84104f58(0x1365d6183bb397a6e2159e9e9a9c29746f0f9f11103cb2021407289ce4dbd79f); /* function */ \n\r\ncoverage_0x84104f58(0x41034e62ed3c940e58c9c1e0827f4f30411569cf458279f085f97a66d0e9e33e); /* line */ \n        coverage_0x84104f58(0xaf912f26dc9814ddadaeb3b02d4102c6f724cb14e56f18d181be9d7e3c351999); /* statement */ \nreturn INVALID_EXECUTION_TYPE;\r\n    }\r\n\r\n    function getValidChildType() internal pure returns (uint256) {coverage_0x84104f58(0xad3b8098093609ee987ee9f187929212e4d9f5c6cd08764af24d937ba8a7aba7); /* function */ \n\r\ncoverage_0x84104f58(0x0585f4c98387d8f5a1f8c0a304a0487734d1f7a1f527f81bab831aae59e9cf7d); /* line */ \n        coverage_0x84104f58(0xd7c5cae4362614ee36a7c8092f724404c192021c00211b243e9ae6854c509049); /* statement */ \nreturn VALID_CHILD_TYPE;\r\n    }\r\n\r\n    function inboxTopHash(\r\n        bytes32 _lowerHash,\r\n        bytes32 _topHash,\r\n        uint256 _chainLength\r\n    ) internal pure returns (bytes32) {coverage_0x84104f58(0xe17cbc141f8287b72a50ab25340117290bdf4e94da4053082a38f0e8efbd8e43); /* function */ \n\r\ncoverage_0x84104f58(0xf5e29479ea5b22d2b9787840e7ee566df7501107327126960ead25293815f134); /* line */ \n        coverage_0x84104f58(0xb1230632bdd6804e3e2d5bfa56b37081c499ff6eeba4376b0da05bf5fb749f36); /* statement */ \nreturn keccak256(abi.encodePacked(_lowerHash, _topHash, _chainLength));\r\n    }\r\n\r\n    struct ExecutionAssertion {\r\n        uint64 numSteps;\r\n        uint64 numArbGas;\r\n        bytes32 beforeMachineHash;\r\n        bytes32 afterMachineHash;\r\n        bytes32 beforeInboxHash;\r\n        bytes32 afterInboxHash;\r\n        bytes32 firstMessageHash;\r\n        bytes32 lastMessageHash;\r\n        uint64 messageCount;\r\n        bytes32 firstLogHash;\r\n        bytes32 lastLogHash;\r\n        uint64 logCount;\r\n    }\r\n\r\n    function hash(ExecutionAssertion memory assertion) internal pure returns (bytes32) {coverage_0x84104f58(0x02cab0eb21b30507e321cf572847febbd07815ceb067c3b6cac698bd70a51da1); /* function */ \n\r\ncoverage_0x84104f58(0x608763fbcfedac601f3f7741aa123fa3530be84ee991253496470c897d581db4); /* line */ \n        coverage_0x84104f58(0xd42fc37361e423f35008d6a01678f9de85a3f18812d92eac7187f47a96d14852); /* statement */ \nreturn\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    assertion.numSteps,\r\n                    assertion.numArbGas,\r\n                    assertion.beforeMachineHash,\r\n                    assertion.afterMachineHash,\r\n                    assertion.beforeInboxHash,\r\n                    assertion.afterInboxHash,\r\n                    assertion.firstMessageHash,\r\n                    assertion.lastMessageHash,\r\n                    assertion.messageCount,\r\n                    assertion.firstLogHash,\r\n                    assertion.lastLogHash,\r\n                    assertion.logCount\r\n                )\r\n            );\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/challenge/ExecutionChallenge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"./IExecutionChallenge.sol\";\r\nimport \"./BisectionChallenge.sol\";\r\nimport \"./ChallengeUtils.sol\";\r\n\r\nimport \"../arch/IOneStepProof.sol\";\r\n\r\nimport \"../libraries/MerkleLib.sol\";\r\n\r\ncontract ExecutionChallenge is IExecutionChallenge, BisectionChallenge {\nfunction coverage_0x06d0f4ef(bytes32 c__0x06d0f4ef) public pure {}\n\r\n    using ChallengeUtils for ChallengeUtils.ExecutionAssertion;\r\n\r\n    event BisectedAssertion(bytes32[] assertionHashes, uint256 deadlineTicks);\r\n\r\n    event OneStepProofCompleted();\r\n\r\n    IOneStepProof private executor;\r\n\r\n    // Incorrect previous state\r\n    string private constant BIS_INPLEN = \"BIS_INPLEN\";\r\n    // Proof was incorrect\r\n    string private constant OSP_PROOF = \"OSP_PROOF\";\r\n\r\n    struct BisectAssertionData {\r\n        bytes32[] machineHashes;\r\n        bytes32[] inboxAccs;\r\n        bytes32[] messageAccs;\r\n        bytes32[] logAccs;\r\n        uint64[] outCounts;\r\n        uint64[] gases;\r\n        uint64 totalSteps;\r\n    }\r\n\r\n    function connectOneStepProof(address oneStepProof) external {coverage_0x06d0f4ef(0x4fb6502ab671983150d280708b9ccd7b04af043418c927d003bf5a33d8ffe1c8); /* function */ \n\r\ncoverage_0x06d0f4ef(0x279c5884e84952a587542cfaa6da23ecd4bd00119db65b05868ddd0356e2622a); /* line */ \n        coverage_0x06d0f4ef(0x4b63712e79957e99829fbebd46db41798007c1dcd5d0605b4b72c2ecd401a30c); /* statement */ \nexecutor = IOneStepProof(oneStepProof);\r\n    }\r\n\r\n    function bisectAssertion(\r\n        bytes32[] memory _machineHashes,\r\n        bytes32[] memory _inboxAccs,\r\n        bytes32[] memory _messageAccs,\r\n        bytes32[] memory _logAccs,\r\n        uint64[] memory _outCounts,\r\n        uint64[] memory _gases,\r\n        uint64 _totalSteps\r\n    ) public asserterAction {coverage_0x06d0f4ef(0xaca783054d6502288f5dd5bc4ad4b8f0e6d69280e1527b0e3ea83ff22b999611); /* function */ \n\r\ncoverage_0x06d0f4ef(0x403e1d0504602186601a1dbdc896e23701907fd6906e65eb8b26ebd4ebcce11a); /* line */ \n        coverage_0x06d0f4ef(0xfed517b91ea83fe57f39ded40c788dea1bef568fa1ea9e53791cf3f22f2b7ee3); /* statement */ \nBisectAssertionData memory bisection = BisectAssertionData(\r\n            _machineHashes,\r\n            _inboxAccs,\r\n            _messageAccs,\r\n            _logAccs,\r\n            _outCounts,\r\n            _gases,\r\n            _totalSteps\r\n        );\r\ncoverage_0x06d0f4ef(0x3926215e2fcc78b29ed0cc91055e2c442803b0ed487b9162913538fe63ea0c22); /* line */ \n        coverage_0x06d0f4ef(0xe0ad02222c76367b723ff615633bbbe4b2b97e7600015b08b15d88628f73d1d1); /* statement */ \n_bisectAssertion(bisection);\r\n    }\r\n\r\n    function _checkBisectionPrecondition(BisectAssertionData memory _data) private view {coverage_0x06d0f4ef(0x688424b9a38dbaaade5d734690dabcd385cd5163ea1716d24c02290cc8a0e5f6); /* function */ \n\r\ncoverage_0x06d0f4ef(0xfd4f776acb88647f8283ef89d5be6099a4cbe91b51c6e0368a9b17cfdc545615); /* line */ \n        coverage_0x06d0f4ef(0x4d3dd9d31fac79987c59a0155986dffd8b01056d48444e08712736439dba079f); /* statement */ \nuint256 bisectionCount = _data.machineHashes.length - 1;\r\ncoverage_0x06d0f4ef(0x155ade10eb6140461d94b8429b80e08071cf6bb0a7b37cfeaa794e035872a8fe); /* line */ \n        coverage_0x06d0f4ef(0xfa04fab7fb3e3183f630e0145ad7775ab8380c4ba7904a2dc159ec3e66f549ee); /* assertPre */ \ncoverage_0x06d0f4ef(0xbb48e8cbf9314dac1e6a1861259de388d7a03fc8c5a2a988f45cbb7b0a6ba79d); /* statement */ \nrequire(bisectionCount + 1 == _data.inboxAccs.length, BIS_INPLEN);coverage_0x06d0f4ef(0x2f43f517f780f0a1637207ffc6749e829e6be8abe266dc469884a6d6a029f6f4); /* assertPost */ \n\r\ncoverage_0x06d0f4ef(0xb0d56cae432df0cfdfbed4aa59286707e11a76a4663a2fcc8a1befe34dd0c0bc); /* line */ \n        coverage_0x06d0f4ef(0x9895d64b573d3e976e5fde72716af6b125d870713bb0aebde108e49794fab80f); /* assertPre */ \ncoverage_0x06d0f4ef(0x59ed9f8121581406655f2045e951966a0d8ec8ec611c5d27ec38d96edc11b403); /* statement */ \nrequire(bisectionCount + 1 == _data.messageAccs.length, BIS_INPLEN);coverage_0x06d0f4ef(0xf7e922a67d05855071f6585dc9c26da90c20cb1266e2392e8a4f89241696553c); /* assertPost */ \n\r\ncoverage_0x06d0f4ef(0x3b2c76751379a75364eee2b7ae20626e070cd82954b0ad004bba9fe4608927bb); /* line */ \n        coverage_0x06d0f4ef(0x913ad12a79ee6b4575636e381dc75b89e588e76aec9e881a1f685f2866652ab4); /* assertPre */ \ncoverage_0x06d0f4ef(0x938a326889ceb41a6a9a0feac5bbbfc1fdae38c25a53f57568cf0acd1231db4e); /* statement */ \nrequire(bisectionCount + 1 == _data.logAccs.length, BIS_INPLEN);coverage_0x06d0f4ef(0xe3e8fb0be60d9229c1f4dc5c3f81881b380665bed0d0a1fc7e4d11af73c79f62); /* assertPost */ \n\r\ncoverage_0x06d0f4ef(0x4f27c57a14112f758c1bfbbc9f3485b2faef13b34e7fbd1be6ff45e3ec258e3a); /* line */ \n        coverage_0x06d0f4ef(0x664b7d7b4c572b1924180aad2cb8b9ce1f12610e4e8f3d36fc11c9b2be5575b5); /* assertPre */ \ncoverage_0x06d0f4ef(0x17e43bf8829e673a869964bb615347adaec1d5929612d2c1eb3722bdf8489931); /* statement */ \nrequire(bisectionCount == _data.gases.length, BIS_INPLEN);coverage_0x06d0f4ef(0xfdeeecf09ba83e2bca3002b83495616466b3b1b943d93c196e878d099460b203); /* assertPost */ \n\r\ncoverage_0x06d0f4ef(0x1bbaeeb15ea2f5446677eebaed23ae41b0c3a2136435584a78dd0d5a5e0273b8); /* line */ \n        coverage_0x06d0f4ef(0x0744b2aeba96d598bed724b7fcd990cd001ef52cc935416a8f5581c5572a630a); /* assertPre */ \ncoverage_0x06d0f4ef(0x0cddc8f56a3a3fe1fc28d3aba0ac490d9d24c39f3537f765f2c7255f3935fa75); /* statement */ \nrequire(bisectionCount * 2 == _data.outCounts.length, BIS_INPLEN);coverage_0x06d0f4ef(0xac03473e31aa4eb6fc3b2b41351d15fc26b7bf3f5b34ba552cd50db84de7a05f); /* assertPost */ \n\r\ncoverage_0x06d0f4ef(0xfff68735e0229188ebeeb34a61105d04393686f6c2dd0d99382215ba1eea33c7); /* line */ \n        coverage_0x06d0f4ef(0x7745addee59e2d422d53e69ee75b605dbc788f3de793162a00f75d381f2f66e3); /* statement */ \nuint64 totalGas = 0;\r\ncoverage_0x06d0f4ef(0x3c0aea219632ea1742bcfba8ca9780c1e7e32f92beb796074f12f85f434c8a36); /* line */ \n        coverage_0x06d0f4ef(0xf0f09bb459a34432b90971ceafca5691944edcd9e3f465c8c15814f531472573); /* statement */ \nuint64 totalMessageCount = 0;\r\ncoverage_0x06d0f4ef(0xb9d92fc55c30510d140b608f249efd9c101f63cfe5c8a5233c6b35b71e7ca477); /* line */ \n        coverage_0x06d0f4ef(0x6a637985e6aca5f583117ffd3238b2e13ee65e6529946ea41932938ea05c46ba); /* statement */ \nuint64 totalLogCount = 0;\r\ncoverage_0x06d0f4ef(0x0732dbfcf50948abad1a4e9e0ab12cd5064b2bd4465d3f343deb34b30510951a); /* line */ \n        coverage_0x06d0f4ef(0x329a032cd25d31ccc51289f1aa3a164c033ee32a569c6e2aca05e3eb57a555ce); /* statement */ \nfor (uint256 i = 0; i < bisectionCount; i++) {\r\ncoverage_0x06d0f4ef(0xca7a2cc0115cb8a4228337d822c0b3e44d7f8673d859085d4726ef5ac4cc34b8); /* line */ \n            coverage_0x06d0f4ef(0x4c01ae453063fef0bfa318a23babf822fde75a5360cd94b4829632ce54bc00a4); /* statement */ \ntotalGas += _data.gases[i];\r\ncoverage_0x06d0f4ef(0xf3dedec569ac58449286b7f53c6ba78f565e468e4166834e1847a0ceaf747f8f); /* line */ \n            coverage_0x06d0f4ef(0xd17575918971b33ae98a4b29a06f5079019e5b3a1a497bbad9b17e8e8b51117b); /* statement */ \ntotalMessageCount += _data.outCounts[i];\r\ncoverage_0x06d0f4ef(0xd13d1e0f1ea413973a94420462189094dd883b99ee368440c15db6a9a42b9651); /* line */ \n            coverage_0x06d0f4ef(0x94bc4bc66d7277e7380342058ff493a8a84d9b7f1201ed800e46a2cae35986a2); /* statement */ \ntotalLogCount += _data.outCounts[bisectionCount + i];\r\n        }\r\n\r\ncoverage_0x06d0f4ef(0x7ae3719f31697dbb0624be19e53614bdb106402aa56475b06c1aa7871c819aba); /* line */ \n        coverage_0x06d0f4ef(0xd4e0990aa5e23db7e3ff6367578f088cf59c21cb78fbb61f30dbbf35441814aa); /* statement */ \nrequireMatchesPrevState(\r\n            _generateAssertionHash(\r\n                _data,\r\n                _data.totalSteps,\r\n                0,\r\n                bisectionCount,\r\n                totalGas,\r\n                totalMessageCount,\r\n                totalLogCount\r\n            )\r\n        );\r\n    }\r\n\r\n    function _generateBisectionHash(\r\n        BisectAssertionData memory data,\r\n        uint64 stepCount,\r\n        uint256 bisectionCount,\r\n        uint256 i\r\n    ) private pure returns (bytes32) {coverage_0x06d0f4ef(0xfd5260284b1786df5dcf498f7a96b86118325c2d68a9e5ad561751cafb78d162); /* function */ \n\r\ncoverage_0x06d0f4ef(0xe8df15b113d4ccd34714d9c648b07e3c9c889a79a7e4b0901dd10807b9952233); /* line */ \n        coverage_0x06d0f4ef(0xf8731435b2b6531de2d732271d6fcb3ca5aa9557d042fe4027806be97e356b42); /* statement */ \nreturn\r\n            _generateAssertionHash(\r\n                data,\r\n                stepCount,\r\n                i,\r\n                i + 1,\r\n                data.gases[i],\r\n                data.outCounts[i],\r\n                data.outCounts[bisectionCount + i]\r\n            );\r\n    }\r\n\r\n    function _generateAssertionHash(\r\n        BisectAssertionData memory data,\r\n        uint64 stepCount,\r\n        uint256 start,\r\n        uint256 end,\r\n        uint64 gas,\r\n        uint64 messageCount,\r\n        uint64 logCount\r\n    ) private pure returns (bytes32) {coverage_0x06d0f4ef(0x1cc8252642402fd609c357c171d9538543636f934a854a42bc5806c05316bbc4); /* function */ \n\r\ncoverage_0x06d0f4ef(0xd5d2b979d391603c964af976ab7593b4c1f0190ca998d8016f1934fb85539a2b); /* line */ \n        coverage_0x06d0f4ef(0xe536daf6aa2843dcd32272ccd3a2934ce7fa53125f9e237905238b80cbb56364); /* statement */ \nreturn\r\n            ChallengeUtils\r\n                .ExecutionAssertion(\r\n                stepCount,\r\n                gas,\r\n                data.machineHashes[start],\r\n                data.machineHashes[end],\r\n                data.inboxAccs[start],\r\n                data.inboxAccs[end],\r\n                data.messageAccs[start],\r\n                data.messageAccs[end],\r\n                messageCount,\r\n                data.logAccs[start],\r\n                data.logAccs[end],\r\n                logCount\r\n            )\r\n                .hash();\r\n    }\r\n\r\n    function _bisectAssertion(BisectAssertionData memory _data) private {coverage_0x06d0f4ef(0xd00ac0773f7c8d7e339dab425e59a625241d4338b060d548b680bddc9849655e); /* function */ \n\r\ncoverage_0x06d0f4ef(0x1ce09f549ff7d22142cd4574858e89762da28d9b58da202ef94364c04f9aa93b); /* line */ \n        coverage_0x06d0f4ef(0x79ebd83adfd940eb482a9fdf71a549d4baf96686c0df090ca717fd10f4860856); /* statement */ \nuint256 bisectionCount = _data.machineHashes.length - 1;\r\ncoverage_0x06d0f4ef(0x76cef6f9b12055ddb92731003e5271c06a61076a27e52bc9b0bd510d1f812d91); /* line */ \n        coverage_0x06d0f4ef(0x8f529edbc06244b2ff1c926c92e70a981b461e91b45a28faa1958db0f7d28cf8); /* statement */ \n_checkBisectionPrecondition(_data);\r\ncoverage_0x06d0f4ef(0x033ff520a185b198ea6feeaeac95af53a49d90e9b6cd0c8f7cfbc9ede926b390); /* line */ \n        coverage_0x06d0f4ef(0x4a0ffd2cecb6d168f80ec328e6f5b1655f241e4521b297fa424f82f5386726ef); /* statement */ \nbytes32[] memory hashes = new bytes32[](bisectionCount);\r\ncoverage_0x06d0f4ef(0x694978b210a3538f583ea3d64bec7c974a140d7f526d548feed8b0d27c3d73cd); /* line */ \n        coverage_0x06d0f4ef(0x4c8a385225f75b173fe9d08beb5bd0a655bb800c66d44ece1767b6303cbe3359); /* statement */ \nhashes[0] = _generateBisectionHash(\r\n            _data,\r\n            uint64(firstSegmentSize(uint256(_data.totalSteps), bisectionCount)),\r\n            bisectionCount,\r\n            0\r\n        );\r\ncoverage_0x06d0f4ef(0x83af8357c100e16a32efcbf517e5d0c651fcea4c84b44890f1927784acbd647c); /* line */ \n        coverage_0x06d0f4ef(0xdfadd1e75a9c6be7ba1bdff9ea664c1cbeda64b8bf50d1807316553452b8a876); /* statement */ \nfor (uint256 i = 1; i < bisectionCount; i++) {\r\ncoverage_0x06d0f4ef(0x3c5456d31de1db652e6d256a43f0968db6200c3b3c0ddb6bb53bf14118f45e0a); /* line */ \n            coverage_0x06d0f4ef(0xfae1196a68081ee6b19269aef7e4411025982141c7d3eb45b346fdae39f0a71b); /* statement */ \nhashes[i] = _generateBisectionHash(\r\n                _data,\r\n                uint64(otherSegmentSize(uint256(_data.totalSteps), bisectionCount)),\r\n                bisectionCount,\r\n                i\r\n            );\r\n        }\r\n\r\ncoverage_0x06d0f4ef(0x46dedabc99df0fd8a12da6def9c97de3d6e329d106ec71466bfd3d93a1857804); /* line */ \n        coverage_0x06d0f4ef(0xd800d2a4750a8c702fd28f9381516b960bd0dbcdca428bbcc94193ce610ef524); /* statement */ \ncommitToSegment(hashes);\r\ncoverage_0x06d0f4ef(0xe1e6daedc51b98161da0debd58ace723dfc2feff3803a0621278311bc8724848); /* line */ \n        coverage_0x06d0f4ef(0xfcdab17d75a48d82ad18650518c66235ed65262787588169991a4bfb462a7bf4); /* statement */ \nasserterResponded();\r\n\r\ncoverage_0x06d0f4ef(0xaf142c9f772aabc1892ef7a584fc61d6149ce451b17d0d1702cab2ccb2d4576b); /* line */ \n        coverage_0x06d0f4ef(0x09b5783f37e625e4b9b097b0f46b127deb3346d0822ce3e1bb6d10393a11264e); /* statement */ \nemit BisectedAssertion(hashes, deadlineTicks);\r\n    }\r\n\r\n    function oneStepProofWithMessage(\r\n        bytes32 _firstInbox,\r\n        bytes32 _firstMessage,\r\n        bytes32 _firstLog,\r\n        bytes memory _proof,\r\n        uint8 _kind,\r\n        uint256 _blockNumber,\r\n        uint256 _timestamp,\r\n        address _sender,\r\n        uint256 _inboxSeqNum,\r\n        bytes memory _msgData\r\n    ) public asserterAction {coverage_0x06d0f4ef(0xc8680ab6333c1dfd4129f63485a2b47ba65023e566d32c51a84f0b49d23cb63d); /* function */ \n\r\ncoverage_0x06d0f4ef(0x04fe7f20b021ad5bd1887dda212e845ba097f1da43276b2f339505cfb06e4d2d); /* line */ \n        coverage_0x06d0f4ef(0xcd73d9a29025e22c9d0b1850004327f5c10bd74365c351fc68b89fed5b9d9833); /* statement */ \n(uint64 gas, bytes32[5] memory fields) = executor.executeStepWithMessage(\r\n            _firstInbox,\r\n            _firstMessage,\r\n            _firstLog,\r\n            _proof,\r\n            _kind,\r\n            _blockNumber,\r\n            _timestamp,\r\n            _sender,\r\n            _inboxSeqNum,\r\n            _msgData\r\n        );\r\n\r\ncoverage_0x06d0f4ef(0xe1395ca359e6e930549164b7c0eff384d8ad18858354be1b4b430ca847cb8545); /* line */ \n        coverage_0x06d0f4ef(0x10ce357119cbe9a756545d4833bc47f9500df3d7a721e4585cf6055aa3a0c570); /* statement */ \ncheckProof(gas, _firstInbox, _firstMessage, _firstLog, fields);\r\n    }\r\n\r\n    function oneStepProof(\r\n        bytes32 _firstInbox,\r\n        bytes32 _firstMessage,\r\n        bytes32 _firstLog,\r\n        bytes memory _proof\r\n    ) public asserterAction {coverage_0x06d0f4ef(0x3e17f94b929d52259b3774442d3d68c296e860e21b33c573058df4358ba8492d); /* function */ \n\r\ncoverage_0x06d0f4ef(0xdc434330c77f7db42524dd04a46d124f653d50eb4f7608510d74f3df42244402); /* line */ \n        coverage_0x06d0f4ef(0xb323a8c6a9aba7f9773cba15cc9a25c472b989414462711a23e24795bc14476f); /* statement */ \n(uint64 gas, bytes32[5] memory fields) = executor.executeStep(\r\n            _firstInbox,\r\n            _firstMessage,\r\n            _firstLog,\r\n            _proof\r\n        );\r\n\r\ncoverage_0x06d0f4ef(0x09683c5cd1ac45feb6263c7e5b688ff4a86cdfe0e5f3b23a45dd1c1156059907); /* line */ \n        coverage_0x06d0f4ef(0x99d90bdc94bc84771fb63e91cf3e6246516a10beaba9ffa8e722e0fc810cb340); /* statement */ \ncheckProof(gas, _firstInbox, _firstMessage, _firstLog, fields);\r\n    }\r\n\r\n    function checkProof(\r\n        uint64 gas,\r\n        bytes32 firstInbox,\r\n        bytes32 firstMessage,\r\n        bytes32 firstLog,\r\n        bytes32[5] memory fields\r\n    ) private {coverage_0x06d0f4ef(0x2e98482a8149ea9ada306849a82ffadcd4745dc87e8e9680105add76f5a77577); /* function */ \n\r\ncoverage_0x06d0f4ef(0x56f8977c32ae247dbc4db28edf4c3954d05d5c602b35fd627a381ddcbfede48c); /* line */ \n        coverage_0x06d0f4ef(0x4c7c4cd759a04f8cd52c94069f4638eff65451e22c769c72b5b1bdd9828aa7b4); /* statement */ \nbytes32 startMachineHash = fields[0];\r\ncoverage_0x06d0f4ef(0x715b9a87339654fc8914b93471678649158fd5258dce59601644dd5ecf5925e9); /* line */ \n        coverage_0x06d0f4ef(0xe784b6266c56493492da3d837c10282f20e9b26c16ff69e0fe80edae68e31c38); /* statement */ \nbytes32 endMachineHash = fields[1];\r\ncoverage_0x06d0f4ef(0xa9e04b09ae71063bfa4bfc67e4da4826bb9f426149a7770f8538b748dbc35b37); /* line */ \n        coverage_0x06d0f4ef(0x117c084dca7f196e0b81a141bbf3584504146640eea30752308ff3b90e8ed466); /* statement */ \nbytes32 afterInboxHash = fields[2];\r\ncoverage_0x06d0f4ef(0xeb3defcfc5c445c4b12280e7a23db50547de842c53cbb77733ed2f9712cf5523); /* line */ \n        coverage_0x06d0f4ef(0x8d96e5edf46acf9dfadf6fde414f4e259f2a65f8613077942fefec995a48ab36); /* statement */ \nbytes32 afterMessagesHash = fields[3];\r\ncoverage_0x06d0f4ef(0x80d6001b1ff79f3187c15583cbd902746f46bea2ba0fb3c4ad253c963908a2a1); /* line */ \n        coverage_0x06d0f4ef(0x4768fb50a322957dcbb2aa59f65814a974eaaf4544fddb2303274e65f7b4a467); /* statement */ \nbytes32 afterLogsHash = fields[4];\r\n        // The one step proof already guarantees us that firstMessage and lastMessage\r\n        // are either one or 0 messages apart and the same is true for logs. Therefore\r\n        // we can infer the message count and log count based on whether the fields\r\n        // are equal or not\r\ncoverage_0x06d0f4ef(0x7f0f53988f4a8e4d9b0542e8138b9b6de1c5b7fabc717be4a31331555424ac59); /* line */ \n        coverage_0x06d0f4ef(0x339d43a380ac05a1ab6ec009fc71d1c6acae57ed3bb860ff51f223fceaf53fec); /* statement */ \nChallengeUtils.ExecutionAssertion memory assertion = ChallengeUtils.ExecutionAssertion(\r\n            1,\r\n            gas,\r\n            startMachineHash,\r\n            endMachineHash,\r\n            firstInbox,\r\n            afterInboxHash,\r\n            firstMessage,\r\n            afterMessagesHash,\r\n            firstMessage == afterMessagesHash ? 0 : 1,\r\n            firstLog,\r\n            afterLogsHash,\r\n            firstLog == afterLogsHash ? 0 : 1\r\n        );\r\ncoverage_0x06d0f4ef(0xee0787550eadf032ddd8eea250df00ee59ea72b4deac48e2eb2e13bfbf728996); /* line */ \n        coverage_0x06d0f4ef(0x6df9490f64f7680717c225e59f7f543121599685172ad866d4d3af25d7efbfa6); /* statement */ \nrequireMatchesPrevState(assertion.hash());\r\n\r\ncoverage_0x06d0f4ef(0x1e022f256ed1c975256ff6c324c78d95a649d04445ac1c7520b69888b690dcb1); /* line */ \n        coverage_0x06d0f4ef(0x9632de33e7cfeb66fa7fef95bd7bf703681716c087628d98eecaf36ffb4ab0af); /* statement */ \nemit OneStepProofCompleted();\r\ncoverage_0x06d0f4ef(0x0296fdfaa99da8c0ab000f00bcee6bd8c2289305ec2835465aee0af8333298c2); /* line */ \n        coverage_0x06d0f4ef(0xa70e57d203106e8010162b4f94f9a6d74f73625c441ca62865ea2e8dca4e685f); /* statement */ \n_asserterWin();\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/challenge/InboxTopChallenge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"./BisectionChallenge.sol\";\r\nimport \"./ChallengeUtils.sol\";\r\n\r\nimport \"../inbox/Messages.sol\";\r\n\r\ncontract InboxTopChallenge is BisectionChallenge {\nfunction coverage_0x5f761338(bytes32 c__0x5f761338) public pure {}\n\r\n    event Bisected(bytes32[] chainHashes, uint256 totalLength, uint256 deadlineTicks);\r\n\r\n    event OneStepProofCompleted();\r\n\r\n    // Proof was incorrect\r\n    string private constant HC_OSP_PROOF = \"HC_OSP_PROOF\";\r\n\r\n    function bisect(bytes32[] calldata _chainHashes, uint256 _chainLength) external asserterAction {coverage_0x5f761338(0xf6e859e39d98c4b1c60084b45be6883f59dded15f160d4de3123e541843d85e2); /* function */ \n\r\ncoverage_0x5f761338(0xf735c9d87d39e659618f5d4a15da323558bb86fc212a8ef616b6ccfb6ca3e0e8); /* line */ \n        coverage_0x5f761338(0xad63645d1f77963b48e83130830261bd2cb0d4d7cd7834091412c67a752a607f); /* statement */ \nuint256 bisectionCount = _chainHashes.length - 1;\r\n\r\ncoverage_0x5f761338(0x1d590220f4153f5d2c402d922869481b5c9bbca00111ed725f440be36b8de8a3); /* line */ \n        coverage_0x5f761338(0x99b5b97adfe9e69862b0fbf1db99bb2b8960340771bcb13af0a2bc87776b6a2d); /* statement */ \nrequireMatchesPrevState(\r\n            ChallengeUtils.inboxTopHash(_chainHashes[0], _chainHashes[bisectionCount], _chainLength)\r\n        );\r\n\r\ncoverage_0x5f761338(0x582905ef3e8ee4b0963f54ab354ed8faa4e420baf86a1b8ccc579ddd81258d6d); /* line */ \n        coverage_0x5f761338(0x8d40c3f675f812c4f86aab947f6d305e42d400a82cdc99cb41d146e90a73eb59); /* assertPre */ \ncoverage_0x5f761338(0x6a423a23c3bd0915aad282933131a8afe07fbe53a1a0c26a1a51f517dcc1659b); /* statement */ \nrequire(_chainLength > 1, \"bisection too short\");coverage_0x5f761338(0xb482cc1c00804f944355a1c04d75ba9ad2e339a270eac315b7585366536aa310); /* assertPost */ \n\r\ncoverage_0x5f761338(0x005d7c9cefef6d5a1f0c60d8bfc1c6f2495bf79b7080489bed0725f812d02ac2); /* line */ \n        coverage_0x5f761338(0xf071a18d71399c08f451b39f9ad31b59cea14f26a433f2266a89a35f458a4c61); /* statement */ \nbytes32[] memory hashes = new bytes32[](bisectionCount);\r\ncoverage_0x5f761338(0xb2a5ffab2bdd73dc1fe6e4ee5e904da44668ad6f1e95577aa5bc0c84b550a7ed); /* line */ \n        coverage_0x5f761338(0x95ce7b178a974f06411c535b4064a2af7e7ae26beded09495897a3a64b89b1c8); /* statement */ \nhashes[0] = ChallengeUtils.inboxTopHash(\r\n            _chainHashes[0],\r\n            _chainHashes[1],\r\n            firstSegmentSize(_chainLength, bisectionCount)\r\n        );\r\ncoverage_0x5f761338(0x00b2eb2b66d6687be5d33edef95bacbe183844bd2b1bac6ddaee127d3ebe6038); /* line */ \n        coverage_0x5f761338(0x01978c79b05d4c46c3edd007d59dbc800d3694a373fc7ce54a379c650c99803d); /* statement */ \nfor (uint256 i = 1; i < bisectionCount; i++) {\r\ncoverage_0x5f761338(0xce7d37d95da48fc352baa91c25e510e2aaa52c88761159bf2284fbdc7fea9441); /* line */ \n            coverage_0x5f761338(0xb42c447557e5bdc8f311f95513ebcbf04e60e8d7b7d47bfe0ab9090115414717); /* statement */ \nhashes[i] = ChallengeUtils.inboxTopHash(\r\n                _chainHashes[i],\r\n                _chainHashes[i + 1],\r\n                otherSegmentSize(_chainLength, bisectionCount)\r\n            );\r\n        }\r\n\r\ncoverage_0x5f761338(0x4d12b0b809676c0065c193c6aecd99bed558c6dea8dc5ab30a4688fded36cc7a); /* line */ \n        coverage_0x5f761338(0x22b72ab0dbe573e7997ada72faa8310200cb090b899ec444f84da815a681535b); /* statement */ \ncommitToSegment(hashes);\r\ncoverage_0x5f761338(0xe98c81cbf4ce8fe90021d63293c8f93d82c363a6bc01b9c4165619ed84f4597a); /* line */ \n        coverage_0x5f761338(0xb3ef3fcfbef1a131fdfe8a0f5e230a7f19d219350c5cac5909c26a6c2c0c1fe7); /* statement */ \nasserterResponded();\r\ncoverage_0x5f761338(0x8c538f003488730ef26b7c0152968abe7da061feed35de6bfe41c128d18a0841); /* line */ \n        coverage_0x5f761338(0xa4e6544d38bd45a5640f8884bcc550a75434d794478c412ea9efeed4f5bc141d); /* statement */ \nemit Bisected(_chainHashes, _chainLength, deadlineTicks);\r\n    }\r\n\r\n    function oneStepProof(bytes32 _lowerHash, bytes32 _value) external asserterAction {coverage_0x5f761338(0x07de813b27f79fcff2ed6e5efdc023b97b03ffda8bcb901dfcc47364fd7e437c); /* function */ \n\r\ncoverage_0x5f761338(0x35d4c64c3a8f1ee3d8f98e29332678f0275d143df638e932ec762ad9cda84378); /* line */ \n        coverage_0x5f761338(0xdddff336cc039fcde21d66118d6b548bb75865642ec338da402636027b0eac6a); /* statement */ \nrequireMatchesPrevState(\r\n            ChallengeUtils.inboxTopHash(\r\n                _lowerHash,\r\n                Messages.addMessageToInbox(_lowerHash, _value),\r\n                1\r\n            )\r\n        );\r\n\r\ncoverage_0x5f761338(0xf9ef0939d6f133429106a22cdf39ec3eb14a174e281ac139740edfbc9bae46f6); /* line */ \n        coverage_0x5f761338(0x7bd23bb15b1625be7bf6d77e7a28c4b8b7f6cf4b1c50a0c16fb5c11a81f5ee93); /* statement */ \nemit OneStepProofCompleted();\r\ncoverage_0x5f761338(0x16e9657490844f03d4dc2eb68179876dc16a2515df73253206e06a3262b9ce70); /* line */ \n        coverage_0x5f761338(0x9d6b8960f4b0e95b6184bd691bae9426caf06c545d2198e86af45c29ef5c7f55); /* statement */ \n_asserterWin();\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/inbox/GlobalEthWallet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\ncontract GlobalEthWallet {\nfunction coverage_0xb74b7b42(bytes32 c__0xb74b7b42) public pure {}\n\r\n    mapping(address => uint256) private ethWallets;\r\n\r\n    function withdrawEth() external {coverage_0xb74b7b42(0x468437bf976016aa78cf7364a60538a352b6133f39a9f7101cc605f09b55ee1c); /* function */ \n\r\ncoverage_0xb74b7b42(0xcf232a7a1775e93d8713829e8a92d1d0f2c9a5f327d108b7afee50d08ac5f555); /* line */ \n        coverage_0xb74b7b42(0x49094d7b92cfc146daf0ce0aca23005082915dcb0e5484731294c521e9c19206); /* statement */ \nuint256 value = getEthBalance(msg.sender);\r\ncoverage_0xb74b7b42(0x4b38721146d8f0792e0553c70d90049db25818e68a0be4d142c49c284faac4f5); /* line */ \n        delete ethWallets[msg.sender];\r\ncoverage_0xb74b7b42(0x2fbca625a741ab7e5663028f3d1b752efc9cdb269f7e7e54bc787c5877544522); /* line */ \n        coverage_0xb74b7b42(0x528cfa1ab7c03e516fe652b9916a1cd3daff856a54046590541b9cd4f6b37dfa); /* statement */ \nmsg.sender.transfer(value);\r\n    }\r\n\r\n    function getEthBalance(address _owner) public view returns (uint256) {coverage_0xb74b7b42(0x1ed8f1707686dbaff4085fcedc90ae5b353f363266dd8e499192fec3fb30262c); /* function */ \n\r\ncoverage_0xb74b7b42(0xe36e342c722f71427fd8f802d4d6de35eea4bcf9165e85f3375d7208e089f4b3); /* line */ \n        coverage_0xb74b7b42(0x782c284d0ab97a3e91d4c953f082db2bb63c408d2dba5cb96df379b4d58b2df7); /* statement */ \nreturn ethWallets[_owner];\r\n    }\r\n\r\n    function depositEth(address _destination) internal {coverage_0xb74b7b42(0xc6336d0f90caea39d6325c8839c075d467b95743311463b3adb79c51c60642e7); /* function */ \n\r\ncoverage_0xb74b7b42(0x2841b1e35505b43c7cb789636965b5d0896c3c5af9453ddcb0a43713bafaf1f0); /* line */ \n        coverage_0xb74b7b42(0x7713bd0e756cac7d8c5523795f463682edfb5317856e1eafd752a595525f8420); /* statement */ \nethWallets[_destination] += msg.value;\r\n    }\r\n\r\n    function transferEth(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal returns (bool) {coverage_0xb74b7b42(0xeab2678bfa9910c73b0f159db45e48f7d3845501567a4576162a78c93650bd1c); /* function */ \n\r\ncoverage_0xb74b7b42(0xa31ac6134525bac07e6ee0d82ed3c4544e5460f700d92d594d98009073d05743); /* line */ \n        coverage_0xb74b7b42(0x82b6c85efd45aa9828e920826c67686cbf60c0ce7cd87f2753ae9f02170023d3); /* statement */ \nif (_value > ethWallets[_from]) {coverage_0xb74b7b42(0x04e55eba64f727b7ce0a93527dc108af5454ff788e943212978b458641d5ed57); /* branch */ \n\r\ncoverage_0xb74b7b42(0x397704462d9dc816ee437944d5ab145d9249eeb515d0c89299821e7b693a3685); /* line */ \n            coverage_0xb74b7b42(0x66e1a181e068f341fa32deab25d969807f3a8bc880eaa7ed94549db405fd9c24); /* statement */ \nreturn false;\r\n        }else { coverage_0xb74b7b42(0x7336b037e0331fedbd43d8558d10a8028bb5aab4cf1394db18c3857aadb785fa); /* branch */ \n}\r\ncoverage_0xb74b7b42(0x7a0a4dcb279040a6713a4c61c6a99e347a4bf4fe42760e5e36b4d607b8a39f20); /* line */ \n        coverage_0xb74b7b42(0xd17c9c506aeaf1d08d1067b7667e3c4720f4fdaf7c8d6cd5d480e748bb403f9f); /* statement */ \nethWallets[_from] -= _value;\r\ncoverage_0xb74b7b42(0x79f11d81ce423ad289d2b782ec5b049cecbe21455c77fdc0f7bc8e436f1a6211); /* line */ \n        coverage_0xb74b7b42(0xafd4a0ae9101df55f30140f5e310b4685036feba6102a040993367fcc859cb30); /* statement */ \nethWallets[_to] += _value;\r\ncoverage_0xb74b7b42(0xa194ce373207024e4e354f8968cc7f212e3890d94b66983e94a4ed503ea93c4e); /* line */ \n        coverage_0xb74b7b42(0xf736484964fec20ee6310bb196117c4f4c994cb264cef7369795971ce982ddcf); /* statement */ \nreturn true;\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/inbox/GlobalFTWallet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../interfaces/IERC20.sol\";\r\nimport \"../interfaces/IPairedErc20.sol\";\r\n\r\ncontract GlobalFTWallet {\nfunction coverage_0xb3fcc7e2(bytes32 c__0xb3fcc7e2) public pure {}\n\r\n    string public constant FAILED_TRANSFER = \"FAILED_TRANSFER\";\r\n\r\n    struct FTWallet {\r\n        address contractAddress;\r\n        uint256 balance;\r\n    }\r\n\r\n    struct UserFTWallet {\r\n        mapping(address => uint256) ftIndex;\r\n        FTWallet[] ftList;\r\n    }\r\n\r\n    mapping(address => UserFTWallet) private ftWallets;\r\n\r\n    // Uninitialized paired contracts default to Unpaired\r\n    enum PairingStatus { Unpaired, Requested, Paired }\r\n\r\n    struct PairedContract {\r\n        bool paired;\r\n        mapping(address => PairingStatus) connectedRollups;\r\n    }\r\n\r\n    mapping(address => PairedContract) private pairedContracts;\r\n\r\n    function ownedERC20s(address _owner) external view returns (address[] memory) {coverage_0xb3fcc7e2(0xce3fc4b99d06e6e3c589d5e8cdd7766928313e354d9664813f67e93a03ac85ba); /* function */ \n\r\ncoverage_0xb3fcc7e2(0x71cd4a65ab736a3d9a46adc370244c73f7834400f6004e9edaa64f57b00a7cd7); /* line */ \n        coverage_0xb3fcc7e2(0xe4d960033272b351f83a792cd6f723ae3ad0f35f9f30c38a4d700e82848bfdbe); /* statement */ \nUserFTWallet storage wallet = ftWallets[_owner];\r\ncoverage_0xb3fcc7e2(0x924bcb61c77431e3eee01cedf19501cb6f33f96ee004b2236c20d30be1c51d49); /* line */ \n        coverage_0xb3fcc7e2(0x50d3ec268f3a08bca62a594e809c0fed1799c42493a320d5fa826197672e7da1); /* statement */ \naddress[] memory addresses = new address[](wallet.ftList.length);\r\ncoverage_0xb3fcc7e2(0x08910eb6bfa023e9ad6e77b9269b3137691b559a3c6649c41f72ac5969634ff8); /* line */ \n        coverage_0xb3fcc7e2(0x2c01f36c4465a08293e82172f82ec1db13bb4f241105c22234e1e37fe64a05b4); /* statement */ \nuint256 addressCount = addresses.length;\r\ncoverage_0xb3fcc7e2(0x15a63dee7f8c1ad42128b8f328d6afc52e75507fcf6e939849776f4772fd0ad6); /* line */ \n        coverage_0xb3fcc7e2(0xa5ec5c0d60d55d08d5744b404e92d692477ab7a8aad360c2b96480e3766aa0fa); /* statement */ \nfor (uint256 i = 0; i < addressCount; i++) {\r\ncoverage_0xb3fcc7e2(0x64a9b2ab2b9523418f0f3ac7ff3e27fd577880f960d46740964438b3beb0f5a6); /* line */ \n            coverage_0xb3fcc7e2(0xed21cce643fc1588afa398c1e6f0c0899b27d2037e51bf3c83c037e77706b0db); /* statement */ \naddresses[i] = wallet.ftList[i].contractAddress;\r\n        }\r\ncoverage_0xb3fcc7e2(0x16fe7e3e2ac2eff0204374b710650ff5d51ae916f39b9ca1e5b49d54faacc078); /* line */ \n        coverage_0xb3fcc7e2(0x9d66d10728cabdd48417a168e0d330851ed97b3bdae872f070ee3ab1fe8dc112); /* statement */ \nreturn addresses;\r\n    }\r\n\r\n    function withdrawERC20(address _tokenContract) external {coverage_0xb3fcc7e2(0x66a259a1acc9ae81c0a6d449ab718ca36e8369fb125f7a2112a0959d0b64ecdc); /* function */ \n\r\ncoverage_0xb3fcc7e2(0x93136b6da9a624247249c1412cdf3acfdd9345bb297582ee16a0ae24d79fa483); /* line */ \n        coverage_0xb3fcc7e2(0xfc4bfaeed64ce62ac2e435f3615a0c15a63accb1052a5fe282d41a3ebc323bf1); /* statement */ \nuint256 value = getERC20Balance(_tokenContract, msg.sender);\r\ncoverage_0xb3fcc7e2(0xa9bb3f744f82ef21f3633e325bd177b7e987076050729bf3a238a971c6d2b4b0); /* line */ \n        coverage_0xb3fcc7e2(0xb417f04d07141867d81781c2bc71f81976ec3e946154ee8bdb3f785ebb57b489); /* assertPre */ \ncoverage_0xb3fcc7e2(0x1d0a245cc900571532898cfe6bc2b571a0d534324451acea5517d44d5789ffd0); /* statement */ \nrequire(removeToken(msg.sender, _tokenContract, value), \"insufficient balance\");coverage_0xb3fcc7e2(0x73673640f05d6c7dc39a865944faa67eab66a94743a82a0e440a71c28a67a6fe); /* assertPost */ \n\r\ncoverage_0xb3fcc7e2(0x7e0d9e857d83238aca8bee09bcf44eb306fa7bc4b7f70041799f368d4a1a5bee); /* line */ \n        coverage_0xb3fcc7e2(0xc15fb4b6aa428fe01ddeb645c77b56a630a4c86106cd61842fdf60884ddf1336); /* statement */ \nif (pairedContracts[_tokenContract].paired) {coverage_0xb3fcc7e2(0x5d0b86db4a054b021396abfdd6d0295a7009c2c035117645bbe64bed0239eec7); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0x1a238fce2c79331807f1f9500b4075f03eecf41a55dccf23de83aec3395f0607); /* line */ \n            coverage_0xb3fcc7e2(0x31b248ff4938a901e7dc0303924b2233b0cc6a2e533243f8b23cf670b01cfb49); /* statement */ \nIPairedErc20(_tokenContract).mint(msg.sender, value);\r\n        } else {coverage_0xb3fcc7e2(0xc2122d9dd5a355b5d0118e43e41d3b2b20bdea0d52ccb3922e386dfd72408eef); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0x9d978c9fdeb00fbb06b695444a9d3a7059055b7615cc72ccbb44851b448adf76); /* line */ \n            coverage_0xb3fcc7e2(0xbf51d7ffceb9cfda0888643287230bc8ffe3002ec8b4c0b849b6ea18b6b7783d); /* assertPre */ \ncoverage_0xb3fcc7e2(0xcdb2cc6e41624574569ce97d234873d8e05dc704f8d542cc5faa77758c1cc684); /* statement */ \nrequire(IERC20(_tokenContract).transfer(msg.sender, value), FAILED_TRANSFER);coverage_0xb3fcc7e2(0x714466397cca1db0522565fd20060ed2511b11f01f57ea2320bf0c2c262c6641); /* assertPost */ \n\r\n        }\r\n    }\r\n\r\n    function getERC20Balance(address _tokenContract, address _owner) public view returns (uint256) {coverage_0xb3fcc7e2(0x064cf701c0c122282592cd7ffefa6b1a6a9b8b367be10c6bcff3efa784a8eef9); /* function */ \n\r\ncoverage_0xb3fcc7e2(0x439fd89c55f525a032dea7acb155f69c5357e0fbc7544d0ebd539ab21a67561d); /* line */ \n        coverage_0xb3fcc7e2(0xf4ec59b52fc44e211f6827cdb9f22d2718e8e8a23065e27d9cd58e6504cbde01); /* statement */ \nUserFTWallet storage wallet = ftWallets[_owner];\r\ncoverage_0xb3fcc7e2(0xa504d075e389286eadda65797772ac862faa77cc68fffaa6bac2f99de1347ea8); /* line */ \n        coverage_0xb3fcc7e2(0x7df54b1666057184db1c3edc8ab2896e662c2510f7f8ecbb3f5206e6300daa2d); /* statement */ \nuint256 index = wallet.ftIndex[_tokenContract];\r\ncoverage_0xb3fcc7e2(0x39480fae7f15b44d7587bab28c1d682ce71b9cffdf4c3ad54b3492585fe206ca); /* line */ \n        coverage_0xb3fcc7e2(0x35d455713b80bb9136d3b494c4fd0c6a2742c65ef2c05bb38693c98278706b09); /* statement */ \nif (index == 0) {coverage_0xb3fcc7e2(0x9f41200696e8207c3d3d2b41c8b510607d29b884b63d97eeafb33d6015a12daf); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0xa385ed25071e9ad1ac36d15af07c1d46661313750c4c3caba466228ddbe75abd); /* line */ \n            coverage_0xb3fcc7e2(0xc3b5952a8855bf9750af62e0e8b8ab3a3ca2bc2ee9b89f819358aebaf410f27a); /* statement */ \nreturn 0;\r\n        }else { coverage_0xb3fcc7e2(0x6fee53b096886645d25d7a8fa3abf612a597032d85348aa6819fe1e355d94335); /* branch */ \n}\r\ncoverage_0xb3fcc7e2(0x361a4decc356eabf8af020dfefc752ab40766587c74e18e5444a5ce8545d8c23); /* line */ \n        coverage_0xb3fcc7e2(0x80d0dd078695cb88316483b2ba967eeb3520fbdcfea9c9b777ed7f28a6ee5933); /* statement */ \nreturn wallet.ftList[index - 1].balance;\r\n    }\r\n\r\n    function isPairedContract(address _tokenContract, address _chain)\r\n        external\r\n        view\r\n        returns (PairingStatus)\r\n    {coverage_0xb3fcc7e2(0xe641407264991d8fc2101eaa13ae7e477fab561359752db1eaa3ea584d747ccb); /* function */ \n\r\ncoverage_0xb3fcc7e2(0xbadec3bcf91b3a4f5e6aaf8774c990466b6fb17e0696e0d6b1c06e054fdb33d4); /* line */ \n        coverage_0xb3fcc7e2(0x54a00a9612d198ecf14d7aae1ecbd581d8b0fbae3cba6955287b78b0a74f8bbd); /* statement */ \nreturn pairedContracts[_tokenContract].connectedRollups[_chain];\r\n    }\r\n\r\n    function requestPairing(address _tokenContract, address _chain) internal {coverage_0xb3fcc7e2(0xcf1278c133a3c36ae1b007c89aad4b9ec17146421049f1e77d6a81e220535033); /* function */ \n\r\ncoverage_0xb3fcc7e2(0xec33d6ca8b62351850c7bcbae4a68bed30f1d7b8d97b3ae3c74259a3b79d00f8); /* line */ \n        coverage_0xb3fcc7e2(0xca4816a1af2fe924b43d41fa8b322786b423a9ef1eb82d0a503b5705206407d1); /* statement */ \nPairedContract storage pairedContract = pairedContracts[_tokenContract];\r\ncoverage_0xb3fcc7e2(0xddd2af4a5164af74773cb06a7af2317ac85eada93661205ba02a09b71dad64ba); /* line */ \n        coverage_0xb3fcc7e2(0x6d241913e1cd7131ed0e1d8935065287b68c7cb03d1407e48060090d9194dd3c); /* assertPre */ \ncoverage_0xb3fcc7e2(0xf250785871c9408124032b92676ca9ce4e6f5ec097c0b9d5db20f30207810b1f); /* statement */ \nrequire(\r\n            pairedContract.connectedRollups[_chain] == PairingStatus.Unpaired,\r\n            \"must be unpaired\"\r\n        );coverage_0xb3fcc7e2(0x514346cb81ad670a4e1f569433ed7e8b5f81df7d26e176e80f3ab3e47fa86462); /* assertPost */ \n\r\ncoverage_0xb3fcc7e2(0x62710e2e8c46eb967b039eec27fdd2d6dc91d7cec8a511fa60aa09706f3e4be5); /* line */ \n        coverage_0xb3fcc7e2(0x2989ffc767aae40691d75a17fa1c860d07c5f1302f5017d9e745d3f88d21ca17); /* statement */ \nif (!pairedContract.paired) {coverage_0xb3fcc7e2(0x561c0b2a6d12ff9eeb82242306c59b4d92605eb2a2035ab3676b6e321e2f3a1d); /* branch */ \n\r\n            // This is the first time pairing with a chain\r\ncoverage_0xb3fcc7e2(0x263d3ca7b5d10a7f3335ae13a36119f07b37abf1534864603e4cce5b0228f1ed); /* line */ \n            coverage_0xb3fcc7e2(0x9fc6e907777605f516e3f96e933a434eaf72d1f510e86870146bf9eb1f6fabed); /* statement */ \npairedContract.paired = true;\r\n\r\n            // Burn existing balance since we will switch over to minting on withdrawal\r\ncoverage_0xb3fcc7e2(0x2f1fc159a4dd28f6e348549f77a3e96de7a9eec33c3a563e571ee7422ec80ac3); /* line */ \n            coverage_0xb3fcc7e2(0xc5ca0913521a36936c3643bc3501261cb2a92e8f3c59da4489668e81be11bb48); /* statement */ \nIPairedErc20 tokenContract = IPairedErc20(_tokenContract);\r\ncoverage_0xb3fcc7e2(0x312d2bf7b1fd000547c557c36ef7eaf1d7aa4ab890d4368e0004130f2c3fe458); /* line */ \n            coverage_0xb3fcc7e2(0x120d8587de285d95b9674a221087eec2b04337163f8d7d570d5f3d895d2947d3); /* statement */ \ntokenContract.burn(address(this), tokenContract.balanceOf(address(this)));\r\n        }else { coverage_0xb3fcc7e2(0x1e6ad4c6c8f4f98336893bc3ae8ff4502b38c35303cc9f95abed380d2a466a22); /* branch */ \n}\r\ncoverage_0xb3fcc7e2(0xa869fc781d0baacfc34b79684d3b18926e33f40dbd5156ae15753839943d7b8b); /* line */ \n        coverage_0xb3fcc7e2(0x2e593143f8da5268c8b1fac586c64cec2e1249eddad3486552c3379a91ab3602); /* statement */ \npairedContract.connectedRollups[_chain] = PairingStatus.Requested;\r\n    }\r\n\r\n    function updatePairing(\r\n        address _tokenContract,\r\n        address _chain,\r\n        bool success\r\n    ) internal {coverage_0xb3fcc7e2(0x416404b12869720deff3f85996686cd4c1b05e24fc6b65b4dd31d0799ae4fff1); /* function */ \n\r\ncoverage_0xb3fcc7e2(0x339e0088006df2d55bc91c83dc474b3a7d93f2ce0bfd9e35335abfb8f83ecf6a); /* line */ \n        coverage_0xb3fcc7e2(0x247c37e4d45c1f315d830c86dee8c29ed58149053f7cc481050bc96716d52f24); /* statement */ \nPairedContract storage pairedContract = pairedContracts[_tokenContract];\r\ncoverage_0xb3fcc7e2(0xed5950ae28efb0b33de4f9eb211151e8e1a4a6f0cabe84ad92a76a396bdc4c40); /* line */ \n        coverage_0xb3fcc7e2(0x28756b86dd56be91bbbbd951e9b938795fed3ac686003c68c20e97fadcb179ba); /* statement */ \nif (pairedContract.connectedRollups[_chain] != PairingStatus.Requested) {coverage_0xb3fcc7e2(0x3b32723bfee70b50ac10fd5556d993655a5f35a2a97d36c26097238f626bc516); /* branch */ \n\r\n            // If the pairing hasn't been requested, ignore this\r\ncoverage_0xb3fcc7e2(0x3315f6a28c0438481bb924f6488616b1fcacce6983f2846eea47234df431f98f); /* line */ \n            coverage_0xb3fcc7e2(0x1723d407d45504d3e1a1d8a5728c51c8bc5acb6f0c97f4fec105c5e2021f7a34); /* statement */ \nreturn;\r\n        }else { coverage_0xb3fcc7e2(0xca30c5126e16d828b500adc32a7a4943bb9ebf392ff8aa6132eb9e0a48ee58dc); /* branch */ \n}\r\ncoverage_0xb3fcc7e2(0xca365e619d4604351e12071464287a99b9a2a8121af9e83764ff8f9cd882702b); /* line */ \n        coverage_0xb3fcc7e2(0x547d06c76fb79d2c0bf4fbb28a070b2cefc5402d6c15a87bfc8275c79528b79e); /* statement */ \nif (success) {coverage_0xb3fcc7e2(0x7aed53e76d998734ef9190d4cfae90ac7ddded70563c94a19a53e86578cebe8d); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0x3a8cac7a4825d8ca95499673df5675823a60f64e41bc493b83c176f5dd719b53); /* line */ \n            coverage_0xb3fcc7e2(0xcdda5a512456aa633f4816225eb525979bacda832a71cd0608469750d373aad3); /* statement */ \npairedContract.connectedRollups[_chain] = PairingStatus.Paired;\r\n        } else {coverage_0xb3fcc7e2(0x7a5ebce26495055ba29778d029488c1b92bc29c9c5577bd010c01db2e1300f39); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0x63ecdc631b326b59e133ad65eb907014e6e1c54ce3aed67a81bf71f9c910b311); /* line */ \n            coverage_0xb3fcc7e2(0xa48306236e73542754d31e8225b43079b4bd1d2ba881c0f9cf788a96b7db2e9f); /* statement */ \npairedContract.connectedRollups[_chain] = PairingStatus.Unpaired;\r\n        }\r\n    }\r\n\r\n    function depositERC20(\r\n        address _tokenContract,\r\n        address _destination,\r\n        uint256 _value\r\n    ) internal {coverage_0xb3fcc7e2(0xcee3bcc71466a8874b77f2566afa430560cd3aea714ba2864396701838cad5d8); /* function */ \n\r\ncoverage_0xb3fcc7e2(0xdf1fe0ff64a965e26f3d85bb4fa6e0e22e9bd392f1d314afdf26fb3d0facdc17); /* line */ \n        coverage_0xb3fcc7e2(0x5595d69d3f4cb786e405e782b33ec858e61280fd67827deac188e3cba9869bd4); /* statement */ \nPairedContract storage pairedContract = pairedContracts[_tokenContract];\r\ncoverage_0xb3fcc7e2(0x4c533eae9aa171c8b18a067e4cfbd5a424c9d714733699bc8c52119bfc37c099); /* line */ \n        coverage_0xb3fcc7e2(0xa2dce9aeb85d87270ca57a1b8094ff9fae1b3793e04c1af3e6aabfdadcd517cb); /* statement */ \nbool isPaired = pairedContract.paired;\r\n\r\ncoverage_0xb3fcc7e2(0x2e68ec25ce8b4d44c0d8f5aeba86ffac8c0f708e44d8709a6f74b0b22cb821d0); /* line */ \n        coverage_0xb3fcc7e2(0x8f6209b3d9b5d7bc643fed1fadb6ac696f88580746a6d0d9e1547fce7c5d1e1e); /* statement */ \nbool recipientMintNewTokens = isPaired &&\r\n            pairedContract.connectedRollups[_destination] == PairingStatus.Paired;\r\ncoverage_0xb3fcc7e2(0xb26c1495bdc29e993fd83096418015468152d227da68bde7a45704387c65a57a); /* line */ \n        coverage_0xb3fcc7e2(0xacf269112033832c1b76ee80aa307bccc2763d5ac403bd0fb3f042f3a395f003); /* statement */ \nif (!recipientMintNewTokens) {coverage_0xb3fcc7e2(0xa709a15b09eca5a7e739670589f13b5ee7048a698ea0feecdb06e916d9870cee); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0xebf8cb518c5f82a9b8b76a6798d6a018009d34c0751d0bf862e90ca938bd413d); /* line */ \n            coverage_0xb3fcc7e2(0xe1224996943c6bcb649420a2a52cb105bfecae283213f3dfefd87a061f5b58a4); /* statement */ \naddToken(_destination, _tokenContract, _value);\r\n        }else { coverage_0xb3fcc7e2(0xc65f1f1862bffa2e9664716de05643dbf0883763666d5cc76d437472649631b5); /* branch */ \n}\r\n\r\ncoverage_0xb3fcc7e2(0x0c3983d242afe6db9cc316913a8b8f1876d03d842932df478f1b1708b42ca358); /* line */ \n        coverage_0xb3fcc7e2(0xbc67a01402434151b4da6896d41371f79d79663c1e68f25410a920b55b664c81); /* statement */ \nif (isPaired) {coverage_0xb3fcc7e2(0x2ffb7c7b810b19b18170657bd6e76b55e20ebcd5907c6687cf06880b49b11554); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0x874d64f8e90757a9819557fbbe3510dcb19ba616c92f2d3c7368fb80bfa7d81c); /* line */ \n            coverage_0xb3fcc7e2(0xeed8bcb8b4c53d0b0c62d93137f80d39abd4c99008c23519d5503b9bb27b49df); /* statement */ \nIPairedErc20(_tokenContract).burn(msg.sender, _value);\r\n        } else {coverage_0xb3fcc7e2(0x13642c7212bca045cabf26a8523cd5738a8e1f36c0ec1f1a117b717612df3f1d); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0x97aba4bb6dd2bd910bd666aaa5f6cb7ac80d42a2688278ae4b8c9ff6fe1f4de6); /* line */ \n            coverage_0xb3fcc7e2(0x2c4d2db91d39da5e280c487dca1a89ff3071185a1d470f57a8560482f53e3daa); /* assertPre */ \ncoverage_0xb3fcc7e2(0xcac1614914d7670eb241ef73a2ffc169bb8393591468cb9f5735e185ee63ebab); /* statement */ \nrequire(\r\n                IERC20(_tokenContract).transferFrom(msg.sender, address(this), _value),\r\n                FAILED_TRANSFER\r\n            );coverage_0xb3fcc7e2(0x05a1c4943994b701ad4d16a7ec449aea6416990dfd7e54338489d91963c05aae); /* assertPost */ \n\r\n        }\r\n    }\r\n\r\n    function transferERC20(\r\n        address _from,\r\n        address _to,\r\n        address _tokenContract,\r\n        uint256 _value\r\n    ) internal returns (bool) {coverage_0xb3fcc7e2(0x574431183fd40d69457a3518819bce620448e2958ca686a88c34b4892bd26209); /* function */ \n\r\n        // Skip removing or adding tokens for a pair contract with one of its connected rollups\r\ncoverage_0xb3fcc7e2(0xd8e9ad0ae438149157dfc32567f2a2b832744fdf3a7285389dde73d2e1c3f63f); /* line */ \n        coverage_0xb3fcc7e2(0x572146dfee566f05d8776e760be351a0420c5615a8634e2a4a9d5328caddf911); /* statement */ \nPairedContract storage pairedContract = pairedContracts[_tokenContract];\r\ncoverage_0xb3fcc7e2(0x01ff958ddd1047807366bde19bb540abe05ceae7e5658ea43a01567203d8df0a); /* line */ \n        coverage_0xb3fcc7e2(0x76b32a1510f7a802eaa024cfe0961d346cb6cf15b307d2e674c0dd123b601151); /* statement */ \nbool isPaired = pairedContract.paired;\r\ncoverage_0xb3fcc7e2(0x3a7713cb9f36aca56725442df028aef83cb26d762f0bc6b0c104673a40bda7fb); /* line */ \n        coverage_0xb3fcc7e2(0x80c501cd027e037460950e18db3ac1b72b132ea10df9c7ba3f4653ee7a669fc4); /* statement */ \nbool senderMintNewTokens = isPaired &&\r\n            pairedContract.connectedRollups[_from] == PairingStatus.Paired;\r\ncoverage_0xb3fcc7e2(0x18da625355d5b9655d8552291627acdc98fd0c74e2a6412d79b3454a425ddc95); /* line */ \n        coverage_0xb3fcc7e2(0x296aefc02d298e97f7b90e317b251a1e8f81b807cb089aa15cca86af5de87693); /* statement */ \nif (!senderMintNewTokens && !removeToken(_from, _tokenContract, _value)) {coverage_0xb3fcc7e2(0x2f9477d9e5086c09fb47f153a900a3b4a10b3593d0596a94b51497aa3b86b28a); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0xc1e048e5015d091cf4330a66583f122bd6b23617351fa9fbe8256af357a9e892); /* line */ \n            coverage_0xb3fcc7e2(0x7d13f1bb29b15e7c98fd90921d5dd5d41ac38ffc635059fe5be832933659e2c3); /* statement */ \nreturn false;\r\n        }else { coverage_0xb3fcc7e2(0x9bb3e62ece5bc9c780eb8ed06c8da0d67a9c89a9997d967f2d8684d64c528e16); /* branch */ \n}\r\n\r\ncoverage_0xb3fcc7e2(0xaf21e39c6728491b4b47de7225944932430cb3211ba40ae35c85cbad25289d53); /* line */ \n        coverage_0xb3fcc7e2(0xd4cafa5be56cd404ec7fad131c72681b817c95338e3bbfbbd4d85d678d773e2f); /* statement */ \nbool recipientMintNewTokens = isPaired &&\r\n            pairedContract.connectedRollups[_to] == PairingStatus.Paired;\r\ncoverage_0xb3fcc7e2(0x42f2840d20061d463b3262d5a1c72f9c8f2729db7063f60b06dc2ed2c18f89b8); /* line */ \n        coverage_0xb3fcc7e2(0xd6af75f466f34cfb90d622db858e525107bcbf8363d3c4c1676108c485db7f32); /* statement */ \nif (!recipientMintNewTokens) {coverage_0xb3fcc7e2(0x9556687895dbd8ae673d069d122612661fa02e00ad4a6392dbc3a72f20bfb591); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0x13001071ad648c2b988afbf1334a7a5fde287bea44d75e32572639a5f8412a76); /* line */ \n            coverage_0xb3fcc7e2(0x76a65f548b1ae05079d315f3cc801813aacbf78f911bc0b3377f97d246778321); /* statement */ \naddToken(_to, _tokenContract, _value);\r\n        }else { coverage_0xb3fcc7e2(0x846a7ca443bb0bfcf6c41a6775ab6b98cdb2d24c1a4c3900cf4872b1820d2676); /* branch */ \n}\r\ncoverage_0xb3fcc7e2(0x092742ed9090cf4bb125771e5489b3ac609952b9ab18d85af406a42b83e54e74); /* line */ \n        coverage_0xb3fcc7e2(0x3334d7cb6ffe05ab7e919d400d1d25498e7dcd27bb876587b80b2e9f975c65f8); /* statement */ \nreturn true;\r\n    }\r\n\r\n    function addToken(\r\n        address _user,\r\n        address _tokenContract,\r\n        uint256 _value\r\n    ) private {coverage_0xb3fcc7e2(0x680ce8d2e5bfe65bb19fd1f829b973cda8f0fb026a126b4f35c1c033c7376eeb); /* function */ \n\r\ncoverage_0xb3fcc7e2(0xa775151dc32431a732705bd34f31ac116ef86b7e97b6a9d6389a3a143673dfca); /* line */ \n        coverage_0xb3fcc7e2(0x08d325f8afbffcb6a111c7a8c2eecd115f57977dbbccb899b3e52ff9fcd85259); /* statement */ \nif (_value == 0) {coverage_0xb3fcc7e2(0x8d817ecd4cc8aaba372151bb3dc63e19de485031277cf47ac4b87aaecb618903); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0x5d0faf2f37d6be8d095f94abd2dbdc079256bcdd43d19e1747756cb7273df765); /* line */ \n            coverage_0xb3fcc7e2(0xd6b3d6b378ca54f9becbac1a451ea694f87684596c2b4e79e8a3e01600ccdee4); /* statement */ \nreturn;\r\n        }else { coverage_0xb3fcc7e2(0xd537ea7c0d71bdb04285cdc93b04d35440287059718662872188dc957c8e0138); /* branch */ \n}\r\ncoverage_0xb3fcc7e2(0xd37c57fe688e34fa31983ce5571af8eebcde28b81e9c5a51e59c7715b1934c0e); /* line */ \n        coverage_0xb3fcc7e2(0xb8ad3b5c8aea06f2425f3655c4731f8772cd193458205ecbdd6f38047d33cd5a); /* statement */ \nUserFTWallet storage wallet = ftWallets[_user];\r\ncoverage_0xb3fcc7e2(0x4bab7a9212378f770028a8d7331721522d5f331db3d9071ba9b6b600971e58ed); /* line */ \n        coverage_0xb3fcc7e2(0xd759390d05454cee47db5bdc61ad7223a488f443ccaa98b1132393dd8a1c3e93); /* statement */ \nuint256 index = wallet.ftIndex[_tokenContract];\r\ncoverage_0xb3fcc7e2(0xf3d7876f08d26836773c906f94cb7ef8a6a0786e899a22d280c93f1f30e06832); /* line */ \n        coverage_0xb3fcc7e2(0x4d73c56776d1c128059600cede834a954610d1d69feb9e3eec9624bf05ecaf71); /* statement */ \nif (index == 0) {coverage_0xb3fcc7e2(0x588ba43fb951459a08306b62e12eb077829fcb8f36acf66198a30ee898014fa4); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0x939bec6e941ff76f23b3a6d710653648016975e43bd597822f747cd1f60190f2); /* line */ \n            coverage_0xb3fcc7e2(0x3a798eb716bc09f90ca7603cef6ae6db8d908e9c46ef5d266a091e0dc9eb3b65); /* statement */ \nindex = wallet.ftList.push(FTWallet(_tokenContract, 0));\r\ncoverage_0xb3fcc7e2(0x53c17561200f168f24762150ebe362853e1b74fa239ba5a8b3e034eca1dce6ea); /* line */ \n            coverage_0xb3fcc7e2(0xacd727af3e2221f2e39d0f66f759e163c12a35bb58e79d056f97807f139d459f); /* statement */ \nwallet.ftIndex[_tokenContract] = index;\r\n        }else { coverage_0xb3fcc7e2(0x450b57119d8c74d4ebdff442437a1ed88401ca8402c463f74207009d7a3d7c94); /* branch */ \n}\r\ncoverage_0xb3fcc7e2(0xaaf1364db019bcd0f315343bb9c0253b899529545b7e9b531c67ab651baa988d); /* line */ \n        coverage_0xb3fcc7e2(0xc746948d10ed09c24885908f8f8c6e2bc65481affb415bb6067e3fe93447c168); /* statement */ \nwallet.ftList[index - 1].balance += _value;\r\n    }\r\n\r\n    function removeToken(\r\n        address _user,\r\n        address _tokenContract,\r\n        uint256 _value\r\n    ) private returns (bool) {coverage_0xb3fcc7e2(0xa9bb915a16f8b62a958dc892a6594aadd5095013ea8362b7c6856265f15da195); /* function */ \n\r\ncoverage_0xb3fcc7e2(0xfa22aa882e417ee65cb81c25fadc312886a101a2be88c7a7dd115400bad9f4f4); /* line */ \n        coverage_0xb3fcc7e2(0x5ec41edee5d11447194a314e294a8279432ee3b2f7f2fc1e177b33456c37ca0c); /* statement */ \nif (_value == 0) {coverage_0xb3fcc7e2(0x06b6dc3acd43ca2648afb06313f88c9952ab0c0646eccb93c6675c26039a79b1); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0xc4ca3c50c436c73480c3d630f22a755ccb95d28e357573822f2d3b2db6deb3f7); /* line */ \n            coverage_0xb3fcc7e2(0xa65dd8c02eac735141eeaaf46a0be54de3c8848d4901aa401086fe5bc6712e55); /* statement */ \nreturn true;\r\n        }else { coverage_0xb3fcc7e2(0xa94e0a841fbe79cf840b1e980d395fb4c326b1cfb4e021af288891e0274792de); /* branch */ \n}\r\ncoverage_0xb3fcc7e2(0xe3bf354739b3cabe608bf8886f24a5c1bbd8d0519faa81c61e345f41226cb3a5); /* line */ \n        coverage_0xb3fcc7e2(0x5d7f6e130fef16753a24a57894607cdb623c5db1ac41dfe5b60fdff11e3149a7); /* statement */ \nUserFTWallet storage wallet = ftWallets[_user];\r\ncoverage_0xb3fcc7e2(0x0cd102ae44b40a41077502a5a9c87d7c909eee1159f57c3a79b5107b72cf2fc5); /* line */ \n        coverage_0xb3fcc7e2(0x77c7461ed2d15a12071759b3a89b55636ece72229d4c4010ba7e337b81984a05); /* statement */ \nuint256 walletIndex = wallet.ftIndex[_tokenContract];\r\ncoverage_0xb3fcc7e2(0x43fb941199cd792e8cf966b02a582a8bb125b86d20f05d30fb11a10c68741451); /* line */ \n        coverage_0xb3fcc7e2(0xf1f9b226157aff337d6dc2a71b6d2937cc3577363850da42e02f649946aac2d2); /* statement */ \nif (walletIndex == 0) {coverage_0xb3fcc7e2(0x0b06c2ee29a299358d01cd3cb1b97e5a7cdc022a28831f0582056209a6f04338); /* branch */ \n\r\n            // Wallet has no coins from given ERC20 contract\r\ncoverage_0xb3fcc7e2(0x37f6ab3b7a3ef39205ab624ad59e31c23a71be050a16e1725896a019a6802be5); /* line */ \n            coverage_0xb3fcc7e2(0xce41e34282e4c018e74e124dbd3e862c34dfed4449c21886df2f411b8d6f8711); /* statement */ \nreturn false;\r\n        }else { coverage_0xb3fcc7e2(0xfcbadaf30e79d8ed0ab29c56c4ba5aad8f2a934045cb7cc8f725d98d8a53948f); /* branch */ \n}\r\ncoverage_0xb3fcc7e2(0x297151ad1989e0bf2c01b500ac214afcce7e4620f9451150aeaaec7a0c6ee49d); /* line */ \n        coverage_0xb3fcc7e2(0xe025d66b6ddf37900712fdf6ac888f6ed2afeeec02fa2362491dd937291b14c3); /* statement */ \nFTWallet storage tokenWallet = wallet.ftList[walletIndex - 1];\r\ncoverage_0xb3fcc7e2(0xfd0d982ce6a3ffc08b3a33a5468f857f8a594feba7df9c5fb5eabfa3152c529d); /* line */ \n        coverage_0xb3fcc7e2(0xdcf3c3e7aa2723fa9579d91c78026a17a714fea08aab816ae035c33fe31f4433); /* statement */ \nif (_value > tokenWallet.balance) {coverage_0xb3fcc7e2(0xb766c711c5d4d3c1083c6c9b7306d9cec44ab02f69ccaf68bbe76c34e3204ce4); /* branch */ \n\r\n            // Wallet does not own enough ERC20 tokens\r\ncoverage_0xb3fcc7e2(0xfb9446733f39e9c158162757c3f9cce047e05a8aff29c7c832dc4aecb09febdd); /* line */ \n            coverage_0xb3fcc7e2(0xa35158c048fc4ab3475444e4bf5a7ad29917647de05e1b29204eb6c0f3d409e5); /* statement */ \nreturn false;\r\n        }else { coverage_0xb3fcc7e2(0xa84ca04fd38fb25c953e16556fffda8f2ee07ce22073b0b08076493232d64b2e); /* branch */ \n}\r\ncoverage_0xb3fcc7e2(0x13325e8124d09da4488409a2eabb77755dc30c001937d11ae9931b3a9e85d43b); /* line */ \n        coverage_0xb3fcc7e2(0x0f64e628a6d1b78b2ec67ce230b56b09d91a1b8bb0807b0b76c1317a187da963); /* statement */ \ntokenWallet.balance -= _value;\r\ncoverage_0xb3fcc7e2(0xd3a635ced573b70c50f25a67d5ee03e697952b3ed8db059c5d51530d65baf95b); /* line */ \n        coverage_0xb3fcc7e2(0x372211ee5bf00880a0e87aa102822bce725b6ff0e12bfdd343f6978aeba6bd22); /* statement */ \nif (tokenWallet.balance == 0) {coverage_0xb3fcc7e2(0x4dc08cb9bc85d142da2e2440790cdc2c066cc24b8ca191beb92ae720e6f9fa48); /* branch */ \n\r\ncoverage_0xb3fcc7e2(0xb7aed4c9529bb0e8bc3f095bd59adb503c6355598c84497a898c91b8d15fbf20); /* line */ \n            coverage_0xb3fcc7e2(0x61c1d2473fd9c04db8abb03c3e770dd8afc7705112a282973f8ca95fa2ddaee1); /* statement */ \nwallet.ftIndex[wallet.ftList[wallet.ftList.length - 1].contractAddress] = walletIndex;\r\ncoverage_0xb3fcc7e2(0xcdc457c42d179c4ce030c0671922c272fb236da2996aa56e952314b39f475f92); /* line */ \n            coverage_0xb3fcc7e2(0x71b9354c860d7a2e141883d2e66d0a1425f417027230fca91056ebc3c65c9290); /* statement */ \nwallet.ftList[walletIndex - 1] = wallet.ftList[wallet.ftList.length - 1];\r\ncoverage_0xb3fcc7e2(0x566ff96c9f6af5cc7a2a2cac6823637f77c2e0e0bb02bf9496b3cf0ebed2729e); /* line */ \n            delete wallet.ftIndex[_tokenContract];\r\ncoverage_0xb3fcc7e2(0x1a83c2309827ae46291d18e970bd201c3ecd1b6da5552aa0a59b531eb7ca5521); /* line */ \n            coverage_0xb3fcc7e2(0x619e4ceb0e88cb67231022f72651943e9b7632657f9ea0f96dc0ee1e8ccda554); /* statement */ \nwallet.ftList.pop();\r\n        }else { coverage_0xb3fcc7e2(0x5645382cf53c0ad78592041d9794c0d53fbe480e08b84e134fb1718e58fdbe34); /* branch */ \n}\r\ncoverage_0xb3fcc7e2(0x88fa0bcc60b149821d0085961e4b4c7cbe7c32d98ea82b51185c574fb87b0d0e); /* line */ \n        coverage_0xb3fcc7e2(0x8e2b7690cf0af8b51074eaf0133becae92f0f899b353cbe407512d903a83bb7a); /* statement */ \nreturn true;\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n// Taken from @openzeppelin with MIT License\r\n\r\npragma solidity ^0.5.11;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"
    },
    ".coverage_contracts/interfaces/IPairedErc20.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\ninterface IPairedErc20 {\r\n    function mint(address account, uint256 amount) external;\r\n\r\n    function burn(address account, uint256 amount) external;\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n"
    },
    ".coverage_contracts/inbox/GlobalInbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"./GlobalEthWallet.sol\";\r\nimport \"./GlobalFTWallet.sol\";\r\nimport \"./GlobalNFTWallet.sol\";\r\nimport \"./IGlobalInbox.sol\";\r\nimport \"./Messages.sol\";\r\nimport \"./PaymentRecords.sol\";\r\n\r\ncontract GlobalInbox is\r\n    IGlobalInbox,\r\n    GlobalEthWallet,\r\n    GlobalFTWallet,\r\n    GlobalNFTWallet,\r\n    PaymentRecords // solhint-disable-next-line bracket-align\r\n{\nfunction coverage_0xf49d70be(bytes32 c__0xf49d70be) public pure {}\n\r\n    uint8 internal constant ETH_TRANSFER = 0;\r\n    uint8 internal constant ERC20_TRANSFER = 1;\r\n    uint8 internal constant ERC721_TRANSFER = 2;\r\n    uint8 internal constant L2_MSG = 3;\r\n    uint8 internal constant INITIALIZATION_MSG = 4;\r\n    uint8 internal constant L2_CONTRACT_PAIR = 5;\r\n\r\n    struct Inbox {\r\n        bytes32 value;\r\n        uint256 count;\r\n    }\r\n\r\n    mapping(address => Inbox) private inboxes;\r\n\r\n    function getInbox(address account) external view returns (bytes32, uint256) {coverage_0xf49d70be(0xd4e558f9542fd18a25175d2d32652119fd1f23e76fb2edcf2beb3365587f566f); /* function */ \n\r\ncoverage_0xf49d70be(0xdfc6163a089751615c6d4d9d313313a94c2482696b34c628a0dc05f6a85f8285); /* line */ \n        coverage_0xf49d70be(0x64cb103e0233945fcb74a6a59651ec7dab4791dfe793f000e0cf68d4250566ff); /* statement */ \nInbox storage inbox = inboxes[account];\r\ncoverage_0xf49d70be(0xb48d6bdc898960a142f95a294031419838fb6756bfd5410a056bcd27feadb8ab); /* line */ \n        coverage_0xf49d70be(0xdfe8b7a290af58e5fe7e7a33cc00dc9f80e3995e069bd8a5bad2e4363faf7213); /* statement */ \nreturn (inbox.value, inbox.count);\r\n    }\r\n\r\n    /**\r\n     * @notice Process a set of marshalled messages confirmed by a rollup chain\r\n     * @dev messageCounts and nodeHashes are used to uniquely identify messages in conjunction with PaymentRecords\r\n     * @param messages Contiguously marshaled messages from a set of assertions\r\n     * @param initialMaxSendCount Previous total message count sent by this sender\r\n     * @param finalMaxSendCount Total message count sent by this sender after these messages\r\n     */\r\n    function sendMessages(\r\n        bytes calldata messages,\r\n        uint256 initialMaxSendCount,\r\n        uint256 finalMaxSendCount\r\n    ) external {coverage_0xf49d70be(0x99df5e60e59824005d3872fb987e86acf6e9b0bb3eba5b7ebf279b8e2aed7637); /* function */ \n\r\ncoverage_0xf49d70be(0x25a1fde8b048e1b1524a1b97ed0e16c1ffb7fcb31f4b1a5fa6dce8ad0782033b); /* line */ \n        coverage_0xf49d70be(0xbd21cc82ef83b02ba02a7446504303e1e4e90594f4eaf9f0911503348e5c0588); /* statement */ \nbool valid;\r\ncoverage_0xf49d70be(0xd94243fe248f10124d21015fa5869d1ab3e1369765c2dfa5b65f14c50c012641); /* line */ \n        coverage_0xf49d70be(0x3786c2c9052820346508f543cee2560d4b161db6b5615ee70c4da47e297473f6); /* statement */ \nuint256 offset = 0;\r\ncoverage_0xf49d70be(0x2dfc03b92a80479dedf35cca58cc7ac537f28271bab68dc4b17566096573cd24); /* line */ \n        coverage_0xf49d70be(0xd46d8c2417c0ee67c2569f9936e497849ffc6a95349cee1502260533603d1be3); /* statement */ \nMessages.OutgoingMessage memory message;\r\n\r\ncoverage_0xf49d70be(0x852fd9e6a37c152d72e32a4de839cf147ab8bc5be199b89eba73188a15711cac); /* line */ \n        coverage_0xf49d70be(0x3d31fe11cf1bec0d4ea388b52e0b44210023f208223428a91ad8aecb05f5c035); /* statement */ \nfor (uint256 i = initialMaxSendCount; i < finalMaxSendCount; i++) {\r\ncoverage_0xf49d70be(0xdc32475518ac3c075fee26aebe92a59bbfd65cc36a5ca69aacd353f7e537883c); /* line */ \n            coverage_0xf49d70be(0x37e07d4bc609bc90deca66e03566478a43ee48f631c6e0615601fe5d0288dc8f); /* statement */ \n(valid, offset, message) = Messages.unmarshalOutgoingMessage(messages, offset);\r\ncoverage_0xf49d70be(0x61b2a6c0a5f8af6bf7f3e2d808baa4b6835324733aa2f9c5276328e54a9aaaa6); /* line */ \n            coverage_0xf49d70be(0xb4506ad50a93fe4dcf32812d4a03b371ccb2d10947b9d9d25f14cd461549a1a0); /* statement */ \nif (!valid) {coverage_0xf49d70be(0xa7901693eb97383628f08d587b2e295c4b64dbc3279bf0c2be8518a592a0e078); /* branch */ \n\r\ncoverage_0xf49d70be(0x24936b2b98ce577e6857328f9573df045fbd45ca3efa13202833ef2ac9bab29a); /* line */ \n                coverage_0xf49d70be(0x2c3e415b05619ae9bbcb1edaef83b2ca8c7ad898eca7b190d48d044939b65a45); /* statement */ \nreturn;\r\n            }else { coverage_0xf49d70be(0xc3028c77ffb801ad3d9d9697632fada231193cb0bcdd0991087c6b73bd807532); /* branch */ \n}\r\ncoverage_0xf49d70be(0xaf04c8c8a0522ba1ed06fcaa955acf1f3b0406f645aedd59cef4ed5f7cb11e03); /* line */ \n            coverage_0xf49d70be(0x5fe4a7fe0e5f618c7f8194db23a76a41a8f68f851c174d7f947ca1bc7a889b19); /* statement */ \nsendDeserializedMsg(i, message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Send a generic L2 message to a given Arbitrum Rollup chain\r\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\r\n     * @param chain Address of the rollup chain that the ETH is deposited into\r\n     * @param messageData Data of the message being sent\r\n     */\r\n    function sendL2MessageFromOrigin(address chain, bytes calldata messageData) external {coverage_0xf49d70be(0x066cf22817452fed6b6ef4b86ac031e0e0ac56f870358d9e0316f9278909a5d4); /* function */ \n\r\n        // solhint-disable-next-line avoid-tx-origin\r\ncoverage_0xf49d70be(0x6c78e8ef9011149b3eca0895901f4f92727e2ba2f840e67039c170a79f2511e3); /* line */ \n        coverage_0xf49d70be(0xc13a81efd3990852901a65ee96ccaa9aec8b8bc0a3ca9e44a13c86ca82345006); /* assertPre */ \ncoverage_0xf49d70be(0x006bb23049cd5df574b8bd73bb9a262faafe4937509af1cb8f07b37e5515d16b); /* statement */ \nrequire(msg.sender == tx.origin, \"origin only\");coverage_0xf49d70be(0x81ac8eb760f32a30da9d3700c77c4f486347e24e76fbe0608c4e44ffbac3f206); /* assertPost */ \n\r\ncoverage_0xf49d70be(0x7be62c90e0952acd95d4fc64a3f7a8df3c1d93c69f968833dc99990479a5c9ca); /* line */ \n        coverage_0xf49d70be(0x8fe2a5f8bb381dd67dfaecb2b2c2ca6086e4dea354024f302d2b6217582904c5); /* statement */ \nuint256 inboxSeqNum = _deliverMessageImpl(\r\n            chain,\r\n            L2_MSG,\r\n            msg.sender,\r\n            keccak256(messageData)\r\n        );\r\ncoverage_0xf49d70be(0x7acc11c6b37892e6ef0482af4a09aa32b27ba6524d40e43c16b7da9675ccc81c); /* line */ \n        coverage_0xf49d70be(0xd3ce6be1de132290a204c049aeec1bbe8186bdb9e042566479108e930967bd07); /* statement */ \nemit MessageDeliveredFromOrigin(chain, L2_MSG, msg.sender, inboxSeqNum);\r\n    }\r\n\r\n    /**\r\n     * @notice Send a generic L2 message to a given Arbitrum Rollup chain\r\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\r\n     * @param chain Address of the rollup chain that the ETH is deposited into\r\n     * @param messageData Data of the message being sent\r\n     */\r\n    function sendL2Message(address chain, bytes calldata messageData) external {coverage_0xf49d70be(0xacbed9e6ac15a9012d266eef0c7dddf7bf604e45b833b54d657b32968db19ecf); /* function */ \n\r\ncoverage_0xf49d70be(0x272345f9efafd0a3016e5cca258efdbf3e852223ddbcbc7eea85ca290e31ba4e); /* line */ \n        coverage_0xf49d70be(0xea6f260f55d63cd6db4b3b90454ab8996889950bc74bc94cc97051865bb7920b); /* statement */ \n_deliverMessage(chain, L2_MSG, msg.sender, messageData);\r\n    }\r\n\r\n    function deployL2ContractPair(\r\n        address chain,\r\n        uint256 maxGas,\r\n        uint256 gasPriceBid,\r\n        uint256 payment,\r\n        bytes calldata contractData\r\n    ) external {coverage_0xf49d70be(0x8e5d4a5d5a3cd39a717fecca0969893769d04ad254e55851a7fd48923824756a); /* function */ \n\r\ncoverage_0xf49d70be(0xc609a4c516ca3fc9d0a6e78531d397bb852cbd98d1fa5514fa3e4e2a5a29ec51); /* line */ \n        coverage_0xf49d70be(0x7fe6a590fd535c658d0c48773f019313312c80ed58d4f957f2f20191bb3f49a4); /* assertPre */ \ncoverage_0xf49d70be(0x67e3c2e95b2c23ace740a04897c114c38b020efe7652f7c01a75afed1c839897); /* statement */ \nrequire(isContract(msg.sender), \"must be called by contract\");coverage_0xf49d70be(0x10aaa82f38a9cfc1b0c48e00e425c413b33a94b860edd3dd346b9872201600e3); /* assertPost */ \n\r\ncoverage_0xf49d70be(0x9e98295c6c39bbcf9e8b3f1825cce480647ef7c3d0476e761156305b0c476c2d); /* line */ \n        coverage_0xf49d70be(0xa06427bacbd0f0eb3b6e20c9dcd8d405419bbf994f707243bdc868ec99d90a3f); /* statement */ \nrequestPairing(msg.sender, chain);\r\ncoverage_0xf49d70be(0x7a8acaaff45da3e95885c8a52432b11413837f7662b05ecdd75bf8dfb396b117); /* line */ \n        coverage_0xf49d70be(0x92131dd6c984b8482027903846c7c5c74f786bf686d89fc9e7f307fb88a3ecfb); /* statement */ \n_deliverMessage(\r\n            chain,\r\n            L2_CONTRACT_PAIR,\r\n            msg.sender,\r\n            abi.encodePacked(maxGas, gasPriceBid, payment, contractData)\r\n        );\r\ncoverage_0xf49d70be(0x13bdd775c7e2f3d0cd206275415f47330137de079f61763a5893e01297bf25c0); /* line */ \n        coverage_0xf49d70be(0xf4f6a6ffb2023a5aa9557a9d238fc1668df5f567bf2486bb3b090729bad4c184); /* statement */ \nemit BuddyContractPair(msg.sender, chain);\r\n    }\r\n\r\n    /**\r\n     * @notice Send a generic L2 message to a given Arbitrum Rollup chain\r\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\r\n     * @param messageData Data of the message being sent\r\n     */\r\n    function sendInitializationMessage(bytes calldata messageData) external {coverage_0xf49d70be(0x63373fc3bef5812bb3a923c52c4394786faba3272ba7f319c55e6772f999c58c); /* function */ \n\r\ncoverage_0xf49d70be(0x0c61b54fc462296c0b049903d180129225ab2e82875c06e5332b2697f1889a39); /* line */ \n        coverage_0xf49d70be(0x480b49d6eb3184c4524338c4870f5070cb0a27bb41a57186b378006a622c9f51); /* statement */ \n_deliverMessage(msg.sender, INITIALIZATION_MSG, msg.sender, messageData);\r\n    }\r\n\r\n    /**\r\n     * @notice Deposits ETH into a given Arbitrum Rollup chain\r\n     * @dev This method is payable and will deposit all value it is called with\r\n     * @param chain Address of the rollup chain that the ETH is deposited into\r\n     * @param to Address on the rollup chain that will receive the ETH\r\n     */\r\n    function depositEthMessage(address chain, address to) external payable {coverage_0xf49d70be(0xc2904f59066f7afabb656539f2d46c181601ad070dcb54bd2b2daff373e0e63a); /* function */ \n\r\ncoverage_0xf49d70be(0x3cf32de4f51c846f209fe879f57a0c802cc1da61d3dfbf5bcc35cc9ea9acbcc6); /* line */ \n        coverage_0xf49d70be(0x8ee18af332cc95ffaa8420dd2a53697ff20d7d6f76ad3932d79e0d25d28c3197); /* statement */ \ndepositEth(chain);\r\ncoverage_0xf49d70be(0xe821a15bea95d22a1c90357bd06c4a10dce719b89699443fbb0eaf8709937be4); /* line */ \n        coverage_0xf49d70be(0x005f1185c25cde2defc50d3b6fba7f3e767407d12697b89412bc9f8fdb71bc3b); /* statement */ \n_deliverMessage(\r\n            chain,\r\n            ETH_TRANSFER,\r\n            msg.sender,\r\n            abi.encodePacked(uint256(uint160(bytes20(to))), msg.value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Deposits an ERC20 token into a given Arbitrum Rollup chain\r\n     * @dev This method requires approving this contract for transfers\r\n     * @param chain Address of the rollup chain that the token is deposited into\r\n     * @param erc20 L1 address of the token being deposited\r\n     * @param to Address on the rollup chain that will receive the tokens\r\n     * @param value Quantity of tokens being deposited\r\n     */\r\n    function depositERC20Message(\r\n        address chain,\r\n        address erc20,\r\n        address to,\r\n        uint256 value\r\n    ) external {coverage_0xf49d70be(0x6b4512f30b1e611c4962dee8d68fb3bba0f1c19659f8e28bb5698504ed48431c); /* function */ \n\r\ncoverage_0xf49d70be(0xf303ecef124a53776dddc89947bd280e7809c79ab90908d9688d951982bb47b0); /* line */ \n        coverage_0xf49d70be(0xb638e8e0eae0fffb766c0bf93db71937012b6a3eed4c89b1dd5de021b9939f61); /* statement */ \ndepositERC20(erc20, chain, value);\r\ncoverage_0xf49d70be(0x34740a2c1aee37f6915533b93f79ef53bafb499051726f5fabec7bd02c36e635); /* line */ \n        coverage_0xf49d70be(0x606a12d5f997c17d18609e84d2f1f1b70cc2991c0391837f9f4ea721e6eb5c57); /* statement */ \n_deliverMessage(\r\n            chain,\r\n            ERC20_TRANSFER,\r\n            msg.sender,\r\n            abi.encodePacked(uint256(uint160(bytes20(erc20))), uint256(uint160(bytes20(to))), value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Deposits an ERC721 token into a given Arbitrum Rollup chain\r\n     * @dev This method requires approving this contract for transfers\r\n     * @param chain Address of the rollup chain that the token is deposited into\r\n     * @param erc721 L1 address of the token being deposited\r\n     * @param to Address on the rollup chain that will receive the token\r\n     * @param id ID of the token being deposited\r\n     */\r\n    function depositERC721Message(\r\n        address chain,\r\n        address erc721,\r\n        address to,\r\n        uint256 id\r\n    ) external {coverage_0xf49d70be(0x1cd960f0d5f497e6eec1d77f84a45b415ba1c2e456714979a198c30f8842ccf2); /* function */ \n\r\ncoverage_0xf49d70be(0xfc9b590a65aba4d41a59fd43bdf9f19ac83e8a1d3bbfc42065350ad12d513d4f); /* line */ \n        coverage_0xf49d70be(0x21272a8616acd827ba832ccb9d2bd7dcbd18dc71177c80b38040645ac60db27a); /* statement */ \ndepositERC721(erc721, chain, id);\r\ncoverage_0xf49d70be(0x5aed29fee3e01c2495e25a1ca79857b94823b65aa97cfb02755334939ab24090); /* line */ \n        coverage_0xf49d70be(0x299937f32fa580eef422ca5d12713762764f31a9f89993e95468e97af2197b97); /* statement */ \n_deliverMessage(\r\n            chain,\r\n            ERC721_TRANSFER,\r\n            msg.sender,\r\n            abi.encodePacked(uint256(uint160(bytes20(erc721))), uint256(uint160(bytes20(to))), id)\r\n        );\r\n    }\r\n\r\n    function _deliverMessage(\r\n        address _chain,\r\n        uint8 _kind,\r\n        address _sender,\r\n        bytes memory _messageData\r\n    ) private {coverage_0xf49d70be(0x3752829fe0c2e6636948a81174910fe7efeb64f56e95e9c19c547a0ca00db83f); /* function */ \n\r\ncoverage_0xf49d70be(0xd0c03c572188c8a7f1fed4b2e827301b40c8d97a169ca8c80c09b173fc9593ff); /* line */ \n        coverage_0xf49d70be(0xee82d415b28a6e6fd37664d92eee7c30b8d45abd56637ee4e4532d46b9bec5c4); /* statement */ \nuint256 inboxSeqNum = _deliverMessageImpl(_chain, _kind, _sender, keccak256(_messageData));\r\ncoverage_0xf49d70be(0x3364bcd5c3a99e06024434d586a370f7be6bd916cb664417ab57fc8199a767e0); /* line */ \n        coverage_0xf49d70be(0x1a4dc42a34e07f17c4ab49b655f410fb38b045d18fc91a4b4273a92a1c70e4c5); /* statement */ \nemit MessageDelivered(_chain, _kind, _sender, inboxSeqNum, _messageData);\r\n    }\r\n\r\n    function _deliverMessageImpl(\r\n        address _chain,\r\n        uint8 _kind,\r\n        address _sender,\r\n        bytes32 _messageDataHash\r\n    ) private returns (uint256) {coverage_0xf49d70be(0xd35e1e6e47607a2a9215ed3b31d2e9bbd15347cfe6c0865f0c2acdf95686a5ea); /* function */ \n\r\ncoverage_0xf49d70be(0x14dd54c7ea0736beecc9d7f48c05391e5507d086a3e41115ad34650a83bfe9e8); /* line */ \n        coverage_0xf49d70be(0x1c1bbae5616414124e4ac639935fce3ed4762f157ddbbda2f37b72bfdff1b7d4); /* statement */ \nInbox storage inbox = inboxes[_chain];\r\ncoverage_0xf49d70be(0xd17f073ccd91536a9b06c61cbf2ac29d2ccaff24466d6ee1a08c7d5f260afe73); /* line */ \n        coverage_0xf49d70be(0xc31ce2788b6067fbf08c998e136b72811d56afc1166868a0cdabe7b4b4461f38); /* statement */ \nuint256 updatedCount = inbox.count + 1;\r\ncoverage_0xf49d70be(0x1592d727ca49c502fb9f97802db2872b1b92c043136320e5c9863e2a54671fc0); /* line */ \n        coverage_0xf49d70be(0x6e1ed20ceab08938b10b7bf5e88c2344c8545dbb735bc27ec1290a44303e198e); /* statement */ \nbytes32 messageHash = Messages.messageHash(\r\n            _kind,\r\n            _sender,\r\n            block.number,\r\n            block.timestamp, // solhint-disable-line not-rely-on-time\r\n            updatedCount,\r\n            _messageDataHash\r\n        );\r\ncoverage_0xf49d70be(0x2d91b45b8963799344fe5c895ac720ad41d4c8338d236ae7d2023d1da60330a9); /* line */ \n        coverage_0xf49d70be(0xa1c3b01743d96410f4e619a650069caf3bb69611dd0e316dcceb26a0cc9a6f38); /* statement */ \ninbox.value = Messages.addMessageToInbox(inbox.value, messageHash);\r\ncoverage_0xf49d70be(0xbeb5389abebfd1679ae2109c4cd754c897a26344ec628e96e694e00ba8fdf3bd); /* line */ \n        coverage_0xf49d70be(0x30262e9bc883e58d94f8ac391d7f04fa9cd2b96bc005904def913e84caa04542); /* statement */ \ninbox.count = updatedCount;\r\ncoverage_0xf49d70be(0x62598c6178ba1cc9adf65ea4914ea7997b937a005da43dc86be3e6665341ddf7); /* line */ \n        coverage_0xf49d70be(0x3def1a35a5be652cb3350a3b7cab7a08ba3f00ce90d8ebef475c5d04edfe2bf1); /* statement */ \nreturn updatedCount;\r\n    }\r\n\r\n    function sendDeserializedMsg(uint256 messageIndex, Messages.OutgoingMessage memory message)\r\n        private\r\n    {coverage_0xf49d70be(0x81a8360467ef76503c164cb4f70d7cf952579d441a940cce962a80a2e86c6846); /* function */ \n\r\ncoverage_0xf49d70be(0x247d3e031a6b0979c36a42011baff73bbe4772a81b7d383668cc2912caebdb40); /* line */ \n        coverage_0xf49d70be(0xe4d82ff658df7d51e1af37b308f79f81a43f9f530028ab48665291ad7a1f75bb); /* statement */ \nif (message.kind == ETH_TRANSFER) {coverage_0xf49d70be(0x1cfe7a027f26df399a65e817959c1ba8b1542b6b302328caa16d0c8467624b5d); /* branch */ \n\r\ncoverage_0xf49d70be(0x6089895af8bcec63ad4ed6f4f89519b1d91bbff078c010e5e9519f84153b7e0b); /* line */ \n            coverage_0xf49d70be(0x6b351ead6a5efe11d8dcbf7200fb683f41e999691b848d5165137f486f400f96); /* statement */ \n(bool valid, Messages.EthMessage memory eth) = Messages.parseEthMessage(message.data);\r\ncoverage_0xf49d70be(0xf6a0e0bc90257adf40cbb120635767d7615ab1ceea2c9636a4042f65019a4805); /* line */ \n            coverage_0xf49d70be(0xfc312773c4678c0b083f33f65300681adb5fab69e85fdd4b90a3812e73f70adc); /* statement */ \nif (!valid) {coverage_0xf49d70be(0x0cb0078a982b0a5f658c1bd0f8444a2b410bb66273eaee0229eeb2a2ec507029); /* branch */ \n\r\ncoverage_0xf49d70be(0xb3de2cf77f5da52dd96c52f340e28bd47cb7ca20709f7eea0ca7212bf5f51aa0); /* line */ \n                coverage_0xf49d70be(0x60a78b4d124e2543428d8583c62595d7f1e4ee933e8426d4f1b4e331815a040c); /* statement */ \nreturn;\r\n            }else { coverage_0xf49d70be(0xb5fca21c105f07d745e7a121d2f034929089e2678c6479edfd2ff33f300c74d4); /* branch */ \n}\r\n\r\ncoverage_0xf49d70be(0x2237c5feac7b9b116ab99cebbcad752215624bfb7be10b2b026db92c5f91d504); /* line */ \n            coverage_0xf49d70be(0x3d202678f2d2771f099d5274d25a88da5a2eadad5ceff61d1041d25aaea3773a); /* statement */ \naddress paymentOwner = getPaymentOwner(eth.dest, messageIndex);\r\ncoverage_0xf49d70be(0x4c10df7fae1247c6b39c2e1e433bf93bdacf3765cc0bab9e971873d148ccb7a3); /* line */ \n            coverage_0xf49d70be(0x6f8257e77bf3e0af5ca75138b27afa61af4ec60f4896db2a672f3658b15b1a46); /* statement */ \ndeletePayment(eth.dest, messageIndex);\r\ncoverage_0xf49d70be(0xa2ce6395be3165e890841b3f5d0dfb0e2f24f81e7b638fa8312b18497592151d); /* line */ \n            coverage_0xf49d70be(0x6a3166e82bd5a6aec90d2cf9c3e79a92b96cbb8df3d66a5f423854277e578018); /* statement */ \ntransferEth(msg.sender, paymentOwner, eth.value);\r\n        } else {coverage_0xf49d70be(0x167654a61341552becb71169b52a2434993def5bfd0d7c447e747dc446ffa1d6); /* statement */ \ncoverage_0xf49d70be(0x5400a956141113885dd774aa78af4d28cc55d9139ad7fb6eb72cb32f316da41d); /* branch */ \nif (message.kind == ERC20_TRANSFER) {coverage_0xf49d70be(0x1d8dba658b69062b703b59096f96bb08a0e3990af81ef188acbff25a2761d9e8); /* branch */ \n\r\ncoverage_0xf49d70be(0x8b9386085ef2a95d3a1290faa7e17f891275be597c92a754bf351cfa8de7800d); /* line */ \n            coverage_0xf49d70be(0x7676a7f46e0a67b082b36ccd7e7bdc3631cba78b8769c0fbaf9d426843393c4c); /* statement */ \n(bool valid, Messages.ERC20Message memory erc20) = Messages.parseERC20Message(\r\n                message.data\r\n            );\r\ncoverage_0xf49d70be(0x1ba75c1638205adba38d8bc4a42b511b312e8079e0e3c4ecf6f4096c0d2aa01f); /* line */ \n            coverage_0xf49d70be(0xc00e0be588c83760f29cce02bfcc8ee868c8c49b0e473b7a2722a880745d6f69); /* statement */ \nif (!valid) {coverage_0xf49d70be(0xe05a5ed03b6d089dc268a011feb1c04854bd6520b170d52b31bc2f4829ef9559); /* branch */ \n\r\ncoverage_0xf49d70be(0xe7f8f07ff5a5ef70b6d937b907ab28b8adc79a08b5d8ef78dcea1ddef62875ef); /* line */ \n                coverage_0xf49d70be(0x5ee34cf8fff5f734263aac38d65c00a2e060bc041f8efb217b3642e9e4e00d22); /* statement */ \nreturn;\r\n            }else { coverage_0xf49d70be(0xb9b1e29d87b1d359969901e005853b991efefb9e7b09485663b8aa17dcb5c202); /* branch */ \n}\r\n\r\ncoverage_0xf49d70be(0x126016c31dfaa1084dc3f74699ecff7f5f3a18297477cdaac5f5884741c7a29e); /* line */ \n            coverage_0xf49d70be(0x8ae4b748c9b2078bfcc127745818501d45c5bbf13eb3d78ba5590f09fbeb8076); /* statement */ \naddress paymentOwner = getPaymentOwner(erc20.dest, messageIndex);\r\ncoverage_0xf49d70be(0x4eec775fb906849233f2be0ed92a811a08d67e4ee3d7455144176abfd7883659); /* line */ \n            coverage_0xf49d70be(0x9d26a558746f12fe323fabf7a371a80695dd07bba0bfe89bb0d34f697074267e); /* statement */ \ntransferERC20(msg.sender, paymentOwner, erc20.token, erc20.value);\r\ncoverage_0xf49d70be(0xeb491bbd80af85e32b79af931ef7926f8e5bd5c0b18ff063fb42f79a8fa8babf); /* line */ \n            coverage_0xf49d70be(0x873c0b209a94741bda04a82014353f90db25be7b28af93c25a4a5110b2aa791e); /* statement */ \ndeletePayment(erc20.dest, messageIndex);\r\n        } else {coverage_0xf49d70be(0xa72026c63cc8f5328fdafba3dbf223d887b182dbd89c445a09fc6e7062ce1022); /* statement */ \ncoverage_0xf49d70be(0xed84c5fad12d73390f7024ca18b4373bbc901620c4235d0fb58c23af8348d8ca); /* branch */ \nif (message.kind == ERC721_TRANSFER) {coverage_0xf49d70be(0x065ea126b34b70d73962e5ab765f28f473144c574196e1b7d62c94b01bb0e990); /* branch */ \n\r\ncoverage_0xf49d70be(0xdf1808530e9c3bc319231d1ffa71cbd0f3f0bb02796469371a23446f6be35823); /* line */ \n            coverage_0xf49d70be(0x7b4b60087330b83e8e4653b6afb1b6980997e8ec9f5f8d00602cc405430b8c88); /* statement */ \n(bool valid, Messages.ERC721Message memory erc721) = Messages.parseERC721Message(\r\n                message.data\r\n            );\r\ncoverage_0xf49d70be(0xb9020e1ec848119daf612d4895f12c658129d9d564a468729025d28e427bd5e9); /* line */ \n            coverage_0xf49d70be(0x473ea766c528b97850394134f907b88d328a67b72c3bdc1f110a4f5352f79932); /* statement */ \nif (!valid) {coverage_0xf49d70be(0x06b0458a1bbff168162f0ecf1a5770858f939a4c85c76dccfe3353722a5694cc); /* branch */ \n\r\ncoverage_0xf49d70be(0x5e6f195faa26cd98bee5164d3743cf5ea1621cfb4ebcc0df5802fdd17a8a29f3); /* line */ \n                coverage_0xf49d70be(0x422d443a79078042095b4265a0af0b6ccdba8f20c6df109a14603e75bcf29fbc); /* statement */ \nreturn;\r\n            }else { coverage_0xf49d70be(0xfeb048aaffec5fef1d731cbb88f2cf98915281043aaa13821e44ac182f31255c); /* branch */ \n}\r\n\r\ncoverage_0xf49d70be(0x5e29e13835eac6f1cb3b98d17a116dd86a9aded48c97379c6231e680252ba21e); /* line */ \n            coverage_0xf49d70be(0x27cc3c236eb24bdbe538b7848eafef77b77b5c483f743c13c1a9ac8b16ec7009); /* statement */ \naddress paymentOwner = getPaymentOwner(erc721.dest, messageIndex);\r\ncoverage_0xf49d70be(0xf6852a1eff5fd215658083908a11c10021f9af59304444abb96e71eaca2824e9); /* line */ \n            coverage_0xf49d70be(0xa9ee911ce5aac6438e2b3a8d7c502b0d04650a4bb0517e3123382b5849fe2745); /* statement */ \ntransferNFT(msg.sender, paymentOwner, erc721.token, erc721.id);\r\ncoverage_0xf49d70be(0x7c7133afd060d4e93c309c4c2b19fb7a9c31d8bbd509d1fa249d2ab1b666c732); /* line */ \n            coverage_0xf49d70be(0xcb81539ebde44bb8f22e4657ef49e504adbde414589261d00bfc9abda6ca0404); /* statement */ \ndeletePayment(erc721.dest, messageIndex);\r\n        } else {coverage_0xf49d70be(0xa4478248835c895a4924a01c1ab8f721030bdf79ae12f899a864d36853ae37e9); /* statement */ \ncoverage_0xf49d70be(0x7dc60ec50c99f70798cbd37e0cc8b6b9a789cea34dbec28439e8748178405df9); /* branch */ \nif (message.kind == L2_CONTRACT_PAIR) {coverage_0xf49d70be(0xf873f2a341fb2632b25f50a007ed5a07e7efb53ffbebdbe99c483152192a02e4); /* branch */ \n\r\ncoverage_0xf49d70be(0xf197cab4a03fcca745767a9d99124d20222ea4c64dd454f5b2fab5eeafd93a0f); /* line */ \n            coverage_0xf49d70be(0xecd470af84b04eb0b159417906f3d0a7d01db07365ecaf83b5df8e53e5008080); /* statement */ \nupdatePairing(message.sender, msg.sender, message.data[0] != 0);\r\ncoverage_0xf49d70be(0x1529c6b6a6da382ce2c8fbab61d0b6daddfd7e76ff200a9ef9ad613c53bffb4a); /* line */ \n            coverage_0xf49d70be(0x37a060443ad5e65c858a0aaf1c17fea1b92a51d1ebc95b35ea8c3d292f4a5a03); /* statement */ \nemit BuddyContractDeployed(message.sender, message.data);\r\n        }else { coverage_0xf49d70be(0xccfbff3364b7222a80bfde48acb7e5eb8f90d6b3da4c615ec26e4a8ca31ab275); /* branch */ \n}}}}\r\n    }\r\n\r\n    // Implementation taken from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.1.0/contracts/utils/Address.sol)\r\n    function isContract(address account) private view returns (bool) {coverage_0xf49d70be(0x281f171d11aab52a531d0c7dfa91eb5f82fda8337817ce73b4a6afc841457b24); /* function */ \n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\ncoverage_0xf49d70be(0xa2abad6edaf8b25d8645caf8bd7af723bd815ed86dd369a539f29e80f7159cb1); /* line */ \n        coverage_0xf49d70be(0x6739ae2ca5411324895f6faf7b94ec55c1c14de44cf4c332c06a2151b279ddae); /* statement */ \nbytes32 codehash;\r\n\r\ncoverage_0xf49d70be(0xcec1ae853c8da40af168aeaed37a9dc913dbdee019de01d85b544896c1b72cf1); /* line */ \n        coverage_0xf49d70be(0x3602923d3e58afb2a5dc01ecfa39af88129669a1a6bbb690626d9cedbbd8f54a); /* statement */ \nbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\ncoverage_0xf49d70be(0xdecee58b331b7ecc7f28013154b4c69e40fbed99c119748978678f572d496607); /* line */ \n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\ncoverage_0xf49d70be(0xab28c570bb18bc2cb2558b667205dbb6f3be5be1e8927c715a1a2ea95980846a); /* line */ \n        coverage_0xf49d70be(0x756dacc8e8291cadb51e455a169c61c7746cf53ef431bc10038c990ad5c46162); /* statement */ \nreturn (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/inbox/GlobalNFTWallet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../interfaces/IERC721.sol\";\r\n\r\ncontract GlobalNFTWallet {\nfunction coverage_0x269c27f7(bytes32 c__0x269c27f7) public pure {}\n\r\n    struct NFTWallet {\r\n        address contractAddress;\r\n        mapping(uint256 => uint256) tokenIndex;\r\n        uint256[] tokenList;\r\n    }\r\n\r\n    struct UserNFTWallet {\r\n        mapping(address => uint256) nftWalletIndex;\r\n        NFTWallet[] nftWalletList;\r\n    }\r\n\r\n    mapping(address => UserNFTWallet) private nftWallets;\r\n\r\n    function ownedERC721s(address _owner) external view returns (address[] memory) {coverage_0x269c27f7(0xccba01c1b13bd45c57de486e40b6d6288651efc52c2d6b5228e40c8ff3475651); /* function */ \n\r\ncoverage_0x269c27f7(0x1c2369e4ad6c0531609880f351bdb6c35f99a625ce4b4d4df1197d78b0c1525b); /* line */ \n        coverage_0x269c27f7(0xa568195835de72132e733f961ec6a48933af1b15dcb889c478222cb811f3f750); /* statement */ \nUserNFTWallet storage wallet = nftWallets[_owner];\r\ncoverage_0x269c27f7(0x1788ae363a0263e2c5a746db1059ec68fb35ade57f189abaedb6aca0431b2814); /* line */ \n        coverage_0x269c27f7(0xd7a5e91819340514ce7aa7a859016e17c61696e59f6de1308d537a93d46d62c1); /* statement */ \naddress[] memory addresses = new address[](wallet.nftWalletList.length);\r\ncoverage_0x269c27f7(0xf91a86093812dbba52528ac71abb5bef195773e563ea3745356de9be3023d07a); /* line */ \n        coverage_0x269c27f7(0xa0bc9715e4e5962b9820b869153521a70d36480ab99c5dc0c8a3b6278f1b3dd0); /* statement */ \nuint256 addressCount = addresses.length;\r\ncoverage_0x269c27f7(0x50ae4aeeb007c0e5011254954941dc1afe3daa66b2f4f7e8d050922dc3c9107c); /* line */ \n        coverage_0x269c27f7(0xced2ddf602d258aaf2d4be6e2d3d5809481bfd02aa6d2e59dbc41f501fa857c0); /* statement */ \nfor (uint256 i = 0; i < addressCount; i++) {\r\ncoverage_0x269c27f7(0x556e6c8228560e342956d71fe4972a231004f220b9016971adeaa70a4986fc6f); /* line */ \n            coverage_0x269c27f7(0x8cabf9fe9a0493b06e8729e5db160133732c4e14ee9337307821e306944e145e); /* statement */ \naddresses[i] = wallet.nftWalletList[i].contractAddress;\r\n        }\r\ncoverage_0x269c27f7(0x60637abb96399d1874e9b77e61346f93e8df6f88f640452e5697ef47ccbb88bb); /* line */ \n        coverage_0x269c27f7(0x645e0b408f56340b2deca1d73a0592518e64a5b1ea6b27bc0a9250eeadd5a488); /* statement */ \nreturn addresses;\r\n    }\r\n\r\n    function getERC721Tokens(address _erc721, address _owner)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {coverage_0x269c27f7(0x0be7781b1f98c5da89b92c62946675fd6a60b8f471479149d2c35e4dd7bd61f9); /* function */ \n\r\ncoverage_0x269c27f7(0x9c66a08640d820e22ce64784de152018bd77028316dd70ba69b182dd1312f194); /* line */ \n        coverage_0x269c27f7(0x85fc1b356416ca046e7dbf431fe8770fd6f52aaeb13df62d7c2590dc01450fa9); /* statement */ \nUserNFTWallet storage wallet = nftWallets[_owner];\r\ncoverage_0x269c27f7(0xba6bcdc72ef35a320c1c22141e3dca48be5356ba046d39102a98effbc7847466); /* line */ \n        coverage_0x269c27f7(0xd8fca540ea480088abbfd31dc6b62e4a4aaef77b79e6788cd77aedeced95e254); /* statement */ \nuint256 index = wallet.nftWalletIndex[_erc721];\r\ncoverage_0x269c27f7(0x4649e9abdc9449d2d4681cbd3710648e773861f15307c83b8248070b2449581b); /* line */ \n        coverage_0x269c27f7(0xc31183f9f81332bbf9c7edf75cf52ba6ec29890db600b2da42ab6a8c98fb9a6c); /* statement */ \nif (index == 0) {coverage_0x269c27f7(0x06b9d8b77ce0e72997878e3051c6b74e9afc0781b42aca99c568574ca62c1bcf); /* branch */ \n\r\ncoverage_0x269c27f7(0xc5585153247e2a2d4cf6986b12c057cfebc6d79c40194039a2258563ddceb6b2); /* line */ \n            coverage_0x269c27f7(0x897108ddecba66a846719fe92e89ebc5fbe776c9667d212dbb0ce27299e10e12); /* statement */ \nreturn new uint256[](0);\r\n        }else { coverage_0x269c27f7(0x2e525cfecefaa6a8c3c8c97a47ac1aeffae6ef630397acaee26230a59b3b9ce5); /* branch */ \n}\r\ncoverage_0x269c27f7(0x3e78d895fa824cac89071dce0cc559bbaa36e1700ee2e04abfc4b80db64c2dd6); /* line */ \n        coverage_0x269c27f7(0x28bf809569125a4f481c9f15fe8f225463277e78f755b74e0b8462ae03b61ef0); /* statement */ \nreturn wallet.nftWalletList[index - 1].tokenList;\r\n    }\r\n\r\n    function hasERC721(\r\n        address _erc721,\r\n        address _owner,\r\n        uint256 _tokenId\r\n    ) external view returns (bool) {coverage_0x269c27f7(0x53e85cccb98cf7f212b9e7015797dacf2c667edca262d87354a074d7d2c5abb4); /* function */ \n\r\ncoverage_0x269c27f7(0x7d698b1f06dafcfd874442c28f2767044ec6b396817418634a7d39dc96e77324); /* line */ \n        coverage_0x269c27f7(0x7bd02d61d20d45a4cb23862099060c48fee9078e744bcb234202b96b6779755f); /* statement */ \nUserNFTWallet storage wallet = nftWallets[_owner];\r\ncoverage_0x269c27f7(0xbb986b28ca902fceeec75379ed28975a6ea435564ab844432ce059df5e78d2b3); /* line */ \n        coverage_0x269c27f7(0x17a6553da1585a8f3ea4418de9ac67a8ac916d57141a41111060bfebefcad836); /* statement */ \nuint256 index = wallet.nftWalletIndex[_erc721];\r\ncoverage_0x269c27f7(0xa0d18b663bf9559c0a46fb0d4ef1ab31c3929e6268548eb510963c2eab2a8999); /* line */ \n        coverage_0x269c27f7(0x9cfd438b4d0f14883fb60b6f1374fb4652eb26bd768f35087d3ed39f4bee0886); /* statement */ \nif (index == 0) {coverage_0x269c27f7(0xef9ff101356c7101b85f14197fa8c51352f453546c77bbb35b02608aa434f923); /* branch */ \n\r\ncoverage_0x269c27f7(0x80067bd080df7c0e18753902c9a82962e6e16b207da3e2b275711de3f8e2a343); /* line */ \n            coverage_0x269c27f7(0xb4a8335a8ed3971dc91afd86766af1e8563e29e90400e18c10210d1e4f4d4869); /* statement */ \nreturn false;\r\n        }else { coverage_0x269c27f7(0xd9e10cb2bd6ee13f343572514fbc13687cf8dc25dd0986b51c4041221787ff88); /* branch */ \n}\r\ncoverage_0x269c27f7(0x86595940fa7eadb7cd99d4d08009a6e958aeea702cc93fdd0da57075815d9bb1); /* line */ \n        coverage_0x269c27f7(0x23a0ad0ef835dfbefa693656b84af2e78199b0c2757f2f0e40a3485067c58750); /* statement */ \nreturn wallet.nftWalletList[index - 1].tokenIndex[_tokenId] != 0;\r\n    }\r\n\r\n    function withdrawERC721(address _erc721, uint256 _tokenId) external {coverage_0x269c27f7(0xba0cee3cc2d549c7755a069c099bc9c15d70f796ced98db187b56833b143beb4); /* function */ \n\r\ncoverage_0x269c27f7(0x6d0f94bc74e0d545402a62220c8cf6d174048c874120c2a5d77f21da989e5716); /* line */ \n        coverage_0x269c27f7(0x0a9fc9bc7e0309057fb3edeca7f4fc4a054a51d4bd6be7d9179f6f5e3838b244); /* assertPre */ \ncoverage_0x269c27f7(0xe0d3e697bbb90d3f5c81c51fae731643bd407e3895069d867169058e8bd73eae); /* statement */ \nrequire(removeNFTToken(msg.sender, _erc721, _tokenId), \"Wallet doesn't own token\");coverage_0x269c27f7(0xfcc1be93810fefda36de3a845f2c59d1bf4e56c8adb39e5102ddee4ad85c3bc6); /* assertPost */ \n\r\ncoverage_0x269c27f7(0xa9fd5ae9d3a1d4dfbab70e7d597694a82ef5a6d4ee72299c19de7a4607adbe63); /* line */ \n        coverage_0x269c27f7(0xed3c37d817c750ab9285d56bcfbeb78068171016d1c3587aa51d0f46b89e453d); /* statement */ \nIERC721(_erc721).safeTransferFrom(address(this), msg.sender, _tokenId);\r\n    }\r\n\r\n    function depositERC721(\r\n        address _erc721,\r\n        address _destination,\r\n        uint256 _tokenId\r\n    ) internal {coverage_0x269c27f7(0xcb3940155622c2f28856e2788f6b6496ac60e7c816ed9c39891896493fc60fe8); /* function */ \n\r\ncoverage_0x269c27f7(0xc21b560bcdd9317d2a74b3c8137c4379fc222b8249e77b388ec1c66802b1834d); /* line */ \n        coverage_0x269c27f7(0x760ac27d0678c9c749e2960b6d237615cd67efa0d9e54c0586d12c237f63eae9); /* statement */ \nIERC721(_erc721).transferFrom(msg.sender, address(this), _tokenId);\r\ncoverage_0x269c27f7(0x0ed826028db27b0defa012ec96b040f64c4aaf44005c38ee253895a14c9a9996); /* line */ \n        coverage_0x269c27f7(0x96f701a9760cf37b241439f97399fc4dc2e0664f0d5c090e249eb173bec8c369); /* statement */ \naddNFTToken(_destination, _erc721, _tokenId);\r\n    }\r\n\r\n    function transferNFT(\r\n        address _from,\r\n        address _to,\r\n        address _erc721,\r\n        uint256 _tokenId\r\n    ) internal returns (bool) {coverage_0x269c27f7(0xf196cf811ed7096eeda2d5a06ab8a060aead93b7c6599ab687a7826d26f5033d); /* function */ \n\r\ncoverage_0x269c27f7(0xc02ec26eec88925ce97853306d2895532a35bd7caaf8dd856e8fa455f833722f); /* line */ \n        coverage_0x269c27f7(0x1280a6f6e76f73e92cc4c602ff712c9b4c909b5d424aba43e8fc743c9c392e3c); /* statement */ \nif (!removeNFTToken(_from, _erc721, _tokenId)) {coverage_0x269c27f7(0xfb42cd42796ca34adf8e8ea5f93b93ae9a3f68148a067e198cf7bc7d240bea86); /* branch */ \n\r\ncoverage_0x269c27f7(0x02825e1873935b1892c1f5cc74cac7f7c536f3eac7aa5550b7ba1fb5cec6334f); /* line */ \n            coverage_0x269c27f7(0x2661dd7fba91207f7a52f1bb7b32f8aacabf7270e5cca0076aae97b432b0917e); /* statement */ \nreturn false;\r\n        }else { coverage_0x269c27f7(0x8c015d85511bf57687b757da7419eac3fe4d63a5e0d2b53127e85f5fd8c243e0); /* branch */ \n}\r\ncoverage_0x269c27f7(0x6ed48d8522f5b2615ced09c32e30047670562ba4a9420f39ad3d93bf1ff04249); /* line */ \n        coverage_0x269c27f7(0x1af365bc1abc7dded4a4f8222f6ae4d1a93560b6403435ba075797e6c178cf83); /* statement */ \naddNFTToken(_to, _erc721, _tokenId);\r\ncoverage_0x269c27f7(0x8b81e7655ed04556cc2ee27eaff2a5cdc8ae254e164d1481b3cc0a2a6c9fc5a4); /* line */ \n        coverage_0x269c27f7(0x95ecc2ceebd7f8ea2d9d32beddc1ff2d828fd2c1ffbb0c7011fa7abefd879f0e); /* statement */ \nreturn true;\r\n    }\r\n\r\n    function addNFTToken(\r\n        address _user,\r\n        address _erc721,\r\n        uint256 _tokenId\r\n    ) private {coverage_0x269c27f7(0x65fab6fb9ddcc09df2d7390a2d11200986f887788ef8fd57f2b0273700aa7af4); /* function */ \n\r\ncoverage_0x269c27f7(0x24eaf295cab3197549aaa19884676370fae0d413159dd9440201e65a5ee263b3); /* line */ \n        coverage_0x269c27f7(0x50cda3be9e28e821af96261a55673ebdd5ba21399d1d2a1db852ac0d24c3e927); /* statement */ \nUserNFTWallet storage wallet = nftWallets[_user];\r\ncoverage_0x269c27f7(0xd3b2daa5d52470e6fa959f6040959a55fa8919fcc369fdefba38f45aef794db6); /* line */ \n        coverage_0x269c27f7(0x1ac40f4857165b805b47395481efbb3071300bc8a4cef451910853662ba100fa); /* statement */ \nuint256 index = wallet.nftWalletIndex[_erc721];\r\ncoverage_0x269c27f7(0x885d63e138860eb3bbeea6c37d983e4ba776e56c7ef62687a7e761295a410275); /* line */ \n        coverage_0x269c27f7(0x7a734c7bdba7b92949c37f03d1350973bc1f5286392539dbf9185e758ab0f654); /* statement */ \nif (index == 0) {coverage_0x269c27f7(0x1552ed718d553df7056d0b3d83287ae22884877e059cb5286552a4f6f1313510); /* branch */ \n\r\ncoverage_0x269c27f7(0x3905595441049f117dd7d0d9217afd7ea38f97bbdfeb32e83cc1c582adac766e); /* line */ \n            coverage_0x269c27f7(0x6ba5fcdc8db791375b0ddcf94d76b47a0cbd57e19f988843adc42593b7fc4d1b); /* statement */ \nindex = wallet.nftWalletList.push(NFTWallet(_erc721, new uint256[](0)));\r\ncoverage_0x269c27f7(0x738c70b29c66ee74d14508c9ddac40e2f9463abca00223e3fec475a3a79fbd55); /* line */ \n            coverage_0x269c27f7(0x65171fef778a00343594bffa52dd27d720f3a93a57b047992c3ff2375c7c2aef); /* statement */ \nwallet.nftWalletIndex[_erc721] = index;\r\n        }else { coverage_0x269c27f7(0xeef864aef1c75fadf6a00c3aac6eb44ec17ae72c0fda3d32b314412fc32aa12c); /* branch */ \n}\r\ncoverage_0x269c27f7(0xe06d3e0bc95a2209e2045a2f201de36951c2df18fe820bfdb0e7e3546c8076b0); /* line */ \n        coverage_0x269c27f7(0xa85f3a4afef7be8f6c4a6db56bf9c2866a17ee1a7eab414a8c48bdb9729fe682); /* statement */ \nNFTWallet storage nftWallet = wallet.nftWalletList[index - 1];\r\ncoverage_0x269c27f7(0xec65a370e0a121c71dc0662dd5018cec176edb75ee92c53e3fae19f4fdf15a4d); /* line */ \n        coverage_0x269c27f7(0x3b08c650dacd90f24a791c0856bf1eac3c1ccac020273cc42137c28ea4b03b07); /* assertPre */ \ncoverage_0x269c27f7(0x6ee9dc23e4c340f91d72201bf37aa837cbf38c8f3cc7ceece37e732aaf3caa1b); /* statement */ \nrequire(nftWallet.tokenIndex[_tokenId] == 0, \"can't add already owned token\");coverage_0x269c27f7(0x0aa9f4a4bf162f3015574512a3c6378a5f846d0c4cf2e3589504d1a23ca8e361); /* assertPost */ \n\r\ncoverage_0x269c27f7(0xc81e406ebd036eb301cd0dd4678e4fc7a969b15a1fe26f7c8b56d05ba29d8a30); /* line */ \n        coverage_0x269c27f7(0x5a112596023a8045b948159c17a3251a52ef9a4387e2c8ce8113401ee7188a0b); /* statement */ \nnftWallet.tokenList.push(_tokenId);\r\ncoverage_0x269c27f7(0x55e6a5386bc9a28227e504f13ab1fa80146e1cdafbfb1b87cb619ae7f7c882fe); /* line */ \n        coverage_0x269c27f7(0xce31aa56bb93f3e117342e9e41653e2b08ca7ad2776a70e167dee84698910274); /* statement */ \nnftWallet.tokenIndex[_tokenId] = nftWallet.tokenList.length;\r\n    }\r\n\r\n    function removeNFTToken(\r\n        address _user,\r\n        address _erc721,\r\n        uint256 _tokenId\r\n    ) private returns (bool) {coverage_0x269c27f7(0x807cf514ac7b45c236899e61e4e227829a8dd5010387732e029a7370033d5bcd); /* function */ \n\r\ncoverage_0x269c27f7(0xf6eaf1ef611e677be73131649b53fb3a544b34d2172f9a239e672164f34a51ac); /* line */ \n        coverage_0x269c27f7(0xa3e1b687e934baf83ef0bb5e05232dcd1c6f2031fc76695c0a86460d801c3452); /* statement */ \nUserNFTWallet storage wallet = nftWallets[_user];\r\ncoverage_0x269c27f7(0x4bfdb69785b86caad966e5587303fb37a454b6c8a7073514bdfb21e55bca4ac7); /* line */ \n        coverage_0x269c27f7(0x1ad2f80863f327e02d86dbcdbebadaaa00540b441af7025a8476f8ab63ad47f0); /* statement */ \nuint256 walletIndex = wallet.nftWalletIndex[_erc721];\r\ncoverage_0x269c27f7(0x6a9fd0436dfc4d24e8fa45be89b16a5fa4e9569cef725d7358c41a70ad13ead9); /* line */ \n        coverage_0x269c27f7(0xbb3369c8b83051d406e28868aa531de9603907385f98feeba08ef28ef4c2f487); /* statement */ \nif (walletIndex == 0) {coverage_0x269c27f7(0x37e0f81d067f37dddb3c84f2910934988e8d57a6fed499e0fd310741c015c7de); /* branch */ \n\r\n            // Wallet has no coins from given NFT contract\r\ncoverage_0x269c27f7(0x8bdd5075930277067d9fc1544a2403762d94002750ea91c2f7638739ff485556); /* line */ \n            coverage_0x269c27f7(0x4a835f735aa9d0240829f5bf26dda464c913c4d57ee23544a7288a08eda64c28); /* statement */ \nreturn false;\r\n        }else { coverage_0x269c27f7(0xb1069e5e9beb7e1417f2853844ccd267687e3ce290c29a72900105880f2a079d); /* branch */ \n}\r\ncoverage_0x269c27f7(0xd2be427713a85265f0b416a5998a92503342cbefddcb36704c3e23a61d668c1e); /* line */ \n        coverage_0x269c27f7(0x9f38714434b43067ad6716ef4fd39872c190fdcdc50e855d73cdb97bdfedc795); /* statement */ \nNFTWallet storage nftWallet = wallet.nftWalletList[walletIndex - 1];\r\ncoverage_0x269c27f7(0x3a9a9497ec628228dccf6facef0bcf4df40c2436de1627ee414bac935628d861); /* line */ \n        coverage_0x269c27f7(0xfe0710b78c92ec043bd62c59383796706050f3dc97b333b89b4323a9de9ddd8d); /* statement */ \nuint256 tokenIndex = nftWallet.tokenIndex[_tokenId];\r\ncoverage_0x269c27f7(0x1bcf6cd53ae645c9b3be0ac9d31b555990466f8aaafd4297078468bf06c81bae); /* line */ \n        coverage_0x269c27f7(0x08d0bd118934e85aba7e472ccc33a61b75c3e42c39d1ca990b85bdf29f88b756); /* statement */ \nif (tokenIndex == 0) {coverage_0x269c27f7(0x91e4d8d5c2a25034fd30f2e34751278d84cbc7441775b56b3249907c54f36223); /* branch */ \n\r\n            // Wallet does not own specific NFT\r\ncoverage_0x269c27f7(0xed4dd92bc2a58e43a9cf8e98554686b252efd6ccdafb9cab5d45fa168fb7a0b0); /* line */ \n            coverage_0x269c27f7(0xa0de9af1174242a2d6d581980e14247ffc8ceb4fe248216ded4c7fff89c6af04); /* statement */ \nreturn false;\r\n        }else { coverage_0x269c27f7(0x1918a02b165bb7c2f5adcfe5924390212813bdc6925ff36b32b45dfdda03b19b); /* branch */ \n}\r\ncoverage_0x269c27f7(0x10be05e928f3a8d97f679e5ba979a3379b6b96102060438a383dd4072a22d0fa); /* line */ \n        coverage_0x269c27f7(0xee3337fb5f39ebb90605bf1a6ee58b898ef45f67dd16b166e3ab132761af653f); /* statement */ \nnftWallet.tokenIndex[nftWallet.tokenList[nftWallet.tokenList.length - 1]] = tokenIndex;\r\ncoverage_0x269c27f7(0xfe1cb1fc16bb9064b64064d95b8ca9637a96851de5dc36c5f7003e1b337e21d0); /* line */ \n        coverage_0x269c27f7(0x5b3d0f1a6aeee46203b628301b32274c6397dd41eb9dd83bdcd2a2dbfb8d6ae7); /* statement */ \nnftWallet.tokenList[tokenIndex - 1] = nftWallet.tokenList[nftWallet.tokenList.length - 1];\r\ncoverage_0x269c27f7(0xd97b9b405f301b625c088a76abd908eddd9beaf4e5b224e721f44a0ec3e1061a); /* line */ \n        delete nftWallet.tokenIndex[_tokenId];\r\ncoverage_0x269c27f7(0xaca79a91b1728aa1e80c64f3ed5a2fc4a476d48b2ecd59efcf69e806359c6080); /* line */ \n        coverage_0x269c27f7(0xe7ca4f69c4be9c782167f15838e343730c744f99698d0051b655621fb3efccf9); /* statement */ \nnftWallet.tokenList.pop();\r\ncoverage_0x269c27f7(0x59f719e1da74b14f807bc9b26c412366a5ee51750c71cf4e8ac2ebb62ed124d9); /* line */ \n        coverage_0x269c27f7(0x153377cb73c6ba98beff71c05992131d21b76c2f797cf43e22ded663286651d8); /* statement */ \nif (nftWallet.tokenList.length == 0) {coverage_0x269c27f7(0xe2dbf125cf459c8908b2736667c7bec0fcc7fb9c7e5c26d834281b93038d5b0d); /* branch */ \n\r\ncoverage_0x269c27f7(0x7feeda21ea3815dfd5a51e9ee4414239294acfb2810d2e78fbc081dfb41390ca); /* line */ \n            coverage_0x269c27f7(0xcac399a7d5aff164639be3d1d180e99b4a1f41e966fa07af6f62bcd10dcc8ff3); /* statement */ \nwallet.nftWalletIndex[wallet.nftWalletList[wallet.nftWalletList.length - 1]\r\n                .contractAddress] = walletIndex;\r\ncoverage_0x269c27f7(0xa4a2f1292b8843054fb9ec57d44205d4f1cca057341c5265749376e697d4650c); /* line */ \n            coverage_0x269c27f7(0x0513b0147a4fcc36e0148ce7fe3eabfc9183ed8a72d23cf2bba834bb7daa5f09); /* statement */ \nwallet.nftWalletList[walletIndex - 1] = wallet.nftWalletList[wallet\r\n                .nftWalletList\r\n                .length - 1];\r\ncoverage_0x269c27f7(0xfb32e13f060453adeee7f61ed2fe19fd9ffe181070c50b86415f2b4bff55112e); /* line */ \n            delete wallet.nftWalletIndex[_erc721];\r\ncoverage_0x269c27f7(0xcaaf2a31c2ae86b93e47dceb9faf5cedd2a081af8e5196d7ef8dacf183e56dbd); /* line */ \n            coverage_0x269c27f7(0x2d680590532c69fd7ff808ec65f4670474ca8d8d50c71451083c269da7ea35a5); /* statement */ \nwallet.nftWalletList.pop();\r\n        }else { coverage_0x269c27f7(0x9c02ac63cde57fb48e72a02281205eaf7a91e3b3ca72f85946cabfa815899289); /* branch */ \n}\r\ncoverage_0x269c27f7(0x8fee4f3772f1196f9462d224b5905453c1de8a4273325a9d287f73388f9296bf); /* line */ \n        coverage_0x269c27f7(0x6303c4a08b083bbe39e1a75c494656795f6ec03d614e6a5dd1e8f7f69ba2becb); /* statement */ \nreturn true;\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.11;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\n/* is ERC165 */\r\ninterface IERC721 {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes calldata data\r\n    ) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n"
    },
    ".coverage_contracts/inbox/IGlobalInbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\ninterface IGlobalInbox {\r\n    event MessageDelivered(\r\n        address indexed chain,\r\n        uint8 indexed kind,\r\n        address indexed sender,\r\n        uint256 inboxSeqNum,\r\n        bytes data\r\n    );\r\n\r\n    event MessageDeliveredFromOrigin(\r\n        address indexed chain,\r\n        uint8 indexed kind,\r\n        address indexed sender,\r\n        uint256 inboxSeqNum\r\n    );\r\n\r\n    event BuddyContractDeployed(address indexed sender, bytes data);\r\n    event BuddyContractPair(address indexed sender, address data);\r\n\r\n    function getInbox(address account) external view returns (bytes32, uint256);\r\n\r\n    function sendMessages(\r\n        bytes calldata _messages,\r\n        uint256 initialMaxSendCount,\r\n        uint256 finalMaxSendCount\r\n    ) external;\r\n\r\n    function sendInitializationMessage(bytes calldata messageData) external;\r\n\r\n    function sendL2Message(address chain, bytes calldata messageData) external;\r\n\r\n    function deployL2ContractPair(\r\n        address chain,\r\n        uint256 maxGas,\r\n        uint256 gasPriceBid,\r\n        uint256 payment,\r\n        bytes calldata contractData\r\n    ) external;\r\n}\r\n"
    },
    ".coverage_contracts/inbox/PaymentRecords.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\ncontract PaymentRecords {\nfunction coverage_0x191d35ef(bytes32 c__0x191d35ef) public pure {}\n\r\n    mapping(bytes32 => address) private payments;\r\n\r\n    event PaymentTransfer(\r\n        uint256 messageIndex,\r\n        address originalOwner,\r\n        address prevOwner,\r\n        address newOwner\r\n    );\r\n\r\n    function transferPayment(\r\n        address originalOwner,\r\n        address newOwner,\r\n        uint256 messageIndex\r\n    ) external {coverage_0x191d35ef(0x21bb660192f19948f0685ba8e5ba15208defb3daeccba00dd9cc435a90bc60c5); /* function */ \n\r\ncoverage_0x191d35ef(0xb4094752c13dd6a1b806e2712b2a0263f82ad38a69ba4800dad4cab46b16640f); /* line */ \n        coverage_0x191d35ef(0x6323de9457b9e26fcb12db860da7f928d6d4a3cd4e898db2c37bf4a684cacd21); /* statement */ \naddress currentOwner = getPaymentOwner(originalOwner, messageIndex);\r\ncoverage_0x191d35ef(0xedabf3aa3bef4b74084409509aba5b28a82743aadffa941430679068709b281c); /* line */ \n        coverage_0x191d35ef(0xb0b94c3171ccb515f3315190d6ad3ce01c7f852bee04636b6ab5cceeb955870c); /* assertPre */ \ncoverage_0x191d35ef(0xbca07b3d087d787fbac1fb65103d0eb46f6342282cd999b0a187ae550bfb4a74); /* statement */ \nrequire(msg.sender == currentOwner, \"Must be payment owner.\");coverage_0x191d35ef(0xbf0dd88f8e1e3a062294dda2c7c581c78384c53d6dbf96a72d1b4ca205f3965a); /* assertPost */ \n\r\n\r\ncoverage_0x191d35ef(0xccc8bb879d6abf221231bac60c4c1e013e2e96f43b21595b8392ffad0e3ece27); /* line */ \n        coverage_0x191d35ef(0x2bf193cd3dc18b7866e30f8c3bc7f39e9f46c5390927ef479f81a17f2b5af498); /* statement */ \npayments[keccak256(abi.encodePacked(messageIndex, originalOwner))] = newOwner;\r\n\r\ncoverage_0x191d35ef(0xe8a3a8350d96029b91a255a481e2d30fd91763d861a1a22b7745b104e04ddb83); /* line */ \n        coverage_0x191d35ef(0xff5dc87a205475fa0b2ca93c7de542020f34123f8a9d72d363afde5b984a8044); /* statement */ \nemit PaymentTransfer(messageIndex, originalOwner, currentOwner, newOwner);\r\n    }\r\n\r\n    function getPaymentOwner(address originalOwner, uint256 messageIndex)\r\n        public\r\n        view\r\n        returns (address)\r\n    {coverage_0x191d35ef(0x6aa07c66a678aaba1688d0ddf4c38385ae410ec015d12172bd8bb0bdfa42be95); /* function */ \n\r\ncoverage_0x191d35ef(0xb705055f356d588ef5f97e2810ef341fc2cf060784055bd4192430b209e5bcaf); /* line */ \n        coverage_0x191d35ef(0xb4ea0c879d4e37977ac5b18d2f5c7c5f09b1693ae73a696ddbfa0f78b39bdc96); /* statement */ \naddress currentOwner = payments[keccak256(abi.encodePacked(messageIndex, originalOwner))];\r\n\r\ncoverage_0x191d35ef(0x740298411e316e442097f67a9ccaef0a1a5c21c972b917596c90fd4bb1178461); /* line */ \n        coverage_0x191d35ef(0x9d08fce3ab58aaff22aa62842284eca437942ae6a228b3191243e48a08dfd193); /* statement */ \nif (currentOwner == address(0)) {coverage_0x191d35ef(0xe1cb3b4972bf5b707e75cf63816e96c5fae8ec5df73f4bce0c88f4c9604d52a0); /* branch */ \n\r\ncoverage_0x191d35ef(0x455ff247108dd7705a094f3b4618d1dd5a528b271788316a11bb9480f0f251a2); /* line */ \n            coverage_0x191d35ef(0x0903c49f6ebecda565e4be97b46a047b7fa0dc30a9a64786ccb6732321d8f970); /* statement */ \nreturn originalOwner;\r\n        } else {coverage_0x191d35ef(0x7db109f0da8768380c43043c1eefa03be75dbb3b4fe8d08e6257da1e6f235c8c); /* branch */ \n\r\ncoverage_0x191d35ef(0xd4d368c9f50db618128b793fd6ce3cee0bf5af54ca3c0fddbe6568e2e6257667); /* line */ \n            coverage_0x191d35ef(0x7b635dab241d3bc074a0e3f8d663300ef5fc88a33486f97a570c522641605221); /* statement */ \nreturn currentOwner;\r\n        }\r\n    }\r\n\r\n    function deletePayment(address originalOwner, uint256 messageIndex) internal {coverage_0x191d35ef(0xc00ef994c13a9f36f9c126258a0e0756229b1aee1d271505aba02e95a72cf408); /* function */ \n\r\ncoverage_0x191d35ef(0xf9017849e933bae145de67287a7553ea2598d09a54a9090ad15c38fd1eef264f); /* line */ \n        delete payments[keccak256(abi.encodePacked(messageIndex, originalOwner))];\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.11;\r\n\r\n// SafeMath comes from @openzeppelin under the MIT License\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\nfunction coverage_0x73f85bb9(bytes32 c__0x73f85bb9) public pure {}\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {coverage_0x73f85bb9(0x4f31e41db37b2a978b1a7777e4b2257c35356a87d654fdf9e489ae285c4c97cc); /* function */ \n\r\ncoverage_0x73f85bb9(0xc42907c0733e31af3d6be1ac2eb1c43397232fa4ed1caf603fb50b90daed2e34); /* line */ \n        coverage_0x73f85bb9(0xcd0110f65be07595f05b68841be166a848861904233dab1864a616680744a238); /* statement */ \nuint256 c = a + b;\r\ncoverage_0x73f85bb9(0xe99cc2a2a51fca742337cbb0314300d2a01160b0b773c9385201d3f0f83dff96); /* line */ \n        coverage_0x73f85bb9(0xa6a7178b42f27e2cdb2610faee141d12865aa9175d8c768d8ebb3b03f7791527); /* assertPre */ \ncoverage_0x73f85bb9(0x248bd6158c381b3c426e488e3a4d84783b157db46f4800557a278711cd4b2355); /* statement */ \nrequire(c >= a, \"addition overflow\");coverage_0x73f85bb9(0x6728fd219ced6b6645fd13e042028861f041d8d51cd99d45561c0e89a46d1721); /* assertPost */ \n\r\n\r\ncoverage_0x73f85bb9(0x785c3590083f19653a67f01f3c1a6f93280627311152d373a34d77bb600d1e4d); /* line */ \n        coverage_0x73f85bb9(0x6ed678c18918cd22d4ee577c097c425a89b985522ff75ccbef741c8b0942506e); /* statement */ \nreturn c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {coverage_0x73f85bb9(0x6a7daa8290a16b749f42e23f9a611726022c2d4b73d5a4921469184ed505f18c); /* function */ \n\r\ncoverage_0x73f85bb9(0xaa435288a8153887241e03c9adeaddc5b4d6170cacb736716c8291056f3d57f3); /* line */ \n        coverage_0x73f85bb9(0x302217fa2a3a2ffd81389701b6d5b456e451783d8f256c83591df0603efe4342); /* statement */ \nreturn sub(a, b, \"subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {coverage_0x73f85bb9(0x38e36e69c12289ff174f7041558d82fe19be10a9382e8453bb8b2cbb691eb6cf); /* function */ \n\r\ncoverage_0x73f85bb9(0x614f0527090f9c45389491c92a7ca27cc2aaeafedf9abfda88d4ddc43b9fff33); /* line */ \n        coverage_0x73f85bb9(0x350f5bc80e5f56f8cb3be10d146bf02473a989a65b2b8932d0f7079f0feb28a4); /* assertPre */ \ncoverage_0x73f85bb9(0x7c1561c535ec83348a10db3808c0f54bc81ddc68ee92a549e5c91fdb46a55546); /* statement */ \nrequire(b <= a, errorMessage);coverage_0x73f85bb9(0x75ef703b7ec350290e982d50954a6f98140c3a42e42896e0837ee91263de1e63); /* assertPost */ \n\r\ncoverage_0x73f85bb9(0xd4d6a298a9766c52b69387c0b6aae610e929f70a2fa57635cd243da7138981d8); /* line */ \n        coverage_0x73f85bb9(0x1703c8c59d27b5d486afd17a3c4440bf5f4b01915c17c11ab23385284707f262); /* statement */ \nuint256 c = a - b;\r\n\r\ncoverage_0x73f85bb9(0x553a538c999d6fdc6bb0e224f99d24239682b5da2fbeabe5eb692b3140c16e16); /* line */ \n        coverage_0x73f85bb9(0x97d5f32c8dc69c3dbbbcb2dfe249ca2cb265b7e2b33f8976d226bd0b04286b3c); /* statement */ \nreturn c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {coverage_0x73f85bb9(0x588c27a777c1dff7988545259e3de925c23657932927bdc50461e7cbd20163d7); /* function */ \n\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\ncoverage_0x73f85bb9(0x5acfaa71bd6f3a5e8f6e28716e5da1f1a47f6ee25da87cb07540fda2214d1de9); /* line */ \n        coverage_0x73f85bb9(0x9751260dde4a32a13eb77b8d06b2c88e6f00a9ebb83ed943aa76e2467c94dd9a); /* statement */ \nif (a == 0) {coverage_0x73f85bb9(0x120fbfb048f1e74eed3ae5857f5908cff5cef65c576320a02830f14250500259); /* branch */ \n\r\ncoverage_0x73f85bb9(0xf1e92306f117ab109d70a72b71e99f832cc4206201a398b118b582d55d906563); /* line */ \n            coverage_0x73f85bb9(0x94df05739aac289503a92a0ebbc8110a336058e6b2bc700323cffc936dceb2d6); /* statement */ \nreturn 0;\r\n        }else { coverage_0x73f85bb9(0x48ce0d1f5210d2799963080b00bb3641abf31d4dfef075f4895f1091b503ce86); /* branch */ \n}\r\n\r\ncoverage_0x73f85bb9(0x095edc3a8ec9c46c13e9165674e0e3d9389b3cce52d588c3d50afae99b400add); /* line */ \n        coverage_0x73f85bb9(0xa1ad3ce584b1241f870872ed13d751e1add6eb5dc155d0c066368f2859beb204); /* statement */ \nuint256 c = a * b;\r\ncoverage_0x73f85bb9(0x0f4e8d7e51a7fa71b319c1bbcc20d1114bf22b5645ab20750e16229cf97fd82b); /* line */ \n        coverage_0x73f85bb9(0x40a66efb971da3040519d66faa1963c19282c30739c23b730b636cdb64db448f); /* assertPre */ \ncoverage_0x73f85bb9(0xa48becb4b9e00252d5cf59273d7c3512855c79872007ffbb2dfe78ea58b3591e); /* statement */ \nrequire(c / a == b, \"multiplication overflow\");coverage_0x73f85bb9(0x6b362761b664c28ce8e7699b4529da8859ccad2ac3fe444048b7d47e4bd38f80); /* assertPost */ \n\r\n\r\ncoverage_0x73f85bb9(0xc03e097ce8cf7e1a1fd2caa960c1b6c2a038840b81d3a14fb4b2185a844387bb); /* line */ \n        coverage_0x73f85bb9(0xef1241ae1f10e98a093d036b99af379afc0e7d4e724c60b06135e76e331f502e); /* statement */ \nreturn c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {coverage_0x73f85bb9(0x2fc34f738c35cefc27de693ece4a0424af807307a14328cd093ddfa042c92fab); /* function */ \n\r\ncoverage_0x73f85bb9(0x876de2877d2b548a3af913fbc56b01bcb5bdbed972d3cdb4c4a56e0f49038b60); /* line */ \n        coverage_0x73f85bb9(0x37b4394b512d6838e25beef395e076f2e81e14cc943f5e0bf9db042d723bf339); /* statement */ \nreturn div(a, b, \"division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {coverage_0x73f85bb9(0x3ae074ac07e3e36430d0fc65f58324a0b09e3f44e6dc89a2c1d963325700cede); /* function */ \n\r\n        // Solidity only automatically asserts when dividing by 0\r\ncoverage_0x73f85bb9(0xebe4747ad9b4fd86a17eeb4ad01f005b34d176818c2e4dc02b0e46705261adba); /* line */ \n        coverage_0x73f85bb9(0x24474c726bbf75d675270731cf20abd3ffe7b1fffc46c848d4dec503ea2e668d); /* assertPre */ \ncoverage_0x73f85bb9(0x3c3ebdac6782b00cf8d7e7123d9b476baa3bc54e200e54c3a5747795784d187a); /* statement */ \nrequire(b > 0, errorMessage);coverage_0x73f85bb9(0xfb55aa8c65c430d0b1b998c364cc12c95738a6a10ddce58d1857fc4b43795c6e); /* assertPost */ \n\r\ncoverage_0x73f85bb9(0x857b4e1996716fd214591cdf8341a9c224bf6854594d570fcac14afdf5ed3edf); /* line */ \n        coverage_0x73f85bb9(0x1a8b83dcded6d9227979642037779851e86ff96a8b72781588af97a13ab17483); /* statement */ \nuint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\ncoverage_0x73f85bb9(0xcc90496e76f0be433ab60a0518d43f457182f8be73791b6e340fdb69163dce51); /* line */ \n        coverage_0x73f85bb9(0xbf0fde4fff419e1a10d1106e794d4ed5942f90a506634832ff6daeff20e75e72); /* statement */ \nreturn c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {coverage_0x73f85bb9(0x11b197e9727905f5bd7d85166e2819eb079de757224a189fb552aba7c017de93); /* function */ \n\r\ncoverage_0x73f85bb9(0xb645c27d15fb0e35910a8dece6f9e19b830bf27145c92507fcce6ded4060e827); /* line */ \n        coverage_0x73f85bb9(0xea4ad06a0230b8e498f3e95ce27253d11be33297364e2ad84e91e3dd918ceee3); /* statement */ \nreturn mod(a, b, \"modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {coverage_0x73f85bb9(0xd3c1528cbbcc32185ca0e6a6e51effe59ffbf5320ee2dcab0e762ac1a2218391); /* function */ \n\r\ncoverage_0x73f85bb9(0x146ebe1a9724239898fc17e6a2b1a597f43c1ad91ee773c1125e9648833f5c28); /* line */ \n        coverage_0x73f85bb9(0xfebc8ff60b488a1a2a7e37f5b8ac0226ff4539766724e178ae01debcee5ae127); /* assertPre */ \ncoverage_0x73f85bb9(0x1b643283b32425ddef7a1da180e080d0bea2ca9bbe12d2125550eb4317094e2a); /* statement */ \nrequire(b != 0, errorMessage);coverage_0x73f85bb9(0xedd590707209e806b7b0f0e99e3f30b6bd2cb2774e9688a3415d4847785b8057); /* assertPost */ \n\r\ncoverage_0x73f85bb9(0xe442df66bf21174653415c4de3a16a204f548cdab27a31403efe3f55883cdc93); /* line */ \n        coverage_0x73f85bb9(0x372509123dcd7fd6886bfad2c775fac1d2b306660894a34612ab730d288f7681); /* statement */ \nreturn a % b;\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/rollup/ArbFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../libraries/CloneFactory.sol\";\r\n\r\nimport \"./IArbRollup.sol\";\r\n\r\ncontract ArbFactory is CloneFactory {\nfunction coverage_0xbc6dcfaf(bytes32 c__0xbc6dcfaf) public pure {}\n\r\n    event RollupCreated(address rollupAddress);\r\n\r\n    ICloneable public rollupTemplate;\r\n    address public globalInboxAddress;\r\n    address public challengeFactoryAddress;\r\n\r\n    constructor(\r\n        ICloneable _rollupTemplate,\r\n        address _globalInboxAddress,\r\n        address _challengeFactoryAddress\r\n    ) public {coverage_0xbc6dcfaf(0xe7d27b88284950eb8a11e422997524da13ce889910dd2182e8591a7480c5de1e); /* function */ \n\r\ncoverage_0xbc6dcfaf(0x407d3bac64f8a5e2ef96c6613ad59027be8c6fe7970b27444b3f6ef0ea3360cf); /* line */ \n        coverage_0xbc6dcfaf(0xdbd6bacaa571b0f5829de8a8cc45cf92a4c1c98b58272ed71365991ec44ec35d); /* statement */ \nrollupTemplate = _rollupTemplate;\r\ncoverage_0xbc6dcfaf(0x227a4bfe788dbfebb023ae1ba64bb365dd7181de1bb70ef6a0fd389c52035437); /* line */ \n        coverage_0xbc6dcfaf(0x2f191098bef9a59a750e76913f527755b65fc7648b64a5f3275ca120510e8b90); /* statement */ \nglobalInboxAddress = _globalInboxAddress;\r\ncoverage_0xbc6dcfaf(0x454f576c25f60fb7f28a715c56ee8b8dbfbbe4cd7f53f6530d59609be920ec2c); /* line */ \n        coverage_0xbc6dcfaf(0x2fd8ce1a924b7eb350486150787fd2c6a87516113356d4a477a45b31a69186de); /* statement */ \nchallengeFactoryAddress = _challengeFactoryAddress;\r\n    }\r\n\r\n    function createRollup(\r\n        bytes32 _vmState,\r\n        uint128 _gracePeriodTicks,\r\n        uint128 _arbGasSpeedLimitPerTick,\r\n        uint64 _maxExecutionSteps,\r\n        uint128 _stakeRequirement,\r\n        address _stakeToken,\r\n        address payable _owner,\r\n        bytes calldata _extraConfig\r\n    ) external {coverage_0xbc6dcfaf(0x7c1c3471c43cf92f4222193681f2c63048c8c2733a82a40f22adbb2aad6f18c9); /* function */ \n\r\ncoverage_0xbc6dcfaf(0x84292c50854735a64b26b49232901efbb727afd1a63dd8b8adb3c8be3377d826); /* line */ \n        coverage_0xbc6dcfaf(0xa3ee42b5ee1f2259bd93861192d52556defa07585684ab4f14028ac4b6623d8a); /* statement */ \naddress clone = createClone(rollupTemplate);\r\ncoverage_0xbc6dcfaf(0xe94e38f7701b5340046118cdefbae82abcbfc909a85d1acf4fbec6aedb78975c); /* line */ \n        coverage_0xbc6dcfaf(0xeeec4725cef6168b714004550b36c70c31655fdbf67bde70b1ddcd4ea60692c9); /* statement */ \nIArbRollup(clone).init(\r\n            _vmState,\r\n            _gracePeriodTicks,\r\n            _arbGasSpeedLimitPerTick,\r\n            _maxExecutionSteps,\r\n            _stakeRequirement,\r\n            _stakeToken,\r\n            _owner,\r\n            challengeFactoryAddress,\r\n            globalInboxAddress,\r\n            _extraConfig\r\n        );\r\ncoverage_0xbc6dcfaf(0x6a3fc88586857c390aaa50da18262bb0c4affa9757ec6864d25bb84a8e87cea7); /* line */ \n        coverage_0xbc6dcfaf(0xcdbc0cce224257a5ef4ec304790a39209b14aa12db152e6c02e0da1d61755f21); /* statement */ \nemit RollupCreated(clone);\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/rollup/IArbRollup.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\ninterface IArbRollup {\r\n    function init(\r\n        bytes32 _vmState,\r\n        uint128 _gracePeriodTicks,\r\n        uint128 _arbGasSpeedLimitPerTick,\r\n        uint64 _maxExecutionSteps,\r\n        uint128 _stakeRequirement,\r\n        address _stakeToken,\r\n        address payable _owner,\r\n        address _challengeFactoryAddress,\r\n        address _globalInboxAddress,\r\n        bytes calldata _extraConfig\r\n    ) external;\r\n}\r\n"
    },
    ".coverage_contracts/rollup/ArbRollup.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"./IArbRollup.sol\";\r\nimport \"./NodeGraph.sol\";\r\nimport \"./Staking.sol\";\r\nimport \"../inbox/IGlobalInbox.sol\";\r\nimport \"../libraries/Cloneable.sol\";\r\n\r\ncontract ArbRollup is IArbRollup, Cloneable, NodeGraph, Staking {\nfunction coverage_0xe495bf77(bytes32 c__0xe495bf77) public pure {}\n\r\n    // invalid path proof\r\n    string private constant PLACE_LEAF = \"PLACE_LEAF\";\r\n\r\n    // invalid leaf\r\n    string private constant MOVE_LEAF = \"MOVE_LEAF\";\r\n\r\n    // invalid path proof\r\n    string private constant RECOV_PATH_PROOF = \"RECOV_PATH_PROOF\";\r\n    // Invalid conflict proof\r\n    string private constant RECOV_CONFLICT_PROOF = \"RECOV_CONFLICT_PROOF\";\r\n    // Proof must be of nonzero length\r\n    string private constant RECVOLD_LENGTH = \"RECVOLD_LENGTH\";\r\n    // invalid leaf\r\n    string private constant RECOV_DEADLINE_LEAF = \"RECOV_DEADLINE_LEAF\";\r\n    // Node is not passed deadline\r\n    string private constant RECOV_DEADLINE_TIME = \"RECOV_DEADLINE_TIME\";\r\n\r\n    // invalid staker location proof\r\n    string private constant MAKE_STAKER_PROOF = \"MAKE_STAKER_PROOF\";\r\n\r\n    // Type is not invalid\r\n    string private constant CONF_INV_TYPE = \"CONF_INV_TYPE\";\r\n    // Node is not passed deadline\r\n    string private constant CONF_TIME = \"CONF_TIME\";\r\n    // There must be at least one staker\r\n    string private constant CONF_HAS_STAKER = \"CONF_HAS_STAKER\";\r\n\r\n    // Only callable by owner\r\n    string private constant ONLY_OWNER = \"ONLY_OWNER\";\r\n\r\n    string public constant VERSION = \"0.7.2\";\r\n\r\n    address payable public owner;\r\n\r\n    IGlobalInbox public globalInbox;\r\n\r\n    event RollupCreated(\r\n        bytes32 initVMHash,\r\n        uint128 gracePeriodTicks,\r\n        uint128 arbGasSpeedLimitPerTick,\r\n        uint64 maxExecutionSteps,\r\n        uint128 stakeRequirement,\r\n        address owner,\r\n        bytes extraConfig\r\n    );\r\n\r\n    event ConfirmedAssertion(bytes32[] logsAccHash);\r\n\r\n    event ConfirmedValidAssertion(bytes32 indexed nodeHash);\r\n\r\n    function init(\r\n        bytes32 _vmState,\r\n        uint128 _gracePeriodTicks,\r\n        uint128 _arbGasSpeedLimitPerTick,\r\n        uint64 _maxExecutionSteps,\r\n        uint128 _stakeRequirement,\r\n        address _stakeToken,\r\n        address payable _owner,\r\n        address _challengeFactoryAddress,\r\n        address _globalInboxAddress,\r\n        bytes calldata _extraConfig\r\n    ) external {coverage_0xe495bf77(0x9b1888562e0c15ff909cc4a271b14343c80cec3081cf3ea9866689ed36e14dbc); /* function */ \n\r\ncoverage_0xe495bf77(0x0b065c221b37658bd17a0ae5ffcccca9b0f9343f56f404f7ca0c3b0ee68c5e3c); /* line */ \n        coverage_0xe495bf77(0x2bd54ccf888ff8c60b7aea48eae7338fd0cf085b8d2117d02c9cec1d6f541e97); /* statement */ \nemit RollupCreated(\r\n            _vmState,\r\n            _gracePeriodTicks,\r\n            _arbGasSpeedLimitPerTick,\r\n            _maxExecutionSteps,\r\n            _stakeRequirement,\r\n            _owner,\r\n            _extraConfig\r\n        );\r\n\r\ncoverage_0xe495bf77(0x797344592f2755c3a037b39ab442f086af24e27d08f584149dc58645079eea9f); /* line */ \n        coverage_0xe495bf77(0x07d715e10d2b63f40ae27677d73a9fb5b35548660c6a52bb4acd0ec13935ff98); /* statement */ \nNodeGraph.init(_vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps);\r\ncoverage_0xe495bf77(0x96909e0c4484e7af1d4b90843c1d5afe2aae847b03361142c0a03e55a61586c8); /* line */ \n        coverage_0xe495bf77(0x4b622e22e7ab9b79f34ffbb63f8b7cfa1a5ffdf184c859b609c3dd683edb2c88); /* statement */ \nStaking.init(_stakeRequirement, _stakeToken, _challengeFactoryAddress);\r\ncoverage_0xe495bf77(0xe0433bbab2883269be543f3176895278b5d82e8a661720a70491d82304cf302c); /* line */ \n        coverage_0xe495bf77(0xbbd735f657e3d88683d3a09533aac6df44307d77c61cb318a4f1832687843b4e); /* statement */ \nglobalInbox = IGlobalInbox(_globalInboxAddress);\r\ncoverage_0xe495bf77(0xfcd46717a3960c64eeae8167a6df9ddecc2040f44870d6309f50faa08be285a7); /* line */ \n        coverage_0xe495bf77(0x1b3f4b76e80900812fcecb5784a4a269d396729c89bde56ac403f7011bcf1c5a); /* statement */ \nowner = _owner;\r\n\r\ncoverage_0xe495bf77(0x33f892aa8844d30a611ad45e5e1432eedbfbbe89fb78fec2b50f8fc5f0b8d7a4); /* line */ \n        coverage_0xe495bf77(0xcee3116c4031d0009bf93fc97ad1ea798b66f5d26ed619280fe26339559a1acf); /* statement */ \nglobalInbox.sendInitializationMessage(\r\n            abi.encodePacked(\r\n                uint256(_gracePeriodTicks),\r\n                uint256(_arbGasSpeedLimitPerTick),\r\n                uint256(_maxExecutionSteps),\r\n                uint256(_stakeRequirement),\r\n                bytes32(bytes20(_stakeToken)),\r\n                bytes32(bytes20(_owner)),\r\n                _extraConfig\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Place a stake on an existing node at or after the latest confirmed node\r\n     * @param proof1 Node graph proof that the stake location is a decendent of latest confirmed\r\n     * @param proof2 Node graph proof that the stake location is an ancestor of a current leaf\r\n     */\r\n    function placeStake(bytes32[] calldata proof1, bytes32[] calldata proof2) external payable {coverage_0xe495bf77(0x248674c7942f31c1386a5fbbbad4f5e8c06cc178c6985f1d750ad40f9e426d85); /* function */ \n\r\ncoverage_0xe495bf77(0xb987bb7c10d15636c7d8bfaf4a35c51afc48bdb4a32a3255fe5fe6eb66bab472); /* line */ \n        coverage_0xe495bf77(0xb1e2981f3e8a629b039b99a72d753e24d8bfdb7d95be7966f01320e31fff7531); /* statement */ \nbytes32 location = RollupUtils.calculateLeafFromPath(latestConfirmed(), proof1);\r\ncoverage_0xe495bf77(0x27ad703817a3a95dc45ab2b62b42d0bdef2a99f95ef8c1d9ff6eae4738f68764); /* line */ \n        coverage_0xe495bf77(0x4ae5ae44629dcbd08ae2e0cbb3a79bc7355e3174d686230efe7641938fe6b412); /* statement */ \nbytes32 leaf = RollupUtils.calculateLeafFromPath(location, proof2);\r\ncoverage_0xe495bf77(0x8358c0e032a50655389b4501eab6f6bd4929b66614733baf62c2d637786aad21); /* line */ \n        coverage_0xe495bf77(0x57b03eaf749c744bef7dc2625d12dc7c690aadefc2376b7d90c1c03cdadc151e); /* assertPre */ \ncoverage_0xe495bf77(0x0a33dbc4a79093bf17a80de1bc0b304193f189247e9feeaf7163ec6caa44f454); /* statement */ \nrequire(isValidLeaf(leaf), PLACE_LEAF);coverage_0xe495bf77(0x16f04599ee89675673eab5d2fefc0a4a993a83444d1e9270b267bf2e66099890); /* assertPost */ \n\r\ncoverage_0xe495bf77(0xfbd469966bd3ed757bada30758bc5f0cb406cf49ff8f5e63584028ea75445757); /* line */ \n        coverage_0xe495bf77(0xa0ff22663a4227ecf2d747ab9df5ce89136debc9a50ac04b5d927a52d3ef4839); /* statement */ \ncreateStake(location);\r\n    }\r\n\r\n    /**\r\n     * @notice Move an existing stake to an existing leaf that is a decendent of the node the stake exists on\r\n     * @param proof1 Node graph proof that the destination location is a decendent of the current location\r\n     * @param proof2 Node graph proof that the stake location is an ancestor of a current leaf\r\n     */\r\n    function moveStake(bytes32[] calldata proof1, bytes32[] calldata proof2) external {coverage_0xe495bf77(0xeb073d8619981c8e806cd2fb2b865f7eab5ab6b3e02860b11ba8f2afd36c6d74); /* function */ \n\r\ncoverage_0xe495bf77(0xb786863733881d4d899cba43ab22d013e0342012df8887a9672d83709732b43b); /* line */ \n        coverage_0xe495bf77(0x6844e768f3761dff204859ef8fcfe492646afda5e3faf1f609a494e92a2dd774); /* statement */ \nbytes32 stakerLocation = getStakerLocation(msg.sender);\r\ncoverage_0xe495bf77(0x7e9a7455e8f10d56b0cfb8591f3b43b5e000d4d65a3189bc271b53ae02d77c2f); /* line */ \n        coverage_0xe495bf77(0x87553871393a1959dc34e7ff5a98562fc2cdf1c78624cb631bcbf52be9e4260d); /* statement */ \nbytes32 newLocation = RollupUtils.calculateLeafFromPath(stakerLocation, proof1);\r\ncoverage_0xe495bf77(0x0d4e815a046f0c7f0d55b62d77e6f13f2a6df2148bb860ff46063f24fbd85a86); /* line */ \n        coverage_0xe495bf77(0xf8b6f937b919191da46709b15b6ef1ddfccb1471998f64f7a97e7dfe8957e36f); /* statement */ \nbytes32 leaf = RollupUtils.calculateLeafFromPath(newLocation, proof2);\r\ncoverage_0xe495bf77(0x47c87d9153171312963f94831f5f61b7a4b35fecf1e26573e1b975cd07aa8082); /* line */ \n        coverage_0xe495bf77(0x080f09be5537b29f5dfb223e8a77d1144168bd86a0c8fb7fca0442d8a8b4a507); /* assertPre */ \ncoverage_0xe495bf77(0xfc4154127c8c9ddf969a6556a6fe7dd98c50b9236cb4b7f449a31c92ee7cccdc); /* statement */ \nrequire(isValidLeaf(leaf), MOVE_LEAF);coverage_0xe495bf77(0xe4184504224a86c3b328f4f803423d5e897f3aafd40cd826ce9de0bf80acba95); /* assertPost */ \n\r\ncoverage_0xe495bf77(0x9780fee777a080a4fb6141f119716856e0a09331260b0b3f1fea87a3f41e7979); /* line */ \n        coverage_0xe495bf77(0x96c0b73a7d8aacc763b615391af9ff74ebc5ad1812b6f6dc3a12428ae178f9bf); /* statement */ \nupdateStakerLocation(msg.sender, newLocation);\r\n    }\r\n\r\n    /**\r\n     * @notice Redeem your stake if it is on or before the current latest confirmed node\r\n     * @param proof Node graph proof your stake is on or before the latest confirmed node\r\n     */\r\n    function recoverStakeConfirmed(bytes32[] calldata proof) external {coverage_0xe495bf77(0xe3fd17075661cdf9bf8ba61092f2c632fe889a33ca12524099deae9cc081e44f); /* function */ \n\r\ncoverage_0xe495bf77(0xea9ab2e0906a1c06a292c627ec68e12e00fe7fa396d1d5b2787374ba35cbd2ce); /* line */ \n        coverage_0xe495bf77(0x1be3a172ba6b231201e3f2639f8042c78dfdc41085f41656ee66b98a3e503d10); /* statement */ \n_recoverStakeConfirmed(msg.sender, proof);\r\n    }\r\n\r\n    /**\r\n     * @notice Force a stake to be redeemed if it is before the current latest confirmed node\r\n     * @param stakerAddress Address of the staker whose stake will be removed\r\n     * @param proof Node graph proof your stake is before the latest confirmed node\r\n     */\r\n    function recoverStakeOld(address payable stakerAddress, bytes32[] calldata proof) external {coverage_0xe495bf77(0x393cb823d99d47a2e7fe3877273816f6f95b1b0faad3cff86cc2b67a93b97b12); /* function */ \n\r\ncoverage_0xe495bf77(0xc824853ee21cc30d1d960b64107c325802dacb201513e0983b22391f6a3a162f); /* line */ \n        coverage_0xe495bf77(0x1faef500445777354f895b5bf9736233b1e7f731a8fc0047e6d5f5dfe7c4d236); /* assertPre */ \ncoverage_0xe495bf77(0xdada95af7d516ed1befcec1a23277bd4c7449bb37581c59962da0e4ea251836d); /* statement */ \nrequire(proof.length > 0, RECVOLD_LENGTH);coverage_0xe495bf77(0xb1cf82e7d7489832a31db6398f933cf1060e68a3ca56ad25d3946c8018dc6412); /* assertPost */ \n\r\ncoverage_0xe495bf77(0xd0ba2b145782667503890c215267531fefe22429b7ad74ddc55dd1352b90f722); /* line */ \n        coverage_0xe495bf77(0xb4803584ddecb28942dd582065a35d830902c1005ae70594340f6bfe1011d3bb); /* statement */ \n_recoverStakeConfirmed(stakerAddress, proof);\r\n    }\r\n\r\n    /**\r\n     * @notice Force a stake to be redeemed if it is place on a node which can never be confirmed\r\n     * @dev This method works by showing that the staker's position conflicts with the latest confirmed node\r\n     * @param stakerAddress Address of the staker whose stake will be removed\r\n     * @param node Identifier of a node which is a common ancestor of the latest confirmed node and the staker's location\r\n     * @param latestConfirmedProof Node graph proof that the latest confirmed node is a decendent of the supplied node\r\n     * @param stakerProof Node graph proof that the staker's node is a decendent of the supplied node\r\n     */\r\n    function recoverStakeMooted(\r\n        address payable stakerAddress,\r\n        bytes32 node,\r\n        bytes32[] calldata latestConfirmedProof,\r\n        bytes32[] calldata stakerProof\r\n    ) external {coverage_0xe495bf77(0xc819383f621ea08eee0981c984bd750572be8856a0061a0b9d9d78805e82b94e); /* function */ \n\r\ncoverage_0xe495bf77(0xac143098a0a19287d095d40c38f54c9771d26c146a31500e9196c6248c252619); /* line */ \n        coverage_0xe495bf77(0x5c525f9953205ee99cc01c2e9ffeec73e2a64f6d53cf9f3cc9ecbc6e6381be74); /* statement */ \nbytes32 stakerLocation = getStakerLocation(stakerAddress);\r\ncoverage_0xe495bf77(0x1b540b6c41faa527e1488fdac2f421d2b2d41dd5cd3bf4ee500fe1a2bf25c262); /* line */ \n        coverage_0xe495bf77(0x0a93bc5131e78b2f74652eb24a30bbd29996c548b7e278e71c606ef539c5297a); /* assertPre */ \ncoverage_0xe495bf77(0x2a6e5d8a24fb58e35446ae75f94499b4c5492919918aab1fed7cbc828453d8a7); /* statement */ \nrequire(\r\n            latestConfirmedProof[0] != stakerProof[0] &&\r\n                RollupUtils.calculateLeafFromPath(node, latestConfirmedProof) ==\r\n                latestConfirmed() &&\r\n                RollupUtils.calculateLeafFromPath(node, stakerProof) == stakerLocation,\r\n            RECOV_CONFLICT_PROOF\r\n        );coverage_0xe495bf77(0x422c39b7012ba3f4b6bd80866b3ee39eddac3b8ec432d960e73fb0ac8c091ebd); /* assertPost */ \n\r\ncoverage_0xe495bf77(0xae258aea5e81a90aa181f749416e7233addd34a4669482863426994362f4ce04); /* line */ \n        coverage_0xe495bf77(0xb3c013885e3977b42ad77ef5d6820d0559a0ffc99549131c227335d2c891f55c); /* statement */ \nrefundStaker(stakerAddress);\r\n    }\r\n\r\n    // Kick off if successor node whose deadline has passed\r\n    // TODO: Add full documentation\r\n    function recoverStakePassedDeadline(\r\n        address payable stakerAddress,\r\n        uint256 deadlineTicks,\r\n        bytes32 disputableNodeHashVal,\r\n        uint256 childType,\r\n        bytes32 vmProtoStateHash,\r\n        bytes32[] calldata proof\r\n    ) external {coverage_0xe495bf77(0x5b68b16fabf226dd471dadae02df3913d121311071beb9fec3efe022f57b931f); /* function */ \n\r\ncoverage_0xe495bf77(0xa3340267e5e61cb856cac489f695b183a53e5d6bd9ddb435fc2b1e638742f4d1); /* line */ \n        coverage_0xe495bf77(0xe69249788faa9f480fc08416135abbb02fb2713dc54b07696edf6c67afdd4b65); /* statement */ \nbytes32 stakerLocation = getStakerLocation(stakerAddress);\r\ncoverage_0xe495bf77(0x12692e0f98b7cfee8f74a78e02f874d059e5cbc0c02826f5a72088632f7da066); /* line */ \n        coverage_0xe495bf77(0x7608c0f414ee0ed8755606bd411ca7bbfbd30cb38f3de7d9213ec40ae9fe9ff0); /* statement */ \nbytes32 nextNode = RollupUtils.childNodeHash(\r\n            stakerLocation,\r\n            deadlineTicks,\r\n            disputableNodeHashVal,\r\n            childType,\r\n            vmProtoStateHash\r\n        );\r\ncoverage_0xe495bf77(0x0901b3ffba5e2df9a904111d9652337ba2ce3b21d00079f333cced3430640d71); /* line */ \n        coverage_0xe495bf77(0x60f5957dcac22e92322fa03046cf1dcd4142414b379988d48cb503eb583b1e90); /* statement */ \nbytes32 leaf = RollupUtils.calculateLeafFromPath(nextNode, proof);\r\ncoverage_0xe495bf77(0x12c29bfe757e6c300995c59ff8d467b499ddfeec4758e84420815e7ea7869b60); /* line */ \n        coverage_0xe495bf77(0x284afe1a06a29c4231847ab46107a6937156bb70ac7b703ad99d21c22db85bee); /* assertPre */ \ncoverage_0xe495bf77(0x52a01f24e9c8e377136987712c3f6e55072c35b2f72c279fd30a6d5871474246); /* statement */ \nrequire(isValidLeaf(leaf), RECOV_DEADLINE_LEAF);coverage_0xe495bf77(0x931c87a035f38ecc8f552843c6ec3ea402e613a63cd2ad3121ad7c5343bbbe44); /* assertPost */ \n\r\ncoverage_0xe495bf77(0x11a51d3c5668c2aa8778aba1435ca4583eba459a3617de03742813ce8d13a0c7); /* line */ \n        coverage_0xe495bf77(0xfdbaa5d4d743864598f47efc5c0fea4038a6d01000a64ad5940b8ab2e017c3da); /* assertPre */ \ncoverage_0xe495bf77(0x28a0db09f99f00f4f700038429fc864aa54394f3d1a7abab05972feb499b6ba0); /* statement */ \nrequire(block.number >= RollupTime.blocksToTicks(deadlineTicks), RECOV_DEADLINE_TIME);coverage_0xe495bf77(0x5e7731837cc39598c25d733164169f801fd80045a480d086caeeeb4ef4128dce); /* assertPost */ \n\r\n\r\ncoverage_0xe495bf77(0x6753c4283959bf783e097e77a3cf3e3d3f99a652114dbed29e656ac997271a6c); /* line */ \n        coverage_0xe495bf77(0xfc3865b9f01183606b363e385a9e3e71be350d4c254f5da4a376bd658a87e9df); /* statement */ \nrefundStaker(stakerAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Submit a new assertion to be built on top of the specified leaf if it is validly constructed\r\n     * @dev This method selects an existing leaf to build an assertion on top of. If it succeeds that leaf is eliminated and four new leaves are created. The asserter is automatically moved to stake on the new valid leaf.\r\n     * @param fields Packed data for the following fields\r\n     *   beforeMachineHash The hash of the machine at the end of the previous assertion\r\n     *   afterMachineHash Claimed machine hash after this assertion is completed\r\n     *   beforeInboxTop The hash of the global inbox that the previous assertion had read up to\r\n     *   afterInboxTop Claimed hash of the global inbox at height beforeInboxCount + importedMessageCount\r\n     *   messagesAccHash Claimed commitment to a set of messages output in the assertion\r\n     *   logsAccHash Claimed commitment to a set of logs output in the assertion\r\n     *   prevPrevLeafHash The hash of the leaf that was the ancestor of the leaf we're building on\r\n     *   prevDataHash Type specific data of the node we're on\r\n\r\n     * @param fields2 Packed data for the following fields\r\n     *   beforeInboxCount The total number of messages read after the previous assertion executed\r\n     *   prevDeadlineTicks The challenge deadline of the node this assertion builds on\r\n     *   importedMessageCount Argument specifying the number of messages read\r\n     *   beforeMessageCount The total number of messages that have been output by the chain before this assertion\r\n     *   beforeLogCount The total number of messages that have been output by the chain before this assertion\r\n     * @param validBlockHashPrecondition Hash of a known block to invalidate the assertion if too deep a reorg occurs\r\n     * @param validBlockHeightPrecondition Height of the block with hash validBlockHash\r\n     * @param messageCount Claimed number of messages emitted in the assertion\r\n     * @param logCount Claimed number of logs emitted in the assertion\r\n     * @param prevChildType The type of node that this assertion builds on top of\r\n     * @param numSteps Argument specifying the number of steps execuited\r\n     * @param numArbGas Claimed amount of ArbGas used in the assertion\r\n     * @param stakerProof Node graph proof that the asserter is on or can move to the leaf this assertion builds on\r\n     */\r\n    function makeAssertion(\r\n        bytes32[8] calldata fields,\r\n        uint256[5] calldata fields2,\r\n        bytes32 validBlockHashPrecondition,\r\n        uint256 validBlockHeightPrecondition,\r\n        uint64 messageCount,\r\n        uint64 logCount,\r\n        uint32 prevChildType,\r\n        uint64 numSteps,\r\n        uint64 numArbGas,\r\n        bytes32[] calldata stakerProof\r\n    ) external {coverage_0xe495bf77(0x6695ae39c8ea8876d1aaf59c22dd08506595e38895d77dcd595b09d14ae627f7); /* function */ \n\r\ncoverage_0xe495bf77(0x9c750cef9a5a1eeb24f8a50af8c26ed16a107b4309da83ab1e44a80e90705dca); /* line */ \n        coverage_0xe495bf77(0xa371a55ed00d100cba911a7a3069e45004d02cc4c412820b34cb9f8bf5406e1f); /* assertPre */ \ncoverage_0xe495bf77(0xa3948926a3731b3207d04db9c78e7c238c42de8d10a3a61e2ed831fa6f359448); /* statement */ \nrequire(\r\n            blockhash(validBlockHeightPrecondition) == validBlockHashPrecondition,\r\n            \"invalid known block\"\r\n        );coverage_0xe495bf77(0x75ffd7c8c2e68e30879aacecf9d96782a37fedbf02fe868ed1d8270dee20fc62); /* assertPost */ \n\r\ncoverage_0xe495bf77(0x9c958b697496b04c16f8f43815971e42e0cc658260650ac644df68bec5809d24); /* line */ \n        coverage_0xe495bf77(0x7c595c8721d18828bc6b7d0de3f7fd58e94746c85836b642eca4781800fa4599); /* statement */ \nNodeGraphUtils.AssertionData memory assertData = NodeGraphUtils.makeAssertion(\r\n            fields,\r\n            fields2,\r\n            prevChildType,\r\n            numSteps,\r\n            numArbGas,\r\n            messageCount,\r\n            logCount\r\n        );\r\n\r\ncoverage_0xe495bf77(0x4c538511f2c0723b9029cda4a772a5f9c8b6514d1dae22bbb8b2dfbdc448093e); /* line */ \n        coverage_0xe495bf77(0x63fba200ea8c73932f9f42a66feb25fae5c0f77292ed4899d282653b884db7c4); /* statement */ \n(bytes32 inboxValue, uint256 inboxCount) = globalInbox.getInbox(address(this));\r\n\r\ncoverage_0xe495bf77(0xf533d2772e63885749cedbbe4a5ae0e334b724b37e06ddd7f2258db7eb87ad9f); /* line */ \n        coverage_0xe495bf77(0xf3d73fbb18f2bbabb93dfd330f12b8edc331355f79b8dfd2cf19b706c10a048c); /* statement */ \n(bytes32 prevLeaf, bytes32 newValid) = makeAssertion(assertData, inboxValue, inboxCount);\r\n\r\ncoverage_0xe495bf77(0x2ed2c3c4f5975f8cd5697de81425dcdae2013e0a5bbcc0b223a79d719ee1f5ed); /* line */ \n        coverage_0xe495bf77(0xe73ca04e8b9978e7c1ac074995fda64bbeea1c543f74ad41c56c0c674facbca9); /* statement */ \nbytes32 stakerLocation = getStakerLocation(msg.sender);\r\ncoverage_0xe495bf77(0xf1239df4313595b34febe7f195ade128aba797aae5eb9280f094ad062bd539ec); /* line */ \n        coverage_0xe495bf77(0x88a7e9210b1c11ccd5aaaf934cab2de2283f0ae37f7f54df0bd2972b4eff39c9); /* assertPre */ \ncoverage_0xe495bf77(0x5db78c0705eaa5da6d8e487851b7ff82c4d89c61ad28d654e96407cb878848b2); /* statement */ \nrequire(\r\n            RollupUtils.calculateLeafFromPath(stakerLocation, stakerProof) == prevLeaf,\r\n            MAKE_STAKER_PROOF\r\n        );coverage_0xe495bf77(0xa18bd817c2ff3ebd9d59fae452d9040e63dca70a09fd5432a458f86bfde6cc66); /* assertPost */ \n\r\ncoverage_0xe495bf77(0x9eaea70552bd1906cdd1a01d522114d1eeff68dd376844cacbc17a1d4fdf486c); /* line */ \n        coverage_0xe495bf77(0xfd9b18ba13fb3714d3acda2614c91827c9bee8d4854cdb873fb45c6b1e6f20f0); /* statement */ \nupdateStakerLocation(msg.sender, newValid);\r\n    }\r\n\r\n    modifier onlyOwner() {coverage_0xe495bf77(0xe2615b1f811e677849e1044680cc811ba37969306a169c0099dc0075df55b7d1); /* function */ \n\r\ncoverage_0xe495bf77(0x8efd25e100471e745675ee51ba814fbfda582ec8807519b6e81e3672d1a0bc1b); /* line */ \n        coverage_0xe495bf77(0x7ed6976b86bd6576ecff78f6b8399650da0c1173d686fc40a1904cf55165ce30); /* assertPre */ \ncoverage_0xe495bf77(0x2e09b186b75c0cae0f2732b9e0cb3cbcd5708895824222d0a5330538eaad8391); /* statement */ \nrequire(msg.sender == owner, ONLY_OWNER);coverage_0xe495bf77(0x0802580efe92cebe811e0dfa9eb67acc2cfe43c614d268848efda138bf9c8d78); /* assertPost */ \n\r\ncoverage_0xe495bf77(0xa0cc697dad893237ccda9d9677de521d5258bd755993810c39ffea14b01b3756); /* line */ \n        _;\r\n    }\r\n\r\n    function ownerShutdown() external onlyOwner {coverage_0xe495bf77(0x0c843d284738be5d83377cdc66205f09cdf7be5da1febf970c506b4b4af4a9f0); /* function */ \n\r\ncoverage_0xe495bf77(0xcfcace67cb5c1282a6b11974db2e3100d2e689872ab96ce6ac2ffaae5aaa0b69); /* line */ \n        coverage_0xe495bf77(0x2add06608e7e679d2e5dc837144255e0a3c562377b1dc34793cab8f412084e08); /* statement */ \nsafeSelfDestruct(msg.sender);\r\n    }\r\n\r\n    function _recoverStakeConfirmed(address payable stakerAddress, bytes32[] memory proof) private {coverage_0xe495bf77(0xc083cf9550f90ca029c0fa477aee2836f618babd928afeb365cae448fcc6e250); /* function */ \n\r\ncoverage_0xe495bf77(0x2bff6245c1abd69bdc3a53d3a8fd31016a3cc17ad379132e017a87f84777e0d1); /* line */ \n        coverage_0xe495bf77(0xc0b29b4636c169505f5e8645bccb637b19143d0f0cc2248d2b047bdf5d15c74e); /* statement */ \nbytes32 stakerLocation = getStakerLocation(msg.sender);\r\ncoverage_0xe495bf77(0x7e8f75f8368afa6837468f25733bdafbe546f374533b58cc72a0d5257690be82); /* line */ \n        coverage_0xe495bf77(0xf5f2563254e7dd22ed81131559cfc617e62684c750a7b892641815f90a76e930); /* assertPre */ \ncoverage_0xe495bf77(0x9f08682544cff550aaa4c1f46e89a10351f948425c3402397fc6d5a6a18c56c0); /* statement */ \nrequire(\r\n            RollupUtils.calculateLeafFromPath(stakerLocation, proof) == latestConfirmed(),\r\n            RECOV_PATH_PROOF\r\n        );coverage_0xe495bf77(0x6d2941259d7a05695c8c608409f342ec4d9dc56bb1a0361428ee5369d4944e50); /* assertPost */ \n\r\ncoverage_0xe495bf77(0x77641c1b702c395173e7248c9f29b7b78e74aab76752aa4f792650d4ff1f56c0); /* line */ \n        coverage_0xe495bf77(0x5dc6ef97b5e905b0701faa52e7af68e535b32a1d160ee449cd14fe7dea9163c7); /* statement */ \nrefundStaker(stakerAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Confirm an arbitrary number of pending assertions\r\n     * @dev Confirming multiple assertions at once has the advantage that we can skip most checks for all nodes but the final one\r\n     * @dev TODO: An adversary could potentially make this method too expensive to call by creating a large number of validators. This issue could be avoided by providing an interactive confirmation challenge along with this synchronous one.\\\r\n     * @param initalProtoStateHash Hash of the protocol state of the predecessor to the first node confirmed\r\n     * @param branches For each node being confirmed, this is the type of node it was\r\n     * @param deadlineTicks For each node being confirmed, this is the deadline for validators challenging it\r\n     * @param challengeNodeData For the invalid nodes being confirmed, this is the hash of the challenge specific data in that node\r\n     * @param logsAcc For the valid nodes being confirmed, this is the claim about what logs were emitted\r\n     * @param vmProtoStateHashes For the valid nodes being confirmed, this is the state after that node is confirmed\r\n     * @param messageCounts The number of messages in each valid assertion confirmed\r\n     * @param messages All the messages output by the confirmed assertions marshaled in order from oldest to newest\r\n     * @param stakerAddresses The list of all currently staked validators\r\n     * @param stakerProofs A concatenated list of proofs for each validator showing that they agree with the given node\r\n     * @param stakerProofOffsets A list of indexes into stakerProofs to break it into pieces for each validator\r\n     */\r\n    function confirm(\r\n        bytes32 initalProtoStateHash,\r\n        uint256 beforeSendCount,\r\n        uint256[] memory branches,\r\n        uint256[] memory deadlineTicks,\r\n        bytes32[] memory challengeNodeData,\r\n        bytes32[] memory logsAcc,\r\n        bytes32[] memory vmProtoStateHashes,\r\n        uint256[] memory messageCounts,\r\n        bytes memory messages,\r\n        address[] memory stakerAddresses,\r\n        bytes32[] memory stakerProofs,\r\n        uint256[] memory stakerProofOffsets\r\n    ) public {coverage_0xe495bf77(0x0bb9ccd3600b4f4a1a3972a57141dd4e26b1954d78acb4edba1ac3043d04b566); /* function */ \n\r\ncoverage_0xe495bf77(0xfa6e51e0c85e87c442e95e399b08a483e726a766065dfb9f9952311f31de6630); /* line */ \n        coverage_0xe495bf77(0xf0ff4bd41fca84f88e0f1e6b1d7fe7e9db52f3f60edc66c086123a113f8b6593); /* statement */ \nreturn\r\n            _confirm(\r\n                RollupUtils.ConfirmData(\r\n                    initalProtoStateHash,\r\n                    beforeSendCount,\r\n                    branches,\r\n                    deadlineTicks,\r\n                    challengeNodeData,\r\n                    logsAcc,\r\n                    vmProtoStateHashes,\r\n                    messageCounts,\r\n                    messages\r\n                ),\r\n                stakerAddresses,\r\n                stakerProofs,\r\n                stakerProofOffsets\r\n            );\r\n    }\r\n\r\n    function _confirm(\r\n        RollupUtils.ConfirmData memory data,\r\n        address[] memory stakerAddresses,\r\n        bytes32[] memory stakerProofs,\r\n        uint256[] memory stakerProofOffsets\r\n    ) private {coverage_0xe495bf77(0x0e1875b280660e869ab501885c055b4c5443cb79dd483e3df91e9471f960be9b); /* function */ \n\r\ncoverage_0xe495bf77(0x0fbcab400c834981d6b6687b90aa51e3f84cd82d01a44276c305faf2bf49e690); /* line */ \n        coverage_0xe495bf77(0x8b57ae1c252c1a46a7b77a6e0fb40bdd1d3f067099a4d50a0a65c231f2b7be34); /* statement */ \nuint256 totalNodeCount = data.branches.length;\r\n        // If last node is after deadline, then all nodes are\r\ncoverage_0xe495bf77(0x878a5c4722c4a40c3767e9c2d43ea664254fdaf652e2e0ebb86cd8eff18afcd8); /* line */ \n        coverage_0xe495bf77(0x991281a7898fc265883b02fbed9c9a6d30978e5c1014da68916d4084906ea6db); /* assertPre */ \ncoverage_0xe495bf77(0x1d9e1f0050f2f37b9921cb975cf7270fec095ad5cd9d3f969736bd26ed558aee); /* statement */ \nrequire(\r\n            RollupTime.blocksToTicks(block.number) >= data.deadlineTicks[totalNodeCount - 1],\r\n            CONF_TIME\r\n        );coverage_0xe495bf77(0x387d381333ed52ba80360c94612ae3728a7c765ec47aed1e37e0f0cba4c072bf); /* assertPost */ \n\r\n\r\ncoverage_0xe495bf77(0xcdf0ca2b9ef99913f31cd66fd0b6ee3bf43003623d7dfa388c946eae68324898); /* line */ \n        coverage_0xe495bf77(0x0771bbfc6e3956eb460bad77c0b9f1d194639858732c49b0ba28d5e061f49b87); /* statement */ \n(bytes32[] memory validNodeHashes, RollupUtils.NodeData memory finalNodeData) = RollupUtils\r\n            .confirm(data, latestConfirmed());\r\n\r\ncoverage_0xe495bf77(0xe886d88e3421053e751a14d239fff0cd816fde36446f926774a9437403cd32f5); /* line */ \n        coverage_0xe495bf77(0xbc2d4cf24c361e6fd521171393d79bc12d923091f974038ac56a5896b0fe0d6f); /* statement */ \nuint256 validNodeCount = validNodeHashes.length;\r\ncoverage_0xe495bf77(0x54233c6e7778f0ae61b4793881edb7fc4a0c6515fcc10e298380f585225671a1); /* line */ \n        coverage_0xe495bf77(0xc3ef24b584ebe1d21dfff4c85cba8bca018768ed9b0916668d1e8d371476f539); /* statement */ \nfor (uint256 i = 0; i < validNodeCount; i++) {\r\ncoverage_0xe495bf77(0x81116d64782eaf15a55df39e5fe955a1f5cfb85992cb1daa40fe1e5cebf13930); /* line */ \n            coverage_0xe495bf77(0xe072d2bd9ab6ef6dd5fa6be0f6902beff23c7ee133c2f5f14979f923edf84981); /* statement */ \nemit ConfirmedValidAssertion(validNodeHashes[i]);\r\n        }\r\ncoverage_0xe495bf77(0xe1d85b2ba4c7207860215ed08e016f0d3ccd3186df0cdd8bd1647242e5e8e5e9); /* line */ \n        coverage_0xe495bf77(0xe6c846a47fc36f507526fbc65c04aff77880cf166d37674d7f6f685caef4071f); /* statement */ \nuint256 activeCount = checkAlignedStakers(\r\n            finalNodeData.nodeHash,\r\n            data.deadlineTicks[totalNodeCount - 1],\r\n            stakerAddresses,\r\n            stakerProofs,\r\n            stakerProofOffsets\r\n        );\r\ncoverage_0xe495bf77(0x3cfd7cb70d8e50f0b5a9ce5f679f5fbb19316f236129cff811e612edb7017d0e); /* line */ \n        coverage_0xe495bf77(0x86c56a33e00e63e20a1be9cbee5b9aeabf42f37dba71affe089dde9ea5c991c0); /* assertPre */ \ncoverage_0xe495bf77(0xa88dbf8090c800e5ea9c325c38140548f211dbefaafabd4e6bbe639aba5f7a84); /* statement */ \nrequire(activeCount > 0, CONF_HAS_STAKER);coverage_0xe495bf77(0xb3707e51d1e803d204655d32624547bdbd75d26c6133173c86c15aa88829a2b0); /* assertPost */ \n\r\n\r\ncoverage_0xe495bf77(0xe7cea2634f052a8e8780f266792a40a3feebd999243c4644e8a4c2c25559ad17); /* line */ \n        coverage_0xe495bf77(0xe822c34fe3f0a398a839b1e9ec669e00f73c81f8ed018e7632ae594ded0b3e9c); /* statement */ \nconfirmNode(finalNodeData.nodeHash);\r\n\r\n        // Send all messages is a single batch\r\ncoverage_0xe495bf77(0x7f5203550172a7440b9d7d55a308cba3fa1576aba6482058cb09c2deeac1a55b); /* line */ \n        coverage_0xe495bf77(0x6ef11f1c7af947256ce3b3a5c9f8f5d99a75607649ec8cdac2d2405296d305fc); /* statement */ \nglobalInbox.sendMessages(\r\n            data.messages,\r\n            data.initialSendCount,\r\n            finalNodeData.beforeSendCount\r\n        );\r\n\r\ncoverage_0xe495bf77(0x78f4ed20945fbc5284e202104c791a803a69813df2d83ac34a2749f4e8e2d182); /* line */ \n        coverage_0xe495bf77(0x9c65a7f9ae76af111343f10d06ce2c205c636479c33c172aa3afd44d81da08d0); /* statement */ \nif (validNodeCount > 0) {coverage_0xe495bf77(0x2bd5653ffb2d94f5cd94cef04dcb51fc78ed0992e59e367a487e2e5b2863e915); /* branch */ \n\r\ncoverage_0xe495bf77(0x110b8ad7a7166cfa1dc7edf1ed1e90e5ef82fa42fa7d2d9ab4217be399f654b4); /* line */ \n            coverage_0xe495bf77(0xbef564819eea00544a83d6f7e73abb6e23081ee6050f663d467c54508737da9b); /* statement */ \nemit ConfirmedAssertion(data.logsAcc);\r\n        }else { coverage_0xe495bf77(0x3e401e1b2d7767985d7faa25012e09d467215ede47c469ff4bd91b4bf6606e85); /* branch */ \n}\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/rollup/NodeGraph.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"./RollupUtils.sol\";\r\nimport \"./NodeGraphUtils.sol\";\r\nimport \"./VM.sol\";\r\n\r\nimport \"../arch/Value.sol\";\r\n\r\nimport \"../libraries/RollupTime.sol\";\r\n\r\ncontract NodeGraph {\nfunction coverage_0xb698eaca(bytes32 c__0xb698eaca) public pure {}\n\r\n    using SafeMath for uint256;\r\n    using Hashing for Value.Data;\r\n\r\n    // invalid leaf\r\n    string private constant MAKE_LEAF = \"MAKE_LEAF\";\r\n    // Can only disputable assert if machine is not errored or halted\r\n    string private constant MAKE_RUN = \"MAKE_RUN\";\r\n    // Tried to execute too many steps\r\n    string private constant MAKE_STEP = \"MAKE_STEP\";\r\n    // Tried to import more messages than exist in ethe inbox\r\n    string private constant MAKE_MESSAGE_CNT = \"MAKE_MESSAGE_CNT\";\r\n\r\n    string private constant PRUNE_LEAF = \"PRUNE_LEAF\";\r\n    string private constant PRUNE_PROOFLEN = \"PRUNE_PROOFLEN\";\r\n    string private constant PRUNE_CONFLICT = \"PRUNE_CONFLICT\";\r\n\r\n    // Fields\r\n    //  prevLeaf\r\n    //  inboxValue\r\n    //  afterMachineHash\r\n    //  afterInboxHash\r\n    //  messagesAccHash\r\n    //  logsAccHash\r\n    //  validNodeHash\r\n\r\n    event RollupAsserted(\r\n        bytes32[7] fields,\r\n        uint256 inboxCount,\r\n        uint256 importedMessageCount,\r\n        uint64 numArbGas,\r\n        uint64 numSteps,\r\n        uint256 beforeMessageCount,\r\n        uint64 messageCount,\r\n        uint256 beforeLogCount,\r\n        uint64 logCount\r\n    );\r\n\r\n    event RollupConfirmed(bytes32 nodeHash);\r\n\r\n    event RollupPruned(bytes32 leaf);\r\n\r\n    VM.Params public vmParams;\r\n    mapping(bytes32 => bool) private leaves;\r\n    bytes32 private latestConfirmedPriv;\r\n\r\n    /**\r\n     * @notice Prune an arbitrary number of leaves from the node graph\r\n     * @dev Pruning leaves frees up blockchain storage, but is otherwise unnecessary\r\n     * @notice See _pruneLeaf for parameter documentation\r\n     */\r\n    function pruneLeaves(\r\n        bytes32[] calldata fromNodes,\r\n        bytes32[] calldata leafProofs,\r\n        uint256[] calldata leafProofLengths,\r\n        bytes32[] calldata latestConfProofs,\r\n        uint256[] calldata latestConfirmedProofLengths\r\n    ) external {coverage_0xb698eaca(0xff5612a088b92b31f7cf9a50b7f2965c859550ddef06c8a6c9518d62e8c23130); /* function */ \n\r\ncoverage_0xb698eaca(0x46053dbf79eacd25860fb106a0ce23044a5ce66cafd445d378a0622d4cddc9d0); /* line */ \n        coverage_0xb698eaca(0xb933ad2ad4872d696ea427deefb94c6273cef320bf2746dad114b3047bde268a); /* statement */ \nuint256 pruneCount = fromNodes.length;\r\n\r\ncoverage_0xb698eaca(0x9be385ba40957a072079dcc2bf9478f587e8f26cc6e16b071bec9e5328c3e00d); /* line */ \n        coverage_0xb698eaca(0x873ccc695f2ce4b2df63d0ae2186350e6cf19b47181c37fb9dc1f818fcce7528); /* assertPre */ \ncoverage_0xb698eaca(0x5be1b23a02ee11db128d9e8ba7e5837aa552ee2261220d775effd6193e67f455); /* statement */ \nrequire(\r\n            leafProofLengths.length == pruneCount &&\r\n                latestConfirmedProofLengths.length == pruneCount,\r\n            \"input length mistmatch\"\r\n        );coverage_0xb698eaca(0xa8edeba80ba18b2879c9ed4c83a1c652aedd30935403bf6f39974c7ae7170682); /* assertPost */ \n\r\ncoverage_0xb698eaca(0x929aecb0ed6f4434f509541ee093324433b33af28e05ce61ffab3dabcb8aa98c); /* line */ \n        coverage_0xb698eaca(0xe4bd5b1742988017b92414996fc940f79f023a04d7324a1211b28fefc7c8567a); /* statement */ \nuint256 prevLeafOffset = 0;\r\ncoverage_0xb698eaca(0x32580c290595fad57765ab06dc626cbf5a72af21b31b31395671dfbfda738c0a); /* line */ \n        coverage_0xb698eaca(0x8e8335d1546cf5e9125a2d9555e2dc4c68fcd989a87cc42cc1f2fc96ecb3631e); /* statement */ \nuint256 prevConfOffset = 0;\r\n\r\ncoverage_0xb698eaca(0x3fb0a3d84dcd0006bb58b21a216bdeecfbeb9eb72a4c4d2af30c43ab3b0821d0); /* line */ \n        coverage_0xb698eaca(0xa9ec65acc4213522da5ca82d07d1ba77628b1f2f89ea97ee2c9f591cc2612da1); /* statement */ \nfor (uint256 i = 0; i < pruneCount; i++) {\r\ncoverage_0xb698eaca(0x03d43749694382d6a9f15dcb88be3e14c981117db9cbdc6339f95d3126cd3f42); /* line */ \n            coverage_0xb698eaca(0x16d2ddc30e6acb2f87bd8d04e439cc0878e7831d958ec7c5fa8cb456d2f87d10); /* statement */ \n(prevLeafOffset, prevConfOffset) = _pruneLeaf(\r\n                fromNodes[i],\r\n                latestConfirmedProofLengths[i],\r\n                leafProofLengths[i],\r\n                leafProofs,\r\n                latestConfProofs,\r\n                prevLeafOffset,\r\n                prevConfOffset\r\n            );\r\n        }\r\n    }\r\n\r\n    function latestConfirmed() public view returns (bytes32) {coverage_0xb698eaca(0x4d0b55c2907784d94753fd0625256f59815039145bd994a2b09eb89357bb2d70); /* function */ \n\r\ncoverage_0xb698eaca(0x97d999cb54ea013baf0964aadd62aecbc311c4692d2fc4224a5b2c6ffb104d14); /* line */ \n        coverage_0xb698eaca(0x0457d5d0c3790c32e33092083974e9ab2022782a2ed28c6fa3de1865c3c149ca); /* statement */ \nreturn latestConfirmedPriv;\r\n    }\r\n\r\n    function isValidLeaf(bytes32 leaf) public view returns (bool) {coverage_0xb698eaca(0xe0bb44084c9f55f6a5b7766912e4ea51833d06fc814d952d1d58fda99df1f3ee); /* function */ \n\r\ncoverage_0xb698eaca(0xf6892d53b7aad2f6c1abcce7517bc6b8f058bf38f7fb1a7b0efab64beee64430); /* line */ \n        coverage_0xb698eaca(0x83f5aee98bd7ac93a7f432a63eac91c58200ffa200cd6b674610a0948a99276d); /* statement */ \nreturn leaves[leaf];\r\n    }\r\n\r\n    function init(\r\n        bytes32 _vmState,\r\n        uint128 _gracePeriodTicks,\r\n        uint128 _arbGasSpeedLimitPerTick,\r\n        uint64 _maxExecutionSteps\r\n    ) internal {coverage_0xb698eaca(0x25dbc35a3f18fcf255015a37462f8f6f02452087508479aadddfeb6b8120af78); /* function */ \n\r\n        // VM protocol state\r\ncoverage_0xb698eaca(0x62b985fe6b6ad75a23915c9dfff8d7721b4faa27117e0cbfa54dc32a0de831a1); /* line */ \n        coverage_0xb698eaca(0x3c63543e5937bc5dcd7f1d82836a620f05581d3fb46341d10660a12a2b480ae7); /* statement */ \nbytes32 vmProtoStateHash = RollupUtils.protoStateHash(_vmState, 0, 0, 0, 0);\r\ncoverage_0xb698eaca(0x6bffb3639ef7535d5220bbd61b5c33fed7232a5ca60b701426f7923db9b5fb2f); /* line */ \n        coverage_0xb698eaca(0xb3d7e256db1978c6c9efa0f971f6d3de841e0b1fe4c3f6ee256f50890cdb8a4c); /* statement */ \nbytes32 initialNode = RollupUtils.childNodeHash(0, 0, 0, 0, vmProtoStateHash);\r\ncoverage_0xb698eaca(0xfd73298c545bded538da340d669edf270a4745b3651815c9ecf5bdab16a69e3c); /* line */ \n        coverage_0xb698eaca(0x07534113fa0bc9d11af1331e4536e266d01908113f543d328c950d92d8fa73bd); /* statement */ \nlatestConfirmedPriv = initialNode;\r\ncoverage_0xb698eaca(0x1d0fb851e8ff9cdd7e931f3dc2fa1e233aa66c88391189b0f56f1a0d346f8607); /* line */ \n        coverage_0xb698eaca(0x1e74e79151dff9a486887cb1d0c9974ed26e4c248d00099e4e6b6a68c63337d6); /* statement */ \nleaves[initialNode] = true;\r\n\r\n        // VM parameters\r\ncoverage_0xb698eaca(0xb877f1ee1dfca632452905e85b3aace5939465fcd850c0a46c71e7a0426cd3a3); /* line */ \n        coverage_0xb698eaca(0x68fa781d2ee113323c0c839d1112e2f2a9f6af4c4804650e970cf7f074d3a170); /* statement */ \nvmParams.gracePeriodTicks = _gracePeriodTicks;\r\ncoverage_0xb698eaca(0x326bee06d19b73549b340b425cbdf84d406778f27a95607a9e1c716eee36402a); /* line */ \n        coverage_0xb698eaca(0x30731f87b121e0409c45a06d3376e35169ecd467c6e32cda7e444525f2649712); /* statement */ \nvmParams.arbGasSpeedLimitPerTick = _arbGasSpeedLimitPerTick;\r\ncoverage_0xb698eaca(0x8fb06d7108a7f8ad200b8c1be347eaf367cdfca9fa47bb78f3e53ce4a57287a9); /* line */ \n        coverage_0xb698eaca(0x26a9d2d4b9ef4e266db85a8daeeb5a12998769aed12b8a11c1424297862aae30); /* statement */ \nvmParams.maxExecutionSteps = _maxExecutionSteps;\r\n    }\r\n\r\n    function makeAssertion(\r\n        NodeGraphUtils.AssertionData memory data,\r\n        bytes32 inboxValue,\r\n        uint256 inboxCount\r\n    ) internal returns (bytes32, bytes32) {coverage_0xb698eaca(0xdeb8166dc2a367266a005875742ac780d5d7a6a97084a1accd2fa0f7c3eea929); /* function */ \n\r\ncoverage_0xb698eaca(0xfb4de23574e3c75f07987c903d71d4d6fc590560645389cc43b6a81c7d81f7c9); /* line */ \n        coverage_0xb698eaca(0x2220fd4f510a4549a8daf5bd1f11466bfda211fb90a20ddbe3060deacb5e9bf4); /* statement */ \n(bytes32 prevLeaf, bytes32 vmProtoHashBefore) = NodeGraphUtils.computePrevLeaf(data);\r\ncoverage_0xb698eaca(0xa13e1f0baf1c841de876325c42d05de62f2b2bd21ef8fbbf022cc4a211f3b041); /* line */ \n        coverage_0xb698eaca(0x3df305371e01b7861dba2aaf03ae62671289d548dbdf78a63714ae01e821d413); /* assertPre */ \ncoverage_0xb698eaca(0x276fae31f8f24b886653a7b75fdbee7253b2e8be1f31ab9e4f14d0f5abc822b7); /* statement */ \nrequire(isValidLeaf(prevLeaf), MAKE_LEAF);coverage_0xb698eaca(0xf6e77f6d20130089757c607f4ee31be47f3ca30d4a1faa529e8a5449df84bcf6); /* assertPost */ \n\r\ncoverage_0xb698eaca(0x6a7388f618c1cc596f6cf33d9a9bde3230fe8d2ed260176922f4e05abef71afd); /* line */ \n        coverage_0xb698eaca(0x3ea55caa3e10f12a3f38b8d984ab59ff04a2fa721ab12ea47c6213e4b8bc69b6); /* statement */ \n_verifyAssertionData(data);\r\n\r\ncoverage_0xb698eaca(0x4ce468bf13ae00d89928f460156589e02bb47f63194fa9b552af94d369ae2bfc); /* line */ \n        coverage_0xb698eaca(0xae9b0d39fff9733a6531afc2bde3febbce6eada7dafb7bb131b08e1014826647); /* assertPre */ \ncoverage_0xb698eaca(0x96156a28627f2dc6bd5aa4ea11da365237c3085aa0616f71ad0872a8e7bc052f); /* statement */ \nrequire(\r\n            data.importedMessageCount <= inboxCount.sub(data.beforeInboxCount),\r\n            MAKE_MESSAGE_CNT\r\n        );coverage_0xb698eaca(0x25d7573ca725f004c43797acc88c141b65672c886203333f10de89edb1d0140c); /* assertPost */ \n\r\n\r\ncoverage_0xb698eaca(0xc784619ca75a8f0feae93340aaa43b7fc1a7dca0a214975d8e6593aabc3a2373); /* line */ \n        coverage_0xb698eaca(0x7caa328163f432627b1c46a2770a80faf9620621906e2beb2b2b08da27d0537f); /* statement */ \nbytes32 validLeaf = _initializeAssertionLeaves(\r\n            data,\r\n            prevLeaf,\r\n            vmProtoHashBefore,\r\n            inboxValue,\r\n            inboxCount\r\n        );\r\n\r\ncoverage_0xb698eaca(0x281549b0a5a5385de156e70e1d199271ed0e1d8ca050b641b1e3b1b3c1c546c2); /* line */ \n        delete leaves[prevLeaf];\r\n\r\ncoverage_0xb698eaca(0xa32488f048ddb06d2d0539a91c559d4daa3913cdbe75c519e7d631797aad3289); /* line */ \n        coverage_0xb698eaca(0xe60fa3c4f10714d17eba0d05ecdd292fa4a54d832eaa7f0b1d1b2a43c18f35c9); /* statement */ \nemitAssertedEvent(data, prevLeaf, validLeaf, inboxValue, inboxCount);\r\ncoverage_0xb698eaca(0x7a0047951041dd98d63842572930249743c55bba5504250160ec2a4923678398); /* line */ \n        coverage_0xb698eaca(0xde8bcd2f6583f011fd155da58b7f655605d2e9e632d9abf12e054ee739525a91); /* statement */ \nreturn (prevLeaf, validLeaf);\r\n    }\r\n\r\n    function confirmNode(bytes32 to) internal {coverage_0xb698eaca(0xf762c770cc9a1fa8e65a220ce0a0b5abac6bbf18442b9ec03442a954417c7313); /* function */ \n\r\ncoverage_0xb698eaca(0x3b8e0eb438e4bf15375e6f912478fb93dd93bc735b550a4bf1eba6f042886481); /* line */ \n        coverage_0xb698eaca(0x57bc98ce7c56c2d4ac9073e053f0c79f627dd1309c4251600626074e16aaf507); /* statement */ \nlatestConfirmedPriv = to;\r\ncoverage_0xb698eaca(0xaf96b6e8f95adf0244b7ab8fb6b2a37d9a41218f1e24772805f7949c4fe04687); /* line */ \n        coverage_0xb698eaca(0x0ade80b0f0eb2f87a3005f827eb6e22da2c4f583f712ef9faf7e2809d427a444); /* statement */ \nemit RollupConfirmed(to);\r\n    }\r\n\r\n    function emitAssertedEvent(\r\n        NodeGraphUtils.AssertionData memory data,\r\n        bytes32 prevLeaf,\r\n        bytes32 validLeaf,\r\n        bytes32 inboxValue,\r\n        uint256 inboxCount\r\n    ) private {coverage_0xb698eaca(0xb62f76426e26367617fff49c0f4fd484a64bb0e9430a0556e18efe18a99c06a7); /* function */ \n\r\ncoverage_0xb698eaca(0xff0b7f7a36a835d0366a74397e834dfc8d9839927ab514574b30504395d916b8); /* line */ \n        coverage_0xb698eaca(0x341e18ef9c5c8be4810c79f051fb0c315b97472425ec729ca9a1155f42f11369); /* statement */ \nemit RollupAsserted(\r\n            [\r\n                prevLeaf,\r\n                inboxValue,\r\n                data.assertion.afterMachineHash,\r\n                data.assertion.afterInboxHash,\r\n                data.assertion.lastMessageHash,\r\n                data.assertion.lastLogHash,\r\n                validLeaf\r\n            ],\r\n            inboxCount,\r\n            data.importedMessageCount,\r\n            data.assertion.numArbGas,\r\n            data.assertion.numSteps,\r\n            data.beforeMessageCount,\r\n            data.assertion.messageCount,\r\n            data.beforeLogCount,\r\n            data.assertion.logCount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Prune a leaf from the node graph if it conflicts with the latest confirmed node\r\n     * @dev Pruning leaves frees up blockchain storage, but is otherwise unnecessary\r\n     * @param from The node where the leaf we want to prune diverged from the correct path\r\n     * @param latestConfirmedProofLength Length of the proof showing the from is an ancestor of latest confirmed\r\n     * @param leafProofLength Length of the proof showing the the pruned leaf conflicts with the from node\r\n     * @param leafProofs Array containing the leaf conflict proof\r\n     * @param latestConfProofs Array containing the leaf confirmed proof\r\n     * @param prevLeafOffset Index into the leaf proof\r\n     * @param prevConfOffset Index into the confirm proof\r\n     */\r\n    function _pruneLeaf(\r\n        bytes32 from,\r\n        uint256 latestConfirmedProofLength,\r\n        uint256 leafProofLength,\r\n        bytes32[] memory leafProofs,\r\n        bytes32[] memory latestConfProofs,\r\n        uint256 prevLeafOffset,\r\n        uint256 prevConfOffset\r\n    ) private returns (uint256, uint256) {coverage_0xb698eaca(0x980d73b0545cb15249aabffb9fdf0b4de441a7d6b6ece6d33abc92b7f57d9c85); /* function */ \n\r\ncoverage_0xb698eaca(0xc2a0728b0c7dc476773bf7acc63881aa5181870f9a5a13d9a596e34df252649f); /* line */ \n        coverage_0xb698eaca(0x2f0e40cbe66bb322eca47b162a0ae8dfc24bb293bcc81c6b6397528adbedafbb); /* assertPre */ \ncoverage_0xb698eaca(0x4283c3d2e9e6daf233c41c0efb840d24a3c65f7650e4bd7a0abf7d8e7b31d8d9); /* statement */ \nrequire(leafProofLength > 0 && latestConfirmedProofLength > 0, PRUNE_PROOFLEN);coverage_0xb698eaca(0x9636a98501186dcabac198b55e9ead2cd3e317fbd0ea64780da9622d12528053); /* assertPost */ \n\r\ncoverage_0xb698eaca(0x232bed43816aba8182b31d98f8fb0900fa173cc9978085422e514d60d2279018); /* line */ \n        coverage_0xb698eaca(0xf227711f596d55ad6f4a7e6972732fc8f7263d8460ec09224483a24c66e6ce40); /* statement */ \nuint256 nextLeafOffset = prevLeafOffset + leafProofLength;\r\ncoverage_0xb698eaca(0xbf96bd81b50e5110b8f72ad6a63a4a6b0bb41706b0a3dc106c05f9bcc2f693b9); /* line */ \n        coverage_0xb698eaca(0xefcbe848b31570ce69aed8b27f86a312cc31bc535178aa530197ba69e212eb82); /* statement */ \nuint256 nextConfOffset = prevConfOffset + latestConfirmedProofLength;\r\n\r\n        // If the function call was produced valid at any point, either all these checks will pass or all will fail\r\ncoverage_0xb698eaca(0x7f1d4eda9151931a51e4200ec051776976c72a5cd868483fe7873bb1cb3137e3); /* line */ \n        coverage_0xb698eaca(0x0e03ced6491d194620d03021212211b77a52f897f314ed24138cbca4a9a6a8ad); /* statement */ \nbool isValidNode = RollupUtils.calculateLeafFromPath(\r\n            from,\r\n            latestConfProofs,\r\n            prevConfOffset,\r\n            nextConfOffset\r\n        ) == latestConfirmed();\r\n\r\ncoverage_0xb698eaca(0x52d9f84d6a2e087c0748e26030a009a0e63179bba413c51410c9edbca8e6a456); /* line */ \n        coverage_0xb698eaca(0xa93f7c2d86647a249b9e3eeedfd7a1321bb9f2f03e30075cbee6abe50de7e508); /* assertPre */ \ncoverage_0xb698eaca(0xfd185b0fda0982e28480d18e18a3eed083ee1d020b94637038f9bab201ee672f); /* statement */ \nrequire(\r\n            isValidNode && leafProofs[prevLeafOffset] != latestConfProofs[prevConfOffset],\r\n            PRUNE_CONFLICT\r\n        );coverage_0xb698eaca(0xa2da265a85f1f56aa24df194162bbd3b38c7315741e9108f836e0e3344514c35); /* assertPost */ \n\r\n\r\ncoverage_0xb698eaca(0xb44fa96c737dbc918195bee47faff9d71c72ea78e256c2f2351331d957b2bd3e); /* line */ \n        coverage_0xb698eaca(0xe1e6d7d3e1a95458ace6e0b4e7f0ff85119bf8ee7a84ccd5179ad227490cbb02); /* statement */ \nbytes32 leaf = RollupUtils.calculateLeafFromPath(\r\n            from,\r\n            leafProofs,\r\n            prevLeafOffset,\r\n            nextLeafOffset\r\n        );\r\ncoverage_0xb698eaca(0xf095f1e54ce1f5d35f535309c67aaf61a8d25d7d515936048c2548f9e9bcd685); /* line */ \n        coverage_0xb698eaca(0x9b7d3bf15e74502b64d1e8d55433b7c9ae3313f58502d2e5522bc443e82ad847); /* statement */ \nif (isValidLeaf(leaf)) {coverage_0xb698eaca(0x049f9dc16d6a0d57aa895da05afe55df8dc8b596df1eb6c42f5f18c2bdc1eeeb); /* branch */ \n\r\ncoverage_0xb698eaca(0xe6f713bfb09a9246be367c9a09cb5194ade4e805052195caaa30d825326bdd58); /* line */ \n            delete leaves[leaf];\r\ncoverage_0xb698eaca(0x04bbb325706b8ad28a4ccec932c1ae3f399b2c850fbd8e500f771d3042c03f5c); /* line */ \n            coverage_0xb698eaca(0x476527b93fb16d0b4a93f5388ff4b89163e05185c144d3bafbee710402b6b15a); /* statement */ \nemit RollupPruned(leaf);\r\n        }else { coverage_0xb698eaca(0xba9f1c6429ec12abd7a301b6547b6d29a71636e86b11a13af8c8676daaae2ec7); /* branch */ \n}\r\n\r\ncoverage_0xb698eaca(0xf4f4525bfdc972e722a5c03533d4fb69669fd9d75e77363a2b70424048f45d9c); /* line */ \n        coverage_0xb698eaca(0x01614e32dc63247de0b2540e3d2189f043f5ac8c7ba6ff9d416587dfbaa8c8be); /* statement */ \nreturn (nextLeafOffset, nextConfOffset);\r\n    }\r\n\r\n    function _verifyAssertionData(NodeGraphUtils.AssertionData memory data) private view {coverage_0xb698eaca(0xdfcc21ec42fae0b197ed7c57dbcfdc5c31af417335c59631a613e2bda3e040b4); /* function */ \n\r\ncoverage_0xb698eaca(0x65756a80d5b56055042d9d381d1726015cae7ac41c6d3659ad133de589f04c41); /* line */ \n        coverage_0xb698eaca(0x1691f09d8df1e92f4cb04aafd792ee03feeae74df8c7e06bb38dae8605f04129); /* assertPre */ \ncoverage_0xb698eaca(0x6556a20cb8c3d8abf1c8b52a32dfaca9742894a0da73edb7aa3fe9162dd78d44); /* statement */ \nrequire(\r\n            !VM.isErrored(data.assertion.beforeMachineHash) &&\r\n                !VM.isHalted(data.assertion.beforeMachineHash),\r\n            MAKE_RUN\r\n        );coverage_0xb698eaca(0x42edde2fa17041d5ecee6e438d061daefc1fb2bf501b0f4e1526036fd6fa1b48); /* assertPost */ \n\r\ncoverage_0xb698eaca(0x0ddf5d926a43714494766b7e9bebdcdecc72ce2f4993d82786339110fe1ce385); /* line */ \n        coverage_0xb698eaca(0x7ce1a2b9d359b3902662f870249e01342fe0d32ce4116c5743b4cf0a448f6ef1); /* assertPre */ \ncoverage_0xb698eaca(0x5ba71e73d9484a2d3825b9633b6eefc52124176a949df6790d7cfb738585561c); /* statement */ \nrequire(data.assertion.numSteps <= vmParams.maxExecutionSteps, MAKE_STEP);coverage_0xb698eaca(0x28b256d14aa0d9a674b175c1f8d2c617790327e6035b35d69c0774df23f8a09c); /* assertPost */ \n\r\n    }\r\n\r\n    function _initializeAssertionLeaves(\r\n        NodeGraphUtils.AssertionData memory data,\r\n        bytes32 prevLeaf,\r\n        bytes32 vmProtoHashBefore,\r\n        bytes32 inboxValue,\r\n        uint256 inboxCount\r\n    ) private returns (bytes32) {coverage_0xb698eaca(0xd5a22ebd0db84bb9a149c3b78d625cea2fe621f406ff13ddf5dc91567e82097f); /* function */ \n\r\ncoverage_0xb698eaca(0x2e47e12139384014871ab4aa7950cf9403542ec318f3c7efbf204527897e091e); /* line */ \n        coverage_0xb698eaca(0x9c52e663934d5885a7009976e2f40f9cbddd4573ab97932c484d68e5049a7c02); /* statement */ \n(uint256 checkTimeTicks, uint256 deadlineTicks) = NodeGraphUtils.getTimeData(\r\n            vmParams,\r\n            data,\r\n            block.number\r\n        );\r\n\r\ncoverage_0xb698eaca(0x3e31b4b09438c648dc5d8895d8625e0eb9290260a4c0538fbe177211b4bc12da); /* line */ \n        coverage_0xb698eaca(0x1d7c543d9f9f33e78223a44d761339e71ce4f5aeec1b894b3a02eacfc55e550d); /* statement */ \nbytes32 invalidInboxLeaf = NodeGraphUtils.generateInvalidInboxTopLeaf(\r\n            data,\r\n            prevLeaf,\r\n            deadlineTicks,\r\n            inboxValue,\r\n            inboxCount,\r\n            vmProtoHashBefore,\r\n            vmParams.gracePeriodTicks\r\n        );\r\ncoverage_0xb698eaca(0x9dd4edee0ac375f6a8f5fd36d268eb298aaab1fdfaff0ea991c989334340cbed); /* line */ \n        coverage_0xb698eaca(0xa0924b59ca306da4a89f9f5d4f65022aab09295a86db7c248c6ac3b4cb21c769); /* statement */ \nbytes32 invalidExecLeaf = NodeGraphUtils.generateInvalidExecutionLeaf(\r\n            data,\r\n            prevLeaf,\r\n            deadlineTicks,\r\n            vmProtoHashBefore,\r\n            vmParams.gracePeriodTicks,\r\n            checkTimeTicks\r\n        );\r\ncoverage_0xb698eaca(0x64ac1a95b35b8b78d01c760242342ba23e89dea70ef0bfb8bd477fec93bc6bbd); /* line */ \n        coverage_0xb698eaca(0xa313a25fe1e70a6efac70c5da6dcec03ff25ef3d0c0d56ec60ace7de8dd6a038); /* statement */ \nbytes32 validLeaf = NodeGraphUtils.generateValidLeaf(data, prevLeaf, deadlineTicks);\r\n\r\ncoverage_0xb698eaca(0xc572575cb19c21a463fbeea74ece308c3e8a63b767982e4218d8676766e806cd); /* line */ \n        coverage_0xb698eaca(0x41d751bae5c74c740af9b64f491f0696714acc143eda22de05345af4b7edca3c); /* statement */ \nleaves[invalidInboxLeaf] = true;\r\ncoverage_0xb698eaca(0xba855d865f5087e28eb7b62cc3a613bbda858f65016a8189fe0a0b0b66301a50); /* line */ \n        coverage_0xb698eaca(0xbec13d37d311f6496a7837633792ea29bea42988270a01125a68a109473f4a1e); /* statement */ \nleaves[invalidExecLeaf] = true;\r\ncoverage_0xb698eaca(0x3facaa86b4320cad178af4be8cac572b9bf1df63a833adeba90c1ee9f223832a); /* line */ \n        coverage_0xb698eaca(0xff48323d709ce2025741434c5d47ebef388998124e64b7df53e07e9b7432e79a); /* statement */ \nleaves[validLeaf] = true;\r\n\r\ncoverage_0xb698eaca(0x9676872ba3c908d96e1bb89a05b4b84d2499071b218f1d41a23bf2b1a0b28ce0); /* line */ \n        coverage_0xb698eaca(0x52ef351e74d6a7ed3dcea68837464ad6e61a1cf380232614c9ae4d15518ed973); /* statement */ \nreturn validLeaf;\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/rollup/RollupUtils.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../arch/Marshaling.sol\";\r\nimport \"../libraries/RollupTime.sol\";\r\n\r\nimport \"../challenge/ChallengeUtils.sol\";\r\n\r\nlibrary RollupUtils {\nfunction coverage_0x63b290c9(bytes32 c__0x63b290c9) public pure {}\n\r\n    using Hashing for Value.Data;\r\n\r\n    string private constant CONF_INP = \"CONF_INP\";\r\n\r\n    struct ConfirmData {\r\n        bytes32 initalProtoStateHash;\r\n        uint256 initialSendCount;\r\n        uint256[] branches;\r\n        uint256[] deadlineTicks;\r\n        bytes32[] challengeNodeData;\r\n        bytes32[] logsAcc;\r\n        bytes32[] vmProtoStateHashes;\r\n        uint256[] messageCounts;\r\n        bytes messages;\r\n    }\r\n\r\n    struct NodeData {\r\n        uint256 validNum;\r\n        uint256 invalidNum;\r\n        uint256 messagesOffset;\r\n        bytes32 vmProtoStateHash;\r\n        uint256 beforeSendCount;\r\n        bytes32 nodeHash;\r\n    }\r\n\r\n    function getInitialNodeData(\r\n        bytes32 vmProtoStateHash,\r\n        uint256 beforeSendCount,\r\n        bytes32 confNode\r\n    ) private pure returns (NodeData memory) {coverage_0x63b290c9(0xd7e88230b56b3c9f841cf611f61bef7c693a3bb5d6302a56dfb4959c6fdbbff2); /* function */ \n\r\ncoverage_0x63b290c9(0x63446d23bffb8d2c891cff20244a4f5864b69095e70c1c18857fb449b7852bd7); /* line */ \n        coverage_0x63b290c9(0x5c08900f29c809d7af070a7ddd79613b54698965ac7f1e4b5e7d45e73f121a8c); /* statement */ \nreturn NodeData(0, 0, 0, vmProtoStateHash, beforeSendCount, confNode);\r\n    }\r\n\r\n    function confirm(ConfirmData memory data, bytes32 confNode)\r\n        internal\r\n        pure\r\n        returns (bytes32[] memory validNodeHashes, NodeData memory)\r\n    {coverage_0x63b290c9(0xb9650161fda910054bfbd3c2f89ba1847f7c044285e9315d43209b3712f50631); /* function */ \n\r\ncoverage_0x63b290c9(0x7249b106108278fb63549700361043d22ceb3f32aa348643a8c7ec857ef074de); /* line */ \n        coverage_0x63b290c9(0x45e252441bb7bf20402ffb8428d8d43957be211fcccb063e4b9e4e4ba256eac3); /* statement */ \nverifyDataLength(data);\r\n\r\ncoverage_0x63b290c9(0xadb1a1e0e499e742b8eb4de6cf652b90924dcc0510e1bf8ed6e59f30c2c93533); /* line */ \n        coverage_0x63b290c9(0xd6663aeb9dc8215b4a670d8e7da65a2eefc3cc2e2a8f5e7f1eee663cb53564f6); /* statement */ \nuint256 nodeCount = data.branches.length;\r\ncoverage_0x63b290c9(0x6bab0f86d52831cd01006fecdff6eb6c74f58b4354096df2c2820684a0838707); /* line */ \n        coverage_0x63b290c9(0xfd9c8e29864e0573bf9f6056f110a93e5e59628ed09974a26cb284e348499bf6); /* statement */ \nuint256 validNodeCount = data.messageCounts.length;\r\ncoverage_0x63b290c9(0xc6a174d9c05309a83f24abb55535f00b2acda6b5d0ea52cee15b046fee267431); /* line */ \n        coverage_0x63b290c9(0x5bbca21947ab118349448be8a70f6429d77ac206bf9e4f6a56cce82c5ccef955); /* statement */ \nvalidNodeHashes = new bytes32[](validNodeCount);\r\ncoverage_0x63b290c9(0x3490122b34708cd6874958c600d50d3812e50d8d948b5defda29a37ab0b2b2ce); /* line */ \n        coverage_0x63b290c9(0xb89f95dd722b20bb802061f919957451fdecc8d988ba7ee825d21719fe3c1f9c); /* statement */ \nNodeData memory currentNodeData = getInitialNodeData(\r\n            data.initalProtoStateHash,\r\n            data.initialSendCount,\r\n            confNode\r\n        );\r\n\r\ncoverage_0x63b290c9(0xc151d10d82434d5149d847c8760522d992d70c09bed154c07bfa6cb39a4645c0); /* line */ \n        coverage_0x63b290c9(0xef63a26ccbb925487af44786a1697150fd7bcb3485c70621e490d3d4c45f4986); /* statement */ \nfor (uint256 nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++) {\r\ncoverage_0x63b290c9(0x7283d6d9546c9ddaca9e012ad6e13050a60cd5d4f3da7425eb30aba96d68e805); /* line */ \n            coverage_0x63b290c9(0x74ddcc0634b45e9b4aa8fd4be894a436186e0db7c1f265a6c0f0649679804524); /* statement */ \nbool isValidChildType = processNode(data, currentNodeData, nodeIndex);\r\n\r\ncoverage_0x63b290c9(0xa66afd4d00b33453c8681cdef132ad8347a7756b8513c9258d1d77128e6b12b9); /* line */ \n            coverage_0x63b290c9(0xed82b153f7c968a9694c956ad892e987881ead6ed4e78cb9eb64ae13d280f213); /* statement */ \nif (isValidChildType) {coverage_0x63b290c9(0xb1f62885e7008ef34fce111da46703df4e2433a4d59625343c8df5e5e6a63f70); /* branch */ \n\r\ncoverage_0x63b290c9(0x07d45dfeacdef8347bfd75d022c8563f0eb6a6de6c8f91919a6bcc88b14018cb); /* line */ \n                coverage_0x63b290c9(0x55f5ddf83fa40e9bad43135f8d714abd19c3003d75ab1627b1c99ef5ee931d58); /* statement */ \nvalidNodeHashes[currentNodeData.validNum - 1] = currentNodeData.nodeHash;\r\n            }else { coverage_0x63b290c9(0xa01ca3d9cc23afd2954c8dcab16d14061bd1c1457d7ec4bae907fef43b321fc9); /* branch */ \n}\r\n        }\r\ncoverage_0x63b290c9(0x7e08832f9978a39086a220dd2606cc82dc9d515f578e54b2e4dca642a44acb77); /* line */ \n        coverage_0x63b290c9(0x3fc0b323f869949ab936de9a2f610d310d2ac33316f10e16ee6505020b2005bd); /* statement */ \nreturn (validNodeHashes, currentNodeData);\r\n    }\r\n\r\n    function processNode(\r\n        ConfirmData memory data,\r\n        NodeData memory nodeData,\r\n        uint256 nodeIndex\r\n    ) private pure returns (bool) {coverage_0x63b290c9(0xc7e5fb2a5e738bc9fd41d94f000dc00672d71c18419ebc956d58328812b0378f); /* function */ \n\r\ncoverage_0x63b290c9(0x76438496f0dec8a2604fd0ee69e3fc0cf6e3289ab538c688b81015c35aaaf97a); /* line */ \n        coverage_0x63b290c9(0xd1530c2b7206f5f347fb024f5b1c71a8e3a3d89e136bb97f1eff38bf1c32ae8b); /* statement */ \nuint256 branchType = data.branches[nodeIndex];\r\ncoverage_0x63b290c9(0xf5d5c77c98498772756b2782bdaa9b0b67c0ca289f68905d149b3ff7ac4fdb7d); /* line */ \n        coverage_0x63b290c9(0x4c0ee62e13131507183f760dc1b0fd953c5a607f836837edcb86e676fdd6c708); /* statement */ \nbool isValidChildType = (branchType == ChallengeUtils.getValidChildType());\r\ncoverage_0x63b290c9(0xa7d1691ed8afe4ada70eccc183fd232e1b99fa85f263b199072f8e4ec9bf125a); /* line */ \n        coverage_0x63b290c9(0x207c26bb5ed61266fed563684123acf9671452e66af007759918282804ec6363); /* statement */ \nbytes32 nodeDataHash;\r\n\r\ncoverage_0x63b290c9(0x4c2b9693b4d2d723626ada32593b7598f35950d093e4e258313eb63fe503b925); /* line */ \n        coverage_0x63b290c9(0xfe47b6c0bb80007b362718ee3de30a53c3a1b29487c4528960819fb8c159a0e6); /* statement */ \nif (isValidChildType) {coverage_0x63b290c9(0xa04bff0a471680f16c784f1ecb8a19cfe680475f243f29b536c508c6e43d5eec); /* branch */ \n\r\ncoverage_0x63b290c9(0xe412e530751027327d1e8be536646ed418e8895ae8da4512a668c6c73b924c27); /* line */ \n            coverage_0x63b290c9(0x07b3b734e0668357f6c94b0940460653574bd9d86e9770d40e0b1d04b4e8c5d7); /* statement */ \n(\r\n                nodeData.beforeSendCount,\r\n                nodeData.messagesOffset,\r\n                nodeDataHash,\r\n                nodeData.vmProtoStateHash\r\n            ) = processValidNode(\r\n                data,\r\n                nodeData.validNum,\r\n                nodeData.beforeSendCount,\r\n                nodeData.messagesOffset\r\n            );\r\ncoverage_0x63b290c9(0xe0e04c47d7d4759195f978507cee808e1c89a22750eb5cc0e418cb9243ad67b8); /* line */ \n            nodeData.validNum++;\r\n        } else {coverage_0x63b290c9(0x7e5cb4d37b76748df713048b9c22eff08747e7c43a34b276b9485f99b89b83ca); /* branch */ \n\r\ncoverage_0x63b290c9(0x24a4acfa0e15afc4b9f0910ecf7088e17644354fc675d9d75fb1d057be7e19da); /* line */ \n            coverage_0x63b290c9(0x797466588f511a080677169d67ae21a1ba0fcc319def9dba7ad6538744a604b7); /* statement */ \nnodeDataHash = data.challengeNodeData[nodeData.invalidNum];\r\ncoverage_0x63b290c9(0xae53b4f5b6783ac8a78c42656bc2a466293930f40952db5530e5ed1237edfdc9); /* line */ \n            nodeData.invalidNum++;\r\n        }\r\n\r\ncoverage_0x63b290c9(0xca5bb8c55d540cba49b846265100cb358f932595ea8370d239251c8e812b8391); /* line */ \n        coverage_0x63b290c9(0x1fc5d493659de523862acc9122b435003114e9f31fd6f402643ef8b8609656a0); /* statement */ \nnodeData.nodeHash = childNodeHash(\r\n            nodeData.nodeHash,\r\n            data.deadlineTicks[nodeIndex],\r\n            nodeDataHash,\r\n            branchType,\r\n            nodeData.vmProtoStateHash\r\n        );\r\n\r\ncoverage_0x63b290c9(0x521fb4e1a6c32d58135f26937774c02e80a1b5cc853d4bc728fa52a580da42e6); /* line */ \n        coverage_0x63b290c9(0xfd16ffc511bba69fdddc703dc2bbfe19bf55f2e09646610ac89a64cf19c42404); /* statement */ \nreturn isValidChildType;\r\n    }\r\n\r\n    function processValidNode(\r\n        ConfirmData memory data,\r\n        uint256 validNum,\r\n        uint256 beforeSendCount,\r\n        uint256 startOffset\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            bytes32,\r\n            bytes32\r\n        )\r\n    {coverage_0x63b290c9(0x97beb5588a4ef5b17182e7190a0a770e8729113ca8a5176beb00e195d4fc890a); /* function */ \n\r\ncoverage_0x63b290c9(0xe12243f493945fa6a46b35634b1dea9f0e4d784b9b453c1d34837cda2774ffc0); /* line */ \n        coverage_0x63b290c9(0xb7f177dfe72e5c0aed1fc2644ea778bba805850266b0d6fc7caae82cca9d3a78); /* statement */ \nuint256 sendCount = data.messageCounts[validNum];\r\ncoverage_0x63b290c9(0x7442cf6d17fc93442a5d5f09f91f0195300a5cf3d7b16a8f00c42ffdd7f2cf58); /* line */ \n        coverage_0x63b290c9(0x7cee0a6e5edd6f787f15723f47f028b0c2cb95ba4a4b44bf779448ec5301c203); /* statement */ \n(bytes32 lastMsgHash, uint256 messagesOffset) = generateLastMessageHash(\r\n            data.messages,\r\n            startOffset,\r\n            sendCount\r\n        );\r\ncoverage_0x63b290c9(0x15f4e006af5637eaf7aba6afb6916827750c895f46ef1d671196c5dd1bfd644c); /* line */ \n        coverage_0x63b290c9(0x9bb7bcebc27b46fd374f6d1e38f7296cb1c7a966255ad25f36c57a8af91049a1); /* statement */ \nbytes32 nodeDataHash = validDataHash(beforeSendCount, lastMsgHash, data.logsAcc[validNum]);\r\ncoverage_0x63b290c9(0x1eaffe9fb486c9d084be228aaa83e7f2be19b68db69b66a156439ed900cb426f); /* line */ \n        coverage_0x63b290c9(0x7cd4246dcf99fac5325aee4a2a11e58aea43677072b5a76798206094e564e330); /* statement */ \nbytes32 vmProtoStateHash = data.vmProtoStateHashes[validNum];\r\ncoverage_0x63b290c9(0x66ae5ac1d1f3b571299671ca9d26de59f87b952d848570a8ecf0f5517d228b7f); /* line */ \n        coverage_0x63b290c9(0x2df0a16f0826a980711f8ad2c834bfb8a1572f790cf02e544f652e79ba99eebe); /* statement */ \nreturn (beforeSendCount + sendCount, messagesOffset, nodeDataHash, vmProtoStateHash);\r\n    }\r\n\r\n    function generateLastMessageHash(\r\n        bytes memory messages,\r\n        uint256 startOffset,\r\n        uint256 count\r\n    ) internal pure returns (bytes32, uint256) {coverage_0x63b290c9(0xaa14d2810cec2061a0895796abf1a8b7b6a84538f944fb5de0f53da1731272f8); /* function */ \n\r\ncoverage_0x63b290c9(0x7753a3065c8f2836310b9b265280661ddfa5d5ff8cfe7bb5ec9193f0d373eae3); /* line */ \n        coverage_0x63b290c9(0xdd0901410cee03638f3e2591f23d909761aab93f188c514afeffff3f71b899c5); /* statement */ \nbytes32 hashVal = 0x00;\r\ncoverage_0x63b290c9(0x5bb1f2a1fdac791ae80067734d0267926e2149f57eec1334c3019ee028b89fe2); /* line */ \n        coverage_0x63b290c9(0xfe78a7113af519f114a5d5d47350e6cb695343089da6cbbc352b60672c91ee8c); /* statement */ \nValue.Data memory messageVal;\r\ncoverage_0x63b290c9(0x17b519c413e276fe34ac570c8a084d5d62a38b845b80239f08ae3c9524ac53a6); /* line */ \n        coverage_0x63b290c9(0x7dc9c233f11968af359f009d770481c5879db4b1974c9b06ceadd63bf392a1aa); /* statement */ \nuint256 offset = startOffset;\r\ncoverage_0x63b290c9(0x15e7f95c7e9222ca5b4662678bfd07b6539521758393fe34c0530366350453a8); /* line */ \n        coverage_0x63b290c9(0x5b429952dcc31a927546f3463a515b42a87952422d3721f8bba2b99c3c6c3ef4); /* statement */ \nfor (uint256 i = 0; i < count; i++) {\r\ncoverage_0x63b290c9(0x1c40d805e299b9de64101b304ce389bb2c5c1cbe684a4399a1bd76c36cc5dfa3); /* line */ \n            coverage_0x63b290c9(0xbc44c1ce8521700b8f86f01e39b51cc4e917867e5e5112f4d9e1f5ddff341a06); /* statement */ \n(offset, messageVal) = Marshaling.deserialize(messages, offset);\r\ncoverage_0x63b290c9(0x23c3ad1ee6d302779465b366284d36db357b52bdd5fb9de446fac813ce370402); /* line */ \n            coverage_0x63b290c9(0x2a9d2189c2e5f5726cfc4b2a6807ca8b681fb56d44ea34e443945dd7b6e2f0d4); /* statement */ \nhashVal = keccak256(abi.encodePacked(hashVal, messageVal.hash()));\r\n        }\r\ncoverage_0x63b290c9(0xfd21eb0026b6fa7f9d821b3c735ec2b3c8d7b176c7e56eb353710b391014551f); /* line */ \n        coverage_0x63b290c9(0x3759895b0ff3dbf0aa8b24eba86f1883018ed8db83926046b90fc8823d43ba86); /* statement */ \nreturn (hashVal, offset);\r\n    }\r\n\r\n    function verifyDataLength(RollupUtils.ConfirmData memory data) private pure {coverage_0x63b290c9(0x4b52df03e65caadb4370d1d20fcdf89e37d5b4e6497dfdd564701077d93b1274); /* function */ \n\r\ncoverage_0x63b290c9(0x4e7d8a26b9c81c7e4f9e0088e65737e1a0f530fcdadcccc1f93351c1526e0032); /* line */ \n        coverage_0x63b290c9(0xbc9842b8ef61f6995f896e538e48d661ae1a25779017729911ee192b2203df8d); /* statement */ \nuint256 nodeCount = data.branches.length;\r\ncoverage_0x63b290c9(0xbba969f8639ae59cc183b22f3848e701f76dadd863514e9363cc9183cf648df4); /* line */ \n        coverage_0x63b290c9(0x3a3cda5a2e7cc9042a7962f4add797a3fcf17aeb066db15b398713c0b3c6019d); /* statement */ \nuint256 validNodeCount = data.messageCounts.length;\r\ncoverage_0x63b290c9(0x9f8096fe49f99098a4746831f0c7b52b2f94f97deacbfb8b0a5aa9ba259598a8); /* line */ \n        coverage_0x63b290c9(0x5022dd4ea7ca3b39b49ed67e31939b429e332f1965bb434cd4d3338e18b9f4ea); /* assertPre */ \ncoverage_0x63b290c9(0x360687c5c97cfc75e08b1b58184c558da0e7dc04b41ee1877f5cd4e042380d4c); /* statement */ \nrequire(data.vmProtoStateHashes.length == validNodeCount, CONF_INP);coverage_0x63b290c9(0xe25c486ee4198c0364be4547f811da5008b34392e769902e25501c8ea6da58c2); /* assertPost */ \n\r\ncoverage_0x63b290c9(0x7b9d2a320ac0809df51544338659887ef0ad83ef46440f4f7bb277a991d25d7c); /* line */ \n        coverage_0x63b290c9(0xdf80db418715ba6ab33ba80b2700fada95aa7ac10bb8c6cc80d6956a890df5b6); /* assertPre */ \ncoverage_0x63b290c9(0xb7a0fcda511572108215a764d8d7e42adbde140cd5e95c6c62e7a3c1e5ef186e); /* statement */ \nrequire(data.logsAcc.length == validNodeCount, CONF_INP);coverage_0x63b290c9(0x1e9e18785a408ad533c63aada84616342e3fec608d89d025a56e541d9be6032e); /* assertPost */ \n\r\ncoverage_0x63b290c9(0x2722f1faec55f1f8a902ecbba9395a5d0376d2466ff26fb306f8fdbc3cf7bfb9); /* line */ \n        coverage_0x63b290c9(0xcc5a438f42d1716b95f47a55ab47ed90523d9293b3566862a26d1f1c390aea76); /* assertPre */ \ncoverage_0x63b290c9(0x839b7330ef1525c04d8f70597c811229fcf1e1833ec07699bc3d190e5bf468bd); /* statement */ \nrequire(data.deadlineTicks.length == nodeCount, CONF_INP);coverage_0x63b290c9(0x3866bd7428ca5aef87ba392f8d9676712a6192bf23c513009cfd4617a313e3b9); /* assertPost */ \n\r\ncoverage_0x63b290c9(0xd9675a83b5e00bffbc2f958567c3190fca1de5833aa0a280640e3f69cab419f3); /* line */ \n        coverage_0x63b290c9(0xf12bafdc33c53353d8586c7c000d64807f36b8355747083e1e58f8a6e3cc51c8); /* assertPre */ \ncoverage_0x63b290c9(0xc4f629aa962e11bc11ab2c052ab13d7bb295a488a41453d34acc6af8feef773f); /* statement */ \nrequire(data.challengeNodeData.length == nodeCount - validNodeCount, CONF_INP);coverage_0x63b290c9(0x1a08dd3e348d9990728d9e869e23cf1eee3f87fa11c7a5ed9c555b4a514480c3); /* assertPost */ \n\r\n    }\r\n\r\n    function protoStateHash(\r\n        bytes32 machineHash,\r\n        bytes32 inboxTop,\r\n        uint256 inboxCount,\r\n        uint256 messageCount,\r\n        uint256 logCount\r\n    ) internal pure returns (bytes32) {coverage_0x63b290c9(0x5b753810d5df4004ffb6ac6d9047a36e62236ab6ed26ff9f8f2e5bd160f806e2); /* function */ \n\r\ncoverage_0x63b290c9(0x47176693b81b5bd9f85bb578b7100f5a3a0dfbc8a9a016ce98d0411e235cfd24); /* line */ \n        coverage_0x63b290c9(0x55f8afcfef63aa1cd1d2502701f1c1b6f1c113198065dee54e8493303c2f0330); /* statement */ \nreturn\r\n            keccak256(abi.encodePacked(machineHash, inboxTop, inboxCount, messageCount, logCount));\r\n    }\r\n\r\n    function validDataHash(\r\n        uint256 beforeSendCount,\r\n        bytes32 messagesAcc,\r\n        bytes32 logsAcc\r\n    ) internal pure returns (bytes32) {coverage_0x63b290c9(0x2e6698ac3afc65f15a237de70aa587a9963246dfb13da90bb8107c5c6eebf57c); /* function */ \n\r\ncoverage_0x63b290c9(0x424b1c73b29e6db82efd2d1f52c176fbcfc51839d4750a4fe9eede480b42a682); /* line */ \n        coverage_0x63b290c9(0xf5448daec791ef8297815c6106dfe5a0294170a61ba6984b9d106d6cc61976a5); /* statement */ \nreturn keccak256(abi.encodePacked(beforeSendCount, messagesAcc, logsAcc));\r\n    }\r\n\r\n    function challengeDataHash(bytes32 challenge, uint256 challengePeriod)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {coverage_0x63b290c9(0xab5bd313f8153487b73246f5c36055f1850f018a591ea7e2ab4b7898c068b56e); /* function */ \n\r\ncoverage_0x63b290c9(0xf02ce2d6bea632ecc38c2ba96ef0e53337c1f7abe6f1cd23ae0c6e6ab8e6a70c); /* line */ \n        coverage_0x63b290c9(0x796dc60c5bdefc9fb7592de912e2284b9d3e95b00583e06e138aa22beab34a16); /* statement */ \nreturn keccak256(abi.encodePacked(challenge, challengePeriod));\r\n    }\r\n\r\n    function childNodeHash(\r\n        bytes32 prevNodeHash,\r\n        uint256 deadlineTicks,\r\n        bytes32 nodeDataHash,\r\n        uint256 childType,\r\n        bytes32 vmProtoStateHash\r\n    ) internal pure returns (bytes32) {coverage_0x63b290c9(0xf5874dd51727cb18d4cb126aa5209d0c88d3ae4ba89ab4fcfcdd0398c46370b9); /* function */ \n\r\ncoverage_0x63b290c9(0x157cafd4c185215582a9bfec7f63ef0d719ebf168516c2d6216b7887ba946144); /* line */ \n        coverage_0x63b290c9(0xd5c2657251cafe2548da0e2cda96dd1400c4b0f675fe0f33a0153be9a7177145); /* statement */ \nreturn\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    prevNodeHash,\r\n                    keccak256(\r\n                        abi.encodePacked(vmProtoStateHash, deadlineTicks, nodeDataHash, childType)\r\n                    )\r\n                )\r\n            );\r\n    }\r\n\r\n    function calculateLeafFromPath(bytes32 from, bytes32[] memory proof)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {coverage_0x63b290c9(0x31c2602ffe5836d3e8d1b85aef7315f50f8cef4def275f6c6d646f21645e5c31); /* function */ \n\r\ncoverage_0x63b290c9(0xe9c4ef0a382698cc069300432a1d05bebc8b88492154ff06878937f56ed09206); /* line */ \n        coverage_0x63b290c9(0xf1b1380d0322dc75ef614d20df00c14d8ea22448dd936b3e7f9587370535e77b); /* statement */ \nreturn calculateLeafFromPath(from, proof, 0, proof.length);\r\n    }\r\n\r\n    function calculateLeafFromPath(\r\n        bytes32 from,\r\n        bytes32[] memory proof,\r\n        uint256 start,\r\n        uint256 end\r\n    ) internal pure returns (bytes32) {coverage_0x63b290c9(0x56bbfc43a8eedf22d69e8ceb98269337eace5c79eb9b64b868a03a6caaa9fb8e); /* function */ \n\r\ncoverage_0x63b290c9(0xfd6bf20ea888de5a2b080aadb34dbf1c7ec942ac03d1f340323e4a8d8def53ef); /* line */ \n        coverage_0x63b290c9(0x8cb12367cf532f8f9e7f9a037fc3bb06ee5df7e59c8f92b6a6ac11190c991fc2); /* statement */ \nbytes32 node = from;\r\ncoverage_0x63b290c9(0xd318be12e30892e3daf94b0001e6afae818ced07c0706a9a5c296378cbed8d3e); /* line */ \n        coverage_0x63b290c9(0x6be5756ecc65f0a36e2f5f554d6221db7c0994fac2f4281e4e6d1a4e1acf01e2); /* statement */ \nfor (uint256 i = start; i < end; i++) {\r\ncoverage_0x63b290c9(0x4ba0d163580cdabaa6094b2bbcdea6476d6337d82cb678bada43c6ae5fd7852a); /* line */ \n            coverage_0x63b290c9(0x6d886ac023f057400433769067fa459e029e3d9e41be7dfc7f22d2b1174fa437); /* statement */ \nnode = keccak256(abi.encodePacked(node, proof[i]));\r\n        }\r\ncoverage_0x63b290c9(0x8f3c9e6c9b5e7c31ebc2707a61d5e9d8be5e4ac82b14853e750cb2e579620f73); /* line */ \n        coverage_0x63b290c9(0xda38fbc860989fe4b0ec539fd276f0ca1f49331674c9716775eada3d90621e34); /* statement */ \nreturn node;\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/rollup/NodeGraphUtils.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"./RollupUtils.sol\";\r\nimport \"../libraries/RollupTime.sol\";\r\nimport \"../challenge/ChallengeUtils.sol\";\r\nimport \"./VM.sol\";\r\n\r\nlibrary NodeGraphUtils {\nfunction coverage_0x47df6391(bytes32 c__0x47df6391) public pure {}\n\r\n    using Hashing for Value.Data;\r\n\r\n    struct AssertionData {\r\n        uint256 beforeInboxCount;\r\n        bytes32 prevPrevLeafHash;\r\n        uint256 prevDeadlineTicks;\r\n        bytes32 prevDataHash;\r\n        uint32 prevChildType;\r\n        uint256 importedMessageCount;\r\n        uint256 beforeMessageCount;\r\n        uint256 beforeLogCount;\r\n        ChallengeUtils.ExecutionAssertion assertion;\r\n    }\r\n\r\n    function makeAssertion(\r\n        bytes32[8] memory fields,\r\n        uint256[5] memory fields2,\r\n        uint32 prevChildType,\r\n        uint64 numSteps,\r\n        uint64 numArbGas,\r\n        uint64 messageCount,\r\n        uint64 logCount\r\n    ) internal pure returns (AssertionData memory) {coverage_0x47df6391(0xd28e23ff0123096cc3fcf4b4d48b1b73d8a5b5f9d2fc79303a841ee6eff17e7e); /* function */ \n\r\ncoverage_0x47df6391(0x43a0d8a3b835075986d1f3288f6ed6432f52358951f4627f231d8d680d76eb47); /* line */ \n        coverage_0x47df6391(0xd7f6fbb48138663ca4020e0fd80feda38dce127bcee35015bcc61ed4b81623fd); /* statement */ \nChallengeUtils.ExecutionAssertion memory assertion = ChallengeUtils.ExecutionAssertion(\r\n            numSteps,\r\n            numArbGas,\r\n            fields[0],\r\n            fields[1],\r\n            fields[2],\r\n            fields[3],\r\n            0,\r\n            fields[4],\r\n            messageCount,\r\n            0,\r\n            fields[5],\r\n            logCount\r\n        );\r\ncoverage_0x47df6391(0x1ddd1cfdf786ac776c23c914e0500482602e2418cfae2493810fbc0a48a6976f); /* line */ \n        coverage_0x47df6391(0xeaf4fd4eac0b7772d63ff3150f46d8b1a6d644e7aa0f0cd44b71c3717c96f49f); /* statement */ \nreturn\r\n            AssertionData(\r\n                fields2[0],\r\n                fields[6],\r\n                fields2[1],\r\n                fields[7],\r\n                prevChildType,\r\n                fields2[2],\r\n                fields2[3],\r\n                fields2[4],\r\n                assertion\r\n            );\r\n    }\r\n\r\n    function computePrevLeaf(AssertionData memory data)\r\n        internal\r\n        pure\r\n        returns (bytes32 prevLeaf, bytes32 vmProtoHashBefore)\r\n    {coverage_0x47df6391(0x2b9c4942c389b4bd4647877e412e0e81fb959b81c9fb42ea6aaf142688452c20); /* function */ \n\r\ncoverage_0x47df6391(0xd46f40c60f3d35cb84b8caa2032c218f3aaa83060be67acd000c5935f6600585); /* line */ \n        coverage_0x47df6391(0xb73ad2df5c0c0b8f6ce9d5d9c24dd746fabb7f297ad7d8c780bad668cece0ab2); /* statement */ \nvmProtoHashBefore = RollupUtils.protoStateHash(\r\n            data.assertion.beforeMachineHash,\r\n            data.assertion.beforeInboxHash,\r\n            data.beforeInboxCount,\r\n            data.beforeMessageCount,\r\n            data.beforeLogCount\r\n        );\r\ncoverage_0x47df6391(0xaeb6f1bb2cc01151c4fe283b7d3f0d8a1cba7f2ece265e5ac546405c81ff4e23); /* line */ \n        coverage_0x47df6391(0x9b9956fce04bb97760e85ee50cb7aef4aa317671347ae4049350328fb4f0f388); /* statement */ \nprevLeaf = RollupUtils.childNodeHash(\r\n            data.prevPrevLeafHash,\r\n            data.prevDeadlineTicks,\r\n            data.prevDataHash,\r\n            data.prevChildType,\r\n            vmProtoHashBefore\r\n        );\r\n    }\r\n\r\n    function getTimeData(\r\n        VM.Params memory vmParams,\r\n        AssertionData memory data,\r\n        uint256 blockNum\r\n    ) internal pure returns (uint256, uint256) {coverage_0x47df6391(0xcc33bfe366a9a0727848881c1ceee5d4982937bbede2c16c846e5fc9bb5bbfdf); /* function */ \n\r\ncoverage_0x47df6391(0x161288b6c8c044852dda56c9a211cd1a2d82b8673927131526cda9fa4c135244); /* line */ \n        coverage_0x47df6391(0xd301a55070c9c7b14c3063ad96a247c00bbf736e66d20de42d447b5ed795c6e7); /* statement */ \nuint256 checkTimeTicks = data.assertion.numArbGas / vmParams.arbGasSpeedLimitPerTick;\r\ncoverage_0x47df6391(0xf313344c9cf3af44f8045ae85d5b379d8cab62b659bf850c7f509e268f0ce494); /* line */ \n        coverage_0x47df6391(0x0e3e08696d9d532ef1de23f4dc03548761bf516ea3509abb078f985055ca63fd); /* statement */ \nuint256 deadlineTicks = RollupTime.blocksToTicks(blockNum) + vmParams.gracePeriodTicks;\r\ncoverage_0x47df6391(0x0ceac69c135db2cbc99eec43703228fd0b90a02b2a479b70152bf34157f59751); /* line */ \n        coverage_0x47df6391(0x33369742ddb14840ac8173e378545d478ce756d95d888979d95ea36edd67967c); /* statement */ \nif (deadlineTicks < data.prevDeadlineTicks) {coverage_0x47df6391(0x2bfc29ab6c2d38d60abcdc26f51c658d00d52a050f1c9cbb354b1a78ea3caaf0); /* branch */ \n\r\ncoverage_0x47df6391(0xcd7b42f23d20c1d6200b5623a5edb3a30ee8a5c6fe1ae24252bb933951fdb2a9); /* line */ \n            coverage_0x47df6391(0x8429fd93231cc5143573507031eb6c84e9a79515971acd9b76dc66f65629e2c9); /* statement */ \ndeadlineTicks = data.prevDeadlineTicks;\r\n        }else { coverage_0x47df6391(0xe2d07ff1ece53d757c05bb9444fab24f18ec6c55e962320d333139c78345f401); /* branch */ \n}\r\ncoverage_0x47df6391(0x4deec32f26d5771463e6526c50140cf9ac4354cda5e72b3ad8a6cb2f535792f5); /* line */ \n        coverage_0x47df6391(0x533ae11684d926ef29481073139946b43ef5ec66eaf4c00a05a62e7ead803388); /* statement */ \ndeadlineTicks += checkTimeTicks;\r\n\r\ncoverage_0x47df6391(0xec4efb908cb94021442a85d8d6fffecb667fa0505cde28f48803f75935459aed); /* line */ \n        coverage_0x47df6391(0x3ed2b7bdb83c2ebc614ad64a29be01f5664cd7571bb790c78f6e6c202a67041a); /* statement */ \nreturn (checkTimeTicks, deadlineTicks);\r\n    }\r\n\r\n    function generateInvalidInboxTopLeaf(\r\n        AssertionData memory data,\r\n        bytes32 prevLeaf,\r\n        uint256 deadlineTicks,\r\n        bytes32 inboxValue,\r\n        uint256 inboxCount,\r\n        bytes32 vmProtoHashBefore,\r\n        uint256 gracePeriodTicks\r\n    ) internal pure returns (bytes32) {coverage_0x47df6391(0x9446f4785bfe65841c64a5164ceedc872137b80bfd0933741d7d7546df099b32); /* function */ \n\r\ncoverage_0x47df6391(0xd81a6fdaf436eaa5634b64f2414cc16b16e293fe9a51699298e7731bf33276e9); /* line */ \n        coverage_0x47df6391(0x9258b3571c2b4a1516f21eee11531ed9c0f59709f8bd8f7541fc70d960f2f0e4); /* statement */ \nbytes32 challengeHash = ChallengeUtils.inboxTopHash(\r\n            data.assertion.afterInboxHash,\r\n            inboxValue,\r\n            inboxCount - (data.beforeInboxCount + data.importedMessageCount)\r\n        );\r\ncoverage_0x47df6391(0xcce478e5f5b15d349663dedcb6b07bdbe5b66bbb16aefe733467d4dea7ad9cbe); /* line */ \n        coverage_0x47df6391(0x7ff2778ba1cc3eff6f20d4b30283d6ef0204b7fab15bea188bab2f32ab03baba); /* statement */ \nreturn\r\n            RollupUtils.childNodeHash(\r\n                prevLeaf,\r\n                deadlineTicks,\r\n                RollupUtils.challengeDataHash(\r\n                    challengeHash,\r\n                    gracePeriodTicks + RollupTime.blocksToTicks(1)\r\n                ),\r\n                ChallengeUtils.getInvalidInboxType(),\r\n                vmProtoHashBefore\r\n            );\r\n    }\r\n\r\n    function generateInvalidExecutionLeaf(\r\n        AssertionData memory data,\r\n        bytes32 prevLeaf,\r\n        uint256 deadlineTicks,\r\n        bytes32 vmProtoHashBefore,\r\n        uint256 gracePeriodTicks,\r\n        uint256 checkTimeTicks\r\n    ) internal pure returns (bytes32 leaf) {coverage_0x47df6391(0xec881faed8ca38792f42e55797b1a80a6ed0cbcd7e50672ca68eeae413ba5a3d); /* function */ \n\r\ncoverage_0x47df6391(0xafde0ca665140b8ccff2dd6de9a409a7a663e2e760de877dcf1ab4c407c3d87c); /* line */ \n        coverage_0x47df6391(0xfec7b8311021b7a34655d63a3c896077cde8fd9360ec7c76b3aaa47d4648e26a); /* statement */ \nreturn\r\n            RollupUtils.childNodeHash(\r\n                prevLeaf,\r\n                deadlineTicks,\r\n                RollupUtils.challengeDataHash(\r\n                    ChallengeUtils.hash(data.assertion),\r\n                    gracePeriodTicks + checkTimeTicks\r\n                ),\r\n                ChallengeUtils.getInvalidExType(),\r\n                vmProtoHashBefore\r\n            );\r\n    }\r\n\r\n    function generateValidLeaf(\r\n        AssertionData memory data,\r\n        bytes32 prevLeaf,\r\n        uint256 deadlineTicks\r\n    ) internal pure returns (bytes32) {coverage_0x47df6391(0x931ba5aef9e35b60577d5698e20d7abe8d86d44b501ddce004b062b5f88fa045); /* function */ \n\r\ncoverage_0x47df6391(0x26d32fb918c30128604fb5f03e47abfb036c2568c802e5bc98364f808a2fb198); /* line */ \n        coverage_0x47df6391(0xbcbd0555afa7d123be37bf77f901dadc80394bd5c1db61775a3ad954c475eed0); /* statement */ \nreturn\r\n            RollupUtils.childNodeHash(\r\n                prevLeaf,\r\n                deadlineTicks,\r\n                RollupUtils.validDataHash(\r\n                    data.beforeMessageCount,\r\n                    data.assertion.lastMessageHash,\r\n                    data.assertion.lastLogHash\r\n                ),\r\n                ChallengeUtils.getValidChildType(),\r\n                RollupUtils.protoStateHash(\r\n                    data.assertion.afterMachineHash,\r\n                    data.assertion.afterInboxHash,\r\n                    data.beforeInboxCount + data.importedMessageCount,\r\n                    data.beforeMessageCount + data.assertion.messageCount,\r\n                    data.beforeLogCount + data.assertion.logCount\r\n                )\r\n            );\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/rollup/VM.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../arch/Value.sol\";\r\nimport \"../libraries/SafeMath.sol\";\r\n\r\nlibrary VM {\nfunction coverage_0xc626c09e(bytes32 c__0xc626c09e) public pure {}\n\r\n    using SafeMath for uint256;\r\n\r\n    bytes32 private constant MACHINE_HALT_HASH = bytes32(0);\r\n    bytes32 private constant MACHINE_ERROR_HASH = bytes32(uint256(1));\r\n\r\n    struct Params {\r\n        // these are defined just once for each vM\r\n        uint256 gracePeriodTicks;\r\n        uint256 arbGasSpeedLimitPerTick;\r\n        uint64 maxExecutionSteps;\r\n    }\r\n\r\n    function isErrored(bytes32 vmStateHash) internal pure returns (bool) {coverage_0xc626c09e(0x27f747c9a64b4e76853001893d0f821cc9602efe79191a4c88dc1854c2e71ca1); /* function */ \n\r\ncoverage_0xc626c09e(0xba0516ed44ea8af053f998a65d842d23caba0bb12d659312afac6773633c78eb); /* line */ \n        coverage_0xc626c09e(0x223734d41d2f8c56888cc25c30a15e9cd7191d9bbe4b88691b6bab88ad845287); /* statement */ \nreturn vmStateHash == MACHINE_ERROR_HASH;\r\n    }\r\n\r\n    function isHalted(bytes32 vmStateHash) internal pure returns (bool) {coverage_0xc626c09e(0x040c6d14e59b250ec1352a90007dd78ebd0881243e78b29969b44ce5a41558af); /* function */ \n\r\ncoverage_0xc626c09e(0x2a35a1ec93a9b4a2d1a089eb5725af5e3d40c11446120becb00afe5e07d14125); /* line */ \n        coverage_0xc626c09e(0x7c38be7fe044d5a703b4138f8ae855568eb6f86ddb7841806bafc4686c2f7650); /* statement */ \nreturn vmStateHash == MACHINE_HALT_HASH;\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/rollup/Staking.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"./RollupUtils.sol\";\r\nimport \"../libraries/RollupTime.sol\";\r\n\r\nimport \"../challenge/ChallengeUtils.sol\";\r\nimport \"../challenge/IChallengeFactory.sol\";\r\n\r\nimport \"../interfaces/IERC20.sol\";\r\n\r\ncontract Staking {\nfunction coverage_0xed03da06(bytes32 c__0xed03da06) public pure {}\n\r\n    // VM already initialized\"\r\n    string private constant INIT_TWICE = \"INIT_TWICE\";\r\n    // Challenge factory must be nonzero\r\n    string private constant INIT_NONZERO = \"INIT_NONZERO\";\r\n\r\n    // Invalid staker\r\n    string private constant INV_STAKER = \"INV_STAKER\";\r\n\r\n    // must supply stake value\r\n    string private constant STK_AMT = \"STK_AMT\";\r\n    // Staker already exists\r\n    string private constant TRANSFER_FAILED = \"TRANSFER_FAILED\";\r\n    string private constant ALRDY_STAKED = \"ALRDY_STAKED\";\r\n\r\n    // Challenge can only be resolved by spawned contract\r\n    string private constant RES_CHAL_SENDER = \"RES_CHAL_SENDER\";\r\n\r\n    // staker1 staked after deadline\r\n    string private constant STK1_DEADLINE = \"STK1_DEADLINE\";\r\n    // staker2 staked after deadline\r\n    string private constant STK2_DEADLINE = \"STK2_DEADLINE\";\r\n    // staker1 already in a challenge\r\n    string private constant STK1_IN_CHAL = \"STK1_IN_CHAL\";\r\n    // staker2 already in a challenge\r\n    string private constant STK2_IN_CHAL = \"STK2_IN_CHAL\";\r\n    // Child types must be ordered\r\n    string private constant TYPE_ORDER = \"TYPE_ORDER\";\r\n    // Invalid child type\r\n    string private constant INVLD_CHLD_TYPE = \"INVLD_CHLD_TYPE\";\r\n    // Challenge asserter proof\r\n    string private constant ASSERT_PROOF = \"ASSERT_PROOF\";\r\n    // Challenge challenger proof\r\n    string private constant CHAL_PROOF = \"CHAL_PROOF\";\r\n\r\n    // must include proof for all stakers\r\n    string private constant CHCK_COUNT = \"CHCK_COUNT\";\r\n    // Stakers must be ordered\r\n    string private constant CHCK_ORDER = \"CHCK_ORDER\";\r\n    // at least one active staker disagrees\r\n    string private constant CHCK_STAKER_PROOF = \"CHCK_STAKER_PROOF\";\r\n    string private constant CHCK_OFFSETS = \"CHCK_OFFSETS\";\r\n\r\n    uint256 private constant MAX_CHILD_TYPE = 3;\r\n\r\n    IChallengeFactory public challengeFactory;\r\n\r\n    struct Staker {\r\n        bytes32 location;\r\n        uint128 creationTimeBlocks;\r\n        bool inChallenge;\r\n    }\r\n\r\n    uint128 private stakeRequirement;\r\n    address private stakeToken;\r\n    mapping(address => Staker) private stakers;\r\n    uint256 private stakerCount;\r\n    mapping(address => bool) private challenges;\r\n    mapping(address => uint256) withdrawnStakes;\r\n\r\n    event RollupStakeCreated(address staker, bytes32 nodeHash);\r\n\r\n    event RollupStakeRefunded(address staker);\r\n\r\n    event RollupStakeMoved(address staker, bytes32 toNodeHash);\r\n\r\n    event RollupChallengeStarted(\r\n        address asserter,\r\n        address challenger,\r\n        uint256 challengeType,\r\n        address challengeContract\r\n    );\r\n\r\n    event RollupChallengeCompleted(address challengeContract, address winner, address loser);\r\n\r\n    function getStakeRequired() external view returns (uint128) {coverage_0xed03da06(0x8acc824a894c211012d1059a49d82974b5cb62ddb3766fc85941839775a4b5f7); /* function */ \n\r\ncoverage_0xed03da06(0xb740b8e426c29f5fa5a3fce1c0f6791b68236351db5cfb5999023d028a9a8781); /* line */ \n        coverage_0xed03da06(0x99e00f79662abc38bc7b9b447b29145fd58b40a9dc3c6c6585b9bc300f6deae5); /* statement */ \nreturn stakeRequirement;\r\n    }\r\n\r\n    function getStakeToken() external view returns (address) {coverage_0xed03da06(0xee32af772618ec9a8dcc9f987b917d161ddf6c43d7998db04a03b76a0710cf4a); /* function */ \n\r\ncoverage_0xed03da06(0x85698d7ea1864016f4926606a51e7e979a95f9d6d676bb27df612295b1ff5ed0); /* line */ \n        coverage_0xed03da06(0x618b181067a9ff539f2285269279a6f3ffd4fc5e25112a4ba7e699d3a7d64944); /* statement */ \nreturn stakeToken;\r\n    }\r\n\r\n    function isStaked(address _stakerAddress) external view returns (bool) {coverage_0xed03da06(0x1bf7171d86354338228ec10a0d53d89a4b0dc42e379fb28ea0cdf722b1c03132); /* function */ \n\r\ncoverage_0xed03da06(0x32f2da19b55aa8f4334606464b2666df883f4951e6fc1477208d374b8a595357); /* line */ \n        coverage_0xed03da06(0xf33a97542ab56e558f4d78c24c0c6e0ff56d12241c5c11731f7de7eeafcd1b66); /* statement */ \nreturn stakers[_stakerAddress].location != 0x00;\r\n    }\r\n\r\n    function getWithdrawnStake(address payable _staker) external {coverage_0xed03da06(0x457483176bcda64282d5533511469b3273c3834d47e0687849f7b3bb2014a889); /* function */ \n\r\ncoverage_0xed03da06(0x3c3163cd2e4f678972930a8ac83d807c850a7210414c4140cd6e929228560b63); /* line */ \n        coverage_0xed03da06(0x277d6f9a6d4e80598c7be85cffd478fd407d27427583bc74429844c4d61cbd02); /* statement */ \nuint256 amount = withdrawnStakes[_staker];\r\ncoverage_0xed03da06(0x11312e98ef789f38dfa2aea49cdf3a0a838d17401d7d5d9c402261947f5446bd); /* line */ \n        coverage_0xed03da06(0xac9038bcd36ebff8a74c69c60e1545c84a10f76652c723c8da8855c12e6a4b05); /* statement */ \nif (amount == 0) {coverage_0xed03da06(0x9519540c367803c7f72d24ef0e8891ade27eace19bd0c1f9b73cd309192fe12a); /* branch */ \n\r\ncoverage_0xed03da06(0x0138302267fca5fd2784e811f3444648f3d9dedc6aa2a9b935f1170ab7d3694d); /* line */ \n            coverage_0xed03da06(0xbc935aa8c0f46fa3bf57ef5bbed6c6eeb2458a6297d321a8bb511229f87966d4); /* statement */ \nreturn;\r\n        }else { coverage_0xed03da06(0x789f690d8b6526060faf9097dbd7461d7a63e6c6feef175ff2bd1532e245eff3); /* branch */ \n}\r\ncoverage_0xed03da06(0x8c6e2987eed61918cc6578109e4d59a61c0748a810997770d2528b6b801cb016); /* line */ \n        coverage_0xed03da06(0xc56f3c7f88ae9fdfe39dadbb2ca989b02b1df7111133cbbeb2ba49ae695dceac); /* statement */ \nif (stakeToken == address(0)) {coverage_0xed03da06(0x680cefd735e5a765ce761eec71a977131bad160df5dc288cd990d9adf5720da4); /* branch */ \n\r\ncoverage_0xed03da06(0x5d25ba0220a456af9e8990a39dc6241b7df8a345bf64ff181688800e1ae5a8c8); /* line */ \n            coverage_0xed03da06(0xa44a598a05831c7bff5f15e576bd151fcb14733ead6b58b5b69d6785079e163d); /* statement */ \n_staker.transfer(amount);\r\n        } else {coverage_0xed03da06(0xf1e6364212de9c39fcb27551117ea039efb61372db622f8d93714e1396830392); /* branch */ \n\r\ncoverage_0xed03da06(0x4b7e25960adf9e7abb5e23a29b49b55ba4de22a6fd20f584a98431a9fa5512a1); /* line */ \n            coverage_0xed03da06(0x63dde9c1c52ae9fafa533abe86453580cb6125e66a633c1e218413e1f80ca884); /* assertPre */ \ncoverage_0xed03da06(0x188abc39043f34501593b19f8fd4c9b4b75b1bd686d341ef82f0e4605991fada); /* statement */ \nrequire(IERC20(stakeToken).transfer(_staker, amount), TRANSFER_FAILED);coverage_0xed03da06(0xc3996780752b21cf0b5eca76eb3fce931eeadd3c12adaf3cf28f8fc3a95a248a); /* assertPost */ \n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update stakers with the result of a challenge that has ended. The winner received half of the losers deposit and the rest is burned\r\n     * @dev Currently the rollup contract keeps the burned funds. These are frozen since the rollup contract has no way to withdraw them\r\n     * @dev This function can only be called by a challenge contract launched by this contract. Because of this we don't require any other input validator\r\n     * @dev Consider using CREATE2 to eliminate the need to remember what challenges we've launched\r\n     * @param winner The address of the staker who won the challenge\r\n     * @param loser The address of the staker who lost the challenge\r\n     */\r\n    function resolveChallenge(address payable winner, address loser) external {coverage_0xed03da06(0x8b452bd8e083a8d8f1417dc2c4e7dd848919b621d0ad4763b2affd882bba2e35); /* function */ \n\r\ncoverage_0xed03da06(0x0f4744dfbd6a3eaf51a4d82ddcc4d7529bf83cfd90ca4a47bf83561c76ae2b45); /* line */ \n        coverage_0xed03da06(0xc369f5eeff28fbd0fa870d46a399d24c4d584ce2ce9f1c583ba7c5f2ec766c9b); /* assertPre */ \ncoverage_0xed03da06(0xaf1543e21431779c1f81f78e93da285862f13f64dfd49eb2c2efb0a5a330f7f1); /* statement */ \nrequire(challenges[msg.sender], RES_CHAL_SENDER);coverage_0xed03da06(0x3d3646f4b2cc6638e5e351bad803b69fae22d8888e1d9c80e2150a3adab22d1d); /* assertPost */ \n\r\ncoverage_0xed03da06(0xa05776ee1ab0ab054cb4172978b380ea08247fdbf91619f33f90ded354db688b); /* line */ \n        delete challenges[msg.sender];\r\n\r\ncoverage_0xed03da06(0x3fdd89f8eeb25ff248c343b41f99033e6a1875b0c925c689460a5bd713d3eb07); /* line */ \n        coverage_0xed03da06(0xc1dcfcb430f3f2ae7c16522a22b92a7d8d7c6ba2ce1202fe772ec996fddf00c4); /* statement */ \nStaker storage winningStaker = getValidStaker(address(winner));\r\ncoverage_0xed03da06(0xb51a4a950bb1e362b16d682fa42d129590af81d1d0e986741ead70ce7062d831); /* line */ \n        coverage_0xed03da06(0xc3e961aab1867693f93286b06521bae0575dd8bf719e992a9ba3851cd48ea7cb); /* statement */ \nwithdrawnStakes[winner] += stakeRequirement / 2;\r\ncoverage_0xed03da06(0x8a2bb94dee358e809cdce6c9f143659a5a0a3e38d8fa57d323fabd030333fc2f); /* line */ \n        coverage_0xed03da06(0xb557d5ba9479cc30afee4b35ad8a1a0529832037dafd62ebdd0be8b996ef6f28); /* statement */ \nwinningStaker.inChallenge = false;\r\ncoverage_0xed03da06(0x86cdb3908dc5f2d75de0ccc8dd7c526fd96e3a28392d2bb54f5499540e561834); /* line */ \n        coverage_0xed03da06(0x5b5de9feec34068f594072c2ffb9de72c92dccaddcdbe33236b7b5ace52bf9bc); /* statement */ \ndeleteStaker(loser);\r\n\r\ncoverage_0xed03da06(0x7ee130ef2594aa3b1edee290311a08e5ed63e6f6ff655adf11c5985688602734); /* line */ \n        coverage_0xed03da06(0x54e97bba68d39822b999cf00e15906c42647d03b1a7a2dde1e1569815a2196b6); /* statement */ \nemit RollupChallengeCompleted(msg.sender, address(winner), loser);\r\n    }\r\n\r\n    /**\r\n     * @notice Initiate a challenge between two validators staked on this rollup chain.\r\n     * @dev Anyone can force two conflicted validators to engage in a challenge\r\n     * @dev The challenge will occur on the oldest node that the two validators disagree about\r\n     * @param asserterAddress The staker who claimed a given node was valid\r\n     * @param challengerAddress The address who claimed that the same node was invalid\r\n     * @param prevNode The node which is the parent of the two conflicting nodes the asserter and challenger are on\r\n     * @param deadlineTicks The deadline to challenge the asserter's node\r\n     * @param stakerNodeTypes The type of nodes that the asserter and challenger are staked on\r\n     * @param vmProtoHashes The protocol states claimed by each validator\r\n     * @param asserterProof A proof that the asserter actually staked that the claimed node was correct\r\n     * @param challengerProof A proof that the challenger actually staked that hte claimed node was invalid\r\n     * @param asserterNodeHash Type specific data in the asserter's node\r\n     * @param challengerDataHash Information from the challenger's node about the claim the asserter is disputing\r\n     * @param challengerPeriodTicks Amount of time dedicated to rounds of the challenge created\r\n     */\r\n    function startChallenge(\r\n        address payable asserterAddress,\r\n        address payable challengerAddress,\r\n        bytes32 prevNode,\r\n        uint256 deadlineTicks,\r\n        uint256[2] memory stakerNodeTypes, // [asserterNodeType, challengerNodeType]\r\n        bytes32[2] memory vmProtoHashes, // [asserterVMProtoHash, challengerVMProtoHash]\r\n        bytes32[] memory asserterProof,\r\n        bytes32[] memory challengerProof,\r\n        bytes32 asserterNodeHash,\r\n        bytes32 challengerDataHash,\r\n        uint128 challengerPeriodTicks\r\n    ) public {coverage_0xed03da06(0x009a994456adb4cc10d5d92de26b402e88f48ff1d06210d810f338e48714968f); /* function */ \n\r\ncoverage_0xed03da06(0x9077e4b39fc67807b82e928c0023236cb4c5233e3c171d110df12af185c22d2c); /* line */ \n        coverage_0xed03da06(0xf93b24ee98965411779bddc2a10ad184fbc006bc0e43f3a2caa901d22f8b3a51); /* statement */ \nStaker storage asserter = getValidStaker(asserterAddress);\r\ncoverage_0xed03da06(0x14389068166241631916f1f98a45580ad40a9edc5380108d04e83c023b9bd7fe); /* line */ \n        coverage_0xed03da06(0x602936d346e2181372be9e321911803956ef3eef43cd9b7984d4c845cc5b2f33); /* statement */ \nStaker storage challenger = getValidStaker(challengerAddress);\r\n\r\ncoverage_0xed03da06(0xb363c5f1ae4665d15f66f00dd2c2498f6a764f066f2707f2117f636fb8907f84); /* line */ \n        coverage_0xed03da06(0x82b71f6ce93a67c64c27adeb8582eae622dbdb178c19874906abe0ac8d631a01); /* assertPre */ \ncoverage_0xed03da06(0x85e4cb4379a6b09c52d43bab89af2fce09046e240f4eedf4f6f3c4363612ae78); /* statement */ \nrequire(\r\n            RollupTime.blocksToTicks(asserter.creationTimeBlocks) < deadlineTicks,\r\n            STK1_DEADLINE\r\n        );coverage_0xed03da06(0x4f439e2cca576e7c97d7d0c8071c69c7518c10388489e3b1ff76bb46993c2a7b); /* assertPost */ \n\r\ncoverage_0xed03da06(0xe59a09b883f5e06cccbb19d792ded169dc0e441e12af65c5df091dea16656124); /* line */ \n        coverage_0xed03da06(0x1e7b1e9811ac94dc6537c30974ac9ff79b432ce40591c52c91b7da9436a496c3); /* assertPre */ \ncoverage_0xed03da06(0x37438ef24daf7456ecf5b8f4441c49b925d0c87f7329db6a11853688640f27b7); /* statement */ \nrequire(\r\n            RollupTime.blocksToTicks(challenger.creationTimeBlocks) < deadlineTicks,\r\n            STK2_DEADLINE\r\n        );coverage_0xed03da06(0xd88053e661d799e495b7f4491bc96c297a2a95d75eb11889759ae0873dfa9914); /* assertPost */ \n\r\ncoverage_0xed03da06(0x01585636dd904b6cb8e12bbd9ed94d3b8951a30435a903596e91a946e097ff88); /* line */ \n        coverage_0xed03da06(0x138030998664cd6e4af6be3baf76ef0ab072aa9e8824199514a39b7e6192500e); /* assertPre */ \ncoverage_0xed03da06(0x391b7d6d396e91009013863cfed465d1cdcc1d303c57e32030aa0090a9d9b5ea); /* statement */ \nrequire(!asserter.inChallenge, STK1_IN_CHAL);coverage_0xed03da06(0xe785b9eb50c197ce6a5afa4d82fa6a271ef1a6fd962f6087c070cbdeaa0e961b); /* assertPost */ \n\r\ncoverage_0xed03da06(0x5a91bdb15725f4c2914e7f0e51bce8fab4faac4aca89cefdb0da0b562facdbec); /* line */ \n        coverage_0xed03da06(0xa4c95a719d7a5995dd8011722b28e2b3ef8e6763c24ff8eb8e8f0501a68828a6); /* assertPre */ \ncoverage_0xed03da06(0x0684bb69b0db789b8d6f50136ca46ea0f72a4a39dc1b0b7be2b8e1ebc98f84de); /* statement */ \nrequire(!challenger.inChallenge, STK2_IN_CHAL);coverage_0xed03da06(0xc12c54dd0eb932db86da5bf4601e5573169b54510b1ee6ba84ca8a30a6593d9f); /* assertPost */ \n\r\ncoverage_0xed03da06(0x977bda8be5223fef20d396ec72a51972d2558840acdce3ad0cf9e8590b2d963d); /* line */ \n        coverage_0xed03da06(0xf986f608445a7e211c2ec1cd25bccf90318d87c357fc44525ad6e7d61038ba44); /* assertPre */ \ncoverage_0xed03da06(0x4bda80fdb6d2dbb1369f1cc265945a325a5b5bb3167b08ab04f5cdbb86cf6324); /* statement */ \nrequire(stakerNodeTypes[0] > stakerNodeTypes[1], TYPE_ORDER);coverage_0xed03da06(0x06682ac13c5c85654cc940d9b82f0129d5c1f443aaa5edf62b0bd2ddddb00db9); /* assertPost */ \n\r\ncoverage_0xed03da06(0xede7ff19ff25ac76d34f97e330597cb61edb05b80747981df5fd658efb94390a); /* line */ \n        coverage_0xed03da06(0x06828a3db59b511644622f0c63d3c0db8691eb257d6bed4a044899a230ba4f25); /* assertPre */ \ncoverage_0xed03da06(0x7da675799d22b468b6205a433a7740ed981550c9babcfde74031e3aae571a362); /* statement */ \nrequire(\r\n            RollupUtils.calculateLeafFromPath(\r\n                RollupUtils.childNodeHash(\r\n                    prevNode,\r\n                    deadlineTicks,\r\n                    asserterNodeHash,\r\n                    stakerNodeTypes[0],\r\n                    vmProtoHashes[0]\r\n                ),\r\n                asserterProof\r\n            ) == asserter.location,\r\n            ASSERT_PROOF\r\n        );coverage_0xed03da06(0xa9cf7ff7f49d1392018bc13e33779503e979fb4968d38eca7cba5f297544f6cd); /* assertPost */ \n\r\ncoverage_0xed03da06(0x2d12708ef98559a47f50e3df6adffdd717f16f3cd552317d5a1b7e0c461d8901); /* line */ \n        coverage_0xed03da06(0xc9a5c2f421e76d7d46f08c749e7d2413fbbd35b3b2a88463635bd38def7fa37f); /* assertPre */ \ncoverage_0xed03da06(0xc70b2caa67ae81e08b34cd83fe738c640c6b02b38bc55829e61866af18d5c74d); /* statement */ \nrequire(\r\n            RollupUtils.calculateLeafFromPath(\r\n                RollupUtils.childNodeHash(\r\n                    prevNode,\r\n                    deadlineTicks,\r\n                    RollupUtils.challengeDataHash(challengerDataHash, challengerPeriodTicks),\r\n                    stakerNodeTypes[1],\r\n                    vmProtoHashes[1]\r\n                ),\r\n                challengerProof\r\n            ) == challenger.location,\r\n            CHAL_PROOF\r\n        );coverage_0xed03da06(0x35c117d61865c6ed8ac1bbc7f06c5f32ea1a84c319edf4769c4a07d001e35978); /* assertPost */ \n\r\n\r\ncoverage_0xed03da06(0xb252cd81987aabe0b500646270d296ae9ba074c686ba02fdea53c464eef17eed); /* line */ \n        coverage_0xed03da06(0xdc3909bd1d6e9af3d03dd93890d284b9eaf7f32b7363f7769525ae3ce72a7931); /* statement */ \nasserter.inChallenge = true;\r\ncoverage_0xed03da06(0x984f3e624d35fff3bd3bde6d4d0505b72d863be327b4787647e24359d1991d59); /* line */ \n        coverage_0xed03da06(0xd5c1c3872818ad64632fce19da93dadb3f1c65aa1eccfd57e967ec522a277d91); /* statement */ \nchallenger.inChallenge = true;\r\n\r\ncoverage_0xed03da06(0x15a3be4c28885a4ad310b0fb3f938c8024c786af074f63465e3a4c3503e311de); /* line */ \n        coverage_0xed03da06(0xc99a1fe7c469a306c9a2b5eeaf288c31e9e010e03f8aaa79c5b38c87ff51b401); /* statement */ \ncreateChallenge(\r\n            asserterAddress,\r\n            challengerAddress,\r\n            challengerPeriodTicks,\r\n            challengerDataHash,\r\n            stakerNodeTypes[1]\r\n        );\r\n    }\r\n\r\n    function createChallenge(\r\n        address payable asserterAddress,\r\n        address payable challengerAddress,\r\n        uint128 challengerPeriodTicks,\r\n        bytes32 challengerDataHash,\r\n        uint256 stakerNodeType\r\n    ) internal {coverage_0xed03da06(0x665c7c35244f2a95c6c9670511343b9a4ba1ec458ff3a93dd03efeb624080619); /* function */ \n\r\ncoverage_0xed03da06(0x852176584c325971e860baba83d90c11ca6cb5ffe2a0a2c7566ac6b6a1bb9d56); /* line */ \n        coverage_0xed03da06(0x1c8269e4341f5af8985ef65b548d8ae67152d1fa1b84ff4dc6d7e05fcc0a6670); /* statement */ \naddress newChallengeAddr = challengeFactory.createChallenge(\r\n            asserterAddress,\r\n            challengerAddress,\r\n            challengerPeriodTicks,\r\n            challengerDataHash,\r\n            stakerNodeType\r\n        );\r\n\r\ncoverage_0xed03da06(0xf4200f5db202b5dbf2fdedf46bf33a214415bd30d0a18b23f8960da71bca159d); /* line */ \n        coverage_0xed03da06(0x32d627e44e15e012b34689bf7a19f3a993c9ff431d7507a5ee35618dca341cfd); /* statement */ \nchallenges[newChallengeAddr] = true;\r\n\r\ncoverage_0xed03da06(0x268bff8b03e93d849e5a310c96074298af54a8383b6a8205833507264cc2d025); /* line */ \n        coverage_0xed03da06(0x4ffa82a01570b6da8184160e50d8f7eed1f5e874f721003174405b08e05c313a); /* statement */ \nemit RollupChallengeStarted(\r\n            asserterAddress,\r\n            challengerAddress,\r\n            stakerNodeType,\r\n            newChallengeAddr\r\n        );\r\n    }\r\n\r\n    function init(\r\n        uint128 _stakeRequirement,\r\n        address _stakeToken,\r\n        address _challengeFactoryAddress\r\n    ) internal {coverage_0xed03da06(0xb61eb9ff2d69597f6c893b6abbaff7c9c86d7bb69030478ea63994afab50b7a0); /* function */ \n\r\ncoverage_0xed03da06(0xcbf750fa8daf9bdf00ec40402cc0a858e38a318bd36aaca90c46728805fe0e1c); /* line */ \n        coverage_0xed03da06(0xa8da7a29e6f6722118aab8cc049d5132bab3e4018f230f0a17aa4a9bd1260151); /* assertPre */ \ncoverage_0xed03da06(0xd9082bbcbb38cc632f496b531bf55d88365ae2b20daaa8fe78802a23fb77c8e0); /* statement */ \nrequire(address(challengeFactory) == address(0), INIT_TWICE);coverage_0xed03da06(0xdc0b8dd7aa98d64d079dd98c4c5defaa7d5d544cbb7e2ba1d2c0ea2f3ebaa2ff); /* assertPost */ \n\r\ncoverage_0xed03da06(0xb98dc94309776483188b22b7c4f279f8a8448e354768c9270aee5f37fbdd0365); /* line */ \n        coverage_0xed03da06(0x5607e7f8c73a8206689e1f7a9e3ab1b0887373df43ae1a222095dc4bb8250e86); /* assertPre */ \ncoverage_0xed03da06(0xae6df6b3b81f712c53bbe4faaa8800c29dfe278886d4c5eb1ae8f766a6cef0e2); /* statement */ \nrequire(_challengeFactoryAddress != address(0), INIT_NONZERO);coverage_0xed03da06(0xc304a83ecdfe4c006a9039fe693e0c97a4f86deae23ea97ba66ce348516ed80f); /* assertPost */ \n\r\n\r\ncoverage_0xed03da06(0x471c4a271eefeda4870327a5b8dd0c19ce73201fda4901a9c21c99bcfd7e1057); /* line */ \n        coverage_0xed03da06(0x347908f9a1d32c90b9f094ea1fb56a4c79aad7e73cac8e48fbecf332b21a4128); /* statement */ \nchallengeFactory = IChallengeFactory(_challengeFactoryAddress);\r\n\r\n        // VM parameters\r\ncoverage_0xed03da06(0x66bbd106ddc1d994760c7cb721efe09d4597bfebf20633337047e4f8e54ddf3b); /* line */ \n        coverage_0xed03da06(0x7107b2e3af4104fd0bada31ca860ce4670bb90823909b6a673ade9ef8aa0d782); /* statement */ \nstakeRequirement = _stakeRequirement;\r\ncoverage_0xed03da06(0x0bd11024a2a64471ef345dc0184bb9605322a7f363fdb1a43782dc4b345a467e); /* line */ \n        coverage_0xed03da06(0x1e64f3074436d5af9009a76cf6bd4e5c87849a10ebad28224abd17156970710f); /* statement */ \nstakeToken = _stakeToken;\r\n    }\r\n\r\n    function getStakerLocation(address _stakerAddress) internal view returns (bytes32) {coverage_0xed03da06(0xa3944e8e6d76d62dc2249a69b20a07066ca47094e9b1e7ab4e78aa20ce51e92a); /* function */ \n\r\ncoverage_0xed03da06(0x4c5af23a1b70d26c14eee3ae2c989ac61d2b7ac8a2d522907af450bd641552fd); /* line */ \n        coverage_0xed03da06(0x1667b1521cbdc5fcd54835d4e97c249f58e11e164a06e82e477242da2f4b741f); /* statement */ \nbytes32 location = stakers[_stakerAddress].location;\r\ncoverage_0xed03da06(0x86bb7f9bf135a15ffa7e9607b68f9122de5d3473b57783539f5fd36042aee0d1); /* line */ \n        coverage_0xed03da06(0x2c01f8b3f851671713772eb651795dd114db81ee9114602fa30be677f0cc9cd8); /* assertPre */ \ncoverage_0xed03da06(0x796fca3af2fdd5e3942e1a1425898b79931f1f9322a7d79890fa99b3becb8e4f); /* statement */ \nrequire(location != 0x00, INV_STAKER);coverage_0xed03da06(0x3194b19c054e0ba2c579ba747fc918de6164a0aed14c5aba593495cee5e1a05d); /* assertPost */ \n\r\ncoverage_0xed03da06(0x5051d27b29ac4074b389cf13665eced9d10c817f5d8302734c9e3aad6ddd8fff); /* line */ \n        coverage_0xed03da06(0x5e11986ee831944f6342b1b13764f2fd7388fd83ce94fc3d47f7f30db20ef0e8); /* statement */ \nreturn location;\r\n    }\r\n\r\n    function createStake(bytes32 location) internal {coverage_0xed03da06(0xc76ddb4bb20850ce0b8333714a13196b33012eb1967a0eb5a207e29d2c109e06); /* function */ \n\r\ncoverage_0xed03da06(0x63a037d428714303563a9863433f54eb6e76b8b4d520bfc81ba6f4376bbcf02c); /* line */ \n        coverage_0xed03da06(0x0d02d1d2c5c985ea706d08e95f0db7897ac4f22271ce555515412d75c25cecc9); /* statement */ \nif (stakeToken == address(0)) {coverage_0xed03da06(0x650ed2fca96c57366eef4ca3a7bfe482b5bb1dd9fe48faf30df3074a47429b2c); /* branch */ \n\r\ncoverage_0xed03da06(0x27a613151f58b5e0482764653106afc7136dfa8de8490a87902dc14889a223df); /* line */ \n            coverage_0xed03da06(0x5db80949f8aac77ccc453319466df3feafa6191cff2a62e3d97780460f85176d); /* assertPre */ \ncoverage_0xed03da06(0x29f6acffb1d776336ed0ca15bc905e49da3368dd7198e5b95643214b3814d2b2); /* statement */ \nrequire(msg.value == stakeRequirement, STK_AMT);coverage_0xed03da06(0x35a0b8dfd5ec2340ce9f475c402917cbd73082f1fcf0841a5170ecb404671572); /* assertPost */ \n\r\n        } else {coverage_0xed03da06(0x2307c10096ce47a75d6b728864f2c5f7fba9c72f00c147faa1e29573110ce6ce); /* branch */ \n\r\ncoverage_0xed03da06(0xa016cee25854db688f59f3a33e82b22ed9128b203b9c9d4dcd4a1ff17971fc1a); /* line */ \n            coverage_0xed03da06(0x0d1bbdc2e51f74da9ab17117f50fb1f2a7a39e6103a614c0b323a4bea22e54b7); /* assertPre */ \ncoverage_0xed03da06(0xf4f977709d27d492f987e410360d163cb8cb027a11ab280669de5d16912b98ef); /* statement */ \nrequire(msg.value == 0, STK_AMT);coverage_0xed03da06(0x1a70aa4dff9a884021a33aa41628c760a0c6675cddd5d062642b6ab059a117ab); /* assertPost */ \n\r\ncoverage_0xed03da06(0xff71550af9c86100b4728bd9de620ff3b84e5fd22d42cf73d4bd97431f79a144); /* line */ \n            coverage_0xed03da06(0xb67d40263e8f94d33402321577ad3b022dac68d582ac3b964bd4d729cc59c6ea); /* assertPre */ \ncoverage_0xed03da06(0xe50ac4bddd9ff4e272f6872edddd570cce5195151139e72f5b16bceba930ac37); /* statement */ \nrequire(\r\n                IERC20(stakeToken).transferFrom(msg.sender, address(this), stakeRequirement),\r\n                TRANSFER_FAILED\r\n            );coverage_0xed03da06(0xee2927aa7b78e14edf48eef40749eb7b86dba8b9309fc493a0f8e902ab0a56b8); /* assertPost */ \n\r\n        }\r\n\r\ncoverage_0xed03da06(0xd67fd40348f99e874f99e9486c0c21e57a244e1cc8b832cb425038cc314945b1); /* line */ \n        coverage_0xed03da06(0xd5ede4923f63e71656ce53747c2f02e0f1ba04612629666a0018ede4b73b02e0); /* assertPre */ \ncoverage_0xed03da06(0xd887e60772c9b4ba5b9e63d8f9662a86e1d04c7d7842975384b0198e64bd548d); /* statement */ \nrequire(stakers[msg.sender].location == 0x00, ALRDY_STAKED);coverage_0xed03da06(0xfe4f5325e304904e995a3d57ca5cd94445a462f28bfcd7a858f60bdb318889dc); /* assertPost */ \n\r\ncoverage_0xed03da06(0xf3caa492e17a8e2c3725f99a09f012509de5a692dbb9a554ce242ddf5e417deb); /* line */ \n        coverage_0xed03da06(0xf67d809cb41963586bbd9e33fe6c49ed290e214d1a53351b6e22e5d06780a9bb); /* statement */ \nstakers[msg.sender] = Staker(location, uint128(block.number), false);\r\ncoverage_0xed03da06(0x8ab9901e52090f41dc8c6201cd33d1c9c756596a7f8a3e27cf024e426b457cf0); /* line */ \n        stakerCount++;\r\n\r\ncoverage_0xed03da06(0x65914a790dac9e9d359a4cbc36242d183962ff27f2a56937bf8fcba711e56480); /* line */ \n        coverage_0xed03da06(0xb8095da277e2bf9c54f71e19728bb7e74ed19fd7a0da839df952161fef31b26a); /* statement */ \nemit RollupStakeCreated(msg.sender, location);\r\n    }\r\n\r\n    function updateStakerLocation(address _stakerAddress, bytes32 _location) internal {coverage_0xed03da06(0x0661978b663ac04ae82f721c3bc104400c474590db8b86a786023386cf1d0ccf); /* function */ \n\r\ncoverage_0xed03da06(0x4f4e985c1f1f7cf408acd12d74e78b86886b355fca7905652b8a6f311cc517ce); /* line */ \n        coverage_0xed03da06(0x7a5a4c538dd4256366836f6bcd6fb23bd58f3f366bf2f4c56151dbd065fc9aa4); /* statement */ \nstakers[_stakerAddress].location = _location;\r\ncoverage_0xed03da06(0xb7fe40b4e8eb916d6abfd339ddc9c173e0bf22872a4b82ba7d5bcb9e6100e8aa); /* line */ \n        coverage_0xed03da06(0xbee4f9d6a938cb99cb89e0a316766482ae070cab20345a183360bc516cc40ec3); /* statement */ \nemit RollupStakeMoved(_stakerAddress, _location);\r\n    }\r\n\r\n    function refundStaker(address payable _stakerAddress) internal {coverage_0xed03da06(0x2c71730c01f5070408354dda2d91e540ee9ba704ef9b8fc57833a93fff1e4a49); /* function */ \n\r\ncoverage_0xed03da06(0x4dc2846ed4235fccb7b135e27d73aa814874909c79fef0e76a14c9e9dce0aebe); /* line */ \n        coverage_0xed03da06(0x9ff637efcd06b15e7ffbca90c44085c07a429e3578313187551f93fc5890e203); /* statement */ \ndeleteStaker(_stakerAddress);\r\ncoverage_0xed03da06(0xbcdc8b195433d935d880ccc46d8e21fd6bcae5be8efbd94495e30a55a5e38226); /* line */ \n        coverage_0xed03da06(0xcda5f06e228e42b3061acb3524b15551316f163b53af0be51140ae0b41d75499); /* statement */ \nwithdrawnStakes[_stakerAddress] += stakeRequirement;\r\n\r\ncoverage_0xed03da06(0x833d974879a2e28e93d24f6e826fcb363e5fa898d3629cd7511c63fc14ba3b3f); /* line */ \n        coverage_0xed03da06(0x1eade6c03fe7acd144e8c0c7df7a07cef83c86267f0a1657bc1ea0b7201d73ae); /* statement */ \nemit RollupStakeRefunded(address(_stakerAddress));\r\n    }\r\n\r\n    function getValidStaker(address _stakerAddress) private view returns (Staker storage) {coverage_0xed03da06(0x35a4a23f2063aa3baf84b74f8fe7a789d4fb9ad8ff4606e44c22b8d03d0d66f3); /* function */ \n\r\ncoverage_0xed03da06(0x6392c19569e7bae9a9cbaad7d144acfdc3f14fcd3e2bebbe9303c29a651fa3d5); /* line */ \n        coverage_0xed03da06(0x2daf9afe32ebf52a26ad0c41a311d3e660bc6a23857ffa36ee8423302b809da9); /* statement */ \nStaker storage staker = stakers[_stakerAddress];\r\ncoverage_0xed03da06(0x02d16884d1532859372a79b7dce68c2e27c4fb0c8c9437da2606f99052994e76); /* line */ \n        coverage_0xed03da06(0xed016550659b6e5c99afa808cdec5c20a05e76b97ce2284b7bccd48d6ac1a5a8); /* assertPre */ \ncoverage_0xed03da06(0xd5538f3a8385de75fad23edb61e02363ea96ea32bf13b8c776f0102a936f08fc); /* statement */ \nrequire(staker.location != 0x00, INV_STAKER);coverage_0xed03da06(0xaede75c60bd440cd68a3cb071f28cb4cf1554aeeab7f973ea259e115520d418f); /* assertPost */ \n\r\ncoverage_0xed03da06(0xbbf68f2cd8a328d93323db4633f47b393aaae59cd26addf12adb52899677aac8); /* line */ \n        coverage_0xed03da06(0xa15d5e5da3a88faf269051ee0376540d3cef6dd57374fd0c97a36f28f77e9d4a); /* statement */ \nreturn staker;\r\n    }\r\n\r\n    function deleteStaker(address _stakerAddress) private {coverage_0xed03da06(0x74f3688d09893d803ec018f59a20e66b4db8c545b281735e2b05c49a89d4b0e9); /* function */ \n\r\ncoverage_0xed03da06(0x2295c32e80f058ce1fd9f6eab6d433198643c8dcafae9da574bccb8c9162c84e); /* line */ \n        delete stakers[_stakerAddress];\r\ncoverage_0xed03da06(0x60114cfb92b4d5e2a579882c76fee19dae1843254a753babe7be71e8e164a33a); /* line */ \n        stakerCount--;\r\n    }\r\n\r\n    function checkAlignedStakers(\r\n        bytes32 node,\r\n        uint256 deadlineTicks,\r\n        address[] memory stakerAddresses,\r\n        bytes32[] memory stakerProofs,\r\n        uint256[] memory stakerProofOffsets\r\n    ) internal view returns (uint256) {coverage_0xed03da06(0xbb1cdaca0442b3b01896cb35ed0cf43826ab8b37b7f8f10a191eb8d21ba91a8e); /* function */ \n\r\ncoverage_0xed03da06(0x538d56ec33aac574b83d034da312e6d66fdb65a60d6baad28362a884f951d533); /* line */ \n        coverage_0xed03da06(0x5ff8ea6e761b612c80e5c1d20aaf5806519d957616a306db5737117a39cbb2a5); /* statement */ \nuint256 _stakerCount = stakerAddresses.length;\r\ncoverage_0xed03da06(0x5ac6014f521b5ceaa818bc1b94c38efeef1b4a5b33dcba841cc743896c8c7dff); /* line */ \n        coverage_0xed03da06(0x4839b4ebf315b7ebbd8ced55f75cf8c4cb8e54cbca4af5f001e2ad060617ae7c); /* assertPre */ \ncoverage_0xed03da06(0x1a95541409eccd13720e1e27528f47f60a9d77bffc898403dd32fbc156bff8cf); /* statement */ \nrequire(_stakerCount == stakerCount, CHCK_COUNT);coverage_0xed03da06(0x76cba09644d076a9c2f194fe819bd871b7ca9a359844b3a34f2f605df6f5587c); /* assertPost */ \n\r\ncoverage_0xed03da06(0xdb5e9a3bc243b06d6d33e88657ede516a6b981d64ce516ed93e11be659994bc8); /* line */ \n        coverage_0xed03da06(0xfb532b7bb8ddd070307dabb4ff7b931f4a54b6eae5e35a581414708e866891c1); /* assertPre */ \ncoverage_0xed03da06(0x9aee34574074ba0b8eea825576f8567471e6b0371a66190f1d484c5106b2efe2); /* statement */ \nrequire(_stakerCount + 1 == stakerProofOffsets.length, CHCK_OFFSETS);coverage_0xed03da06(0x4edb0d0b2143ea2336ff9496564f85d272090c381ef4f752c876afb8db1ce474); /* assertPost */ \n\r\n\r\ncoverage_0xed03da06(0x4207a709d32a7d8b7cbf3a63cd772c410a6f3256ca73a0955f0d47368d0cd446); /* line */ \n        coverage_0xed03da06(0x8393b197d133b1917143a5d3169665e0045e20ce3b76bc09dba84d63fe085ab5); /* statement */ \nbytes20 prevStaker = 0x00;\r\ncoverage_0xed03da06(0x375024ad6cbfe8a8ca5bbfec162d3d148de5e610d374607af21548f13ead389d); /* line */ \n        coverage_0xed03da06(0x2f419b3f6e8701e6cc71c393cdf4c2d05b64036dd65868718d5ee9e59513aeec); /* statement */ \nuint256 activeCount = 0;\r\ncoverage_0xed03da06(0xfc3f3eda71235557ecae9777417d715efb3cdbabb7a397d18bd00dd2a8b06080); /* line */ \n        coverage_0xed03da06(0x7cfc38fd8bba0c6952a4f8d2f2db985febba43ef7c7facb9210bbdb8896bc583); /* statement */ \nbool isActive = false;\r\n\r\ncoverage_0xed03da06(0x22e0e0112afa8fb8f227ec6067f39c079ad4abb7049652485b3014b0e49723a1); /* line */ \n        coverage_0xed03da06(0x74662dfbe6b6b5f8cd0b3d4700a7bfe980c267b3d321c92e4c94d9f1b9719a29); /* statement */ \nfor (uint256 index = 0; index < _stakerCount; index++) {\r\ncoverage_0xed03da06(0x61882a0219cf0359b48ace3fed64dd94db7cbdae16208b4e265a5296ea812848); /* line */ \n            coverage_0xed03da06(0x3e23eb29021a60440e8505c195ddc1644d65d8862d65ae96176a5062272f7281); /* statement */ \naddress currentStaker = stakerAddresses[index];\r\n\r\ncoverage_0xed03da06(0xb2f5c7772412f0ab299e3ed5f3afbb4f34ba674f71ea887974051b7695263d61); /* line */ \n            coverage_0xed03da06(0xe0ca672affec913f68f86b557928cc6dd769616aab636d2eb195054f6f2fe850); /* statement */ \nisActive = _verifyAlignedStaker(\r\n                node,\r\n                stakerProofs,\r\n                deadlineTicks,\r\n                currentStaker,\r\n                prevStaker,\r\n                stakerProofOffsets[index],\r\n                stakerProofOffsets[index + 1]\r\n            );\r\n\r\ncoverage_0xed03da06(0x95183200d78463d3b9a404cc165a2bfd6f8a6062427fab078ccb9568924d6110); /* line */ \n            coverage_0xed03da06(0x954922f5a85e7f7d49cf40c13f59b77ee4b390886d3a272c756f87f622666e9c); /* statement */ \nif (isActive) {coverage_0xed03da06(0x42ac6c84fdbaa6383886ca143033696dd13d9e1f61c8c372d8f672ccc4aa214e); /* branch */ \n\r\ncoverage_0xed03da06(0xae26b466ea3b7517468a575fe75c0f427f066da1ff15c72d65bcc52ed1e7a1d0); /* line */ \n                activeCount++;\r\n            }else { coverage_0xed03da06(0xf9e1ad10ea44b6efa676356e76cff204e87f83660a1e2b214a83e993986bd252); /* branch */ \n}\r\n\r\ncoverage_0xed03da06(0xdd7dea38c607313785c54155ca0cf48eef4e0519be2cb27303ea1e883596f643); /* line */ \n            coverage_0xed03da06(0xb9ad65ace05d9f8e97fc4caf254190a83ab15d0a2d902f3e82971e493f2f2db1); /* statement */ \nprevStaker = bytes20(currentStaker);\r\n        }\r\ncoverage_0xed03da06(0x42c88ad1866ffb6e569f862fc611834664e04b1c551b6c9ec38f95635f180a0b); /* line */ \n        coverage_0xed03da06(0x0acbb2bfc437c72a757013088c14c190f24f9b37a8d56eaafcf69badc7d5e1ef); /* statement */ \nreturn activeCount;\r\n    }\r\n\r\n    function _verifyAlignedStaker(\r\n        bytes32 node,\r\n        bytes32[] memory stakerProofs,\r\n        uint256 deadlineTicks,\r\n        address stakerAddress,\r\n        bytes20 prevStaker,\r\n        uint256 proofStart,\r\n        uint256 proofEnd\r\n    ) private view returns (bool) {coverage_0xed03da06(0x58c99160d2eea2eecfb8a65c96c48b9a487a0fe30d867451fbdb0fd4aa9022ce); /* function */ \n\r\ncoverage_0xed03da06(0xae5dcc99aae0547820dab0187216e1fed68e8d4d189fa9cada4583b1c454627b); /* line */ \n        coverage_0xed03da06(0xd51aefed06ca172b6458ba9877e7efe7ea172001c58801a31f8d43e1ba13ceb7); /* assertPre */ \ncoverage_0xed03da06(0xf99bdda7f94fd89c4a4c4a8426f69f87bdbfe695726971c6bb0f8ab04dbfcfca); /* statement */ \nrequire(bytes20(stakerAddress) > prevStaker, CHCK_ORDER);coverage_0xed03da06(0x306e4896580225896799520c28a720acdd16b369e9c602ba35c897ee69ba6942); /* assertPost */ \n\r\ncoverage_0xed03da06(0x8e56b1216e3043dd8d5866da4e28779bd0cd1e9184d0473aee0a0549383d030f); /* line */ \n        coverage_0xed03da06(0x9e1ff97584d04f16778eb619aa75d082546b3410e6887ac3b00d4b6ee5d0b843); /* statement */ \nStaker storage staker = getValidStaker(stakerAddress);\r\ncoverage_0xed03da06(0x0967d141896149ccf6b9c6b8ab82073da3d3afc4e49fc2edfebf197babf1fbd8); /* line */ \n        coverage_0xed03da06(0xcb873071276ccd18c48f5c173e2c1bb329dcf341e97e5ae7f4517514d2ae4a22); /* statement */ \nbool isActive = RollupTime.blocksToTicks(staker.creationTimeBlocks) < deadlineTicks;\r\n\r\ncoverage_0xed03da06(0x2a91c911da85b2078dd249d524daab820d090ead6447d5abd16cde10f6b36ad4); /* line */ \n        coverage_0xed03da06(0xe6940ad4c8e964ff403b1b91655cb5989e56fedc70467d4896568e5e688d4083); /* statement */ \nif (isActive) {coverage_0xed03da06(0x0f0ba21b2eecad4d692919141b276f5dcb6e59bf33cc4ddbf898c097fd00ec1d); /* branch */ \n\r\ncoverage_0xed03da06(0xf55551a2fcc340c349ffde127c04759350c1e2dde81e08985071ea91c305bb0a); /* line */ \n            coverage_0xed03da06(0x8e204fb16959c1928f94a85bf6da13c0b6a10fe4a5f09e808b4e204a785a58ad); /* assertPre */ \ncoverage_0xed03da06(0xa0cef8f39d05d88a202320c81297ee330b0685a5f2552429368b3f753b56707d); /* statement */ \nrequire(\r\n                RollupUtils.calculateLeafFromPath(node, stakerProofs, proofStart, proofEnd) ==\r\n                    staker.location,\r\n                CHCK_STAKER_PROOF\r\n            );coverage_0xed03da06(0xa178715403a77dbb97aeb32f1e32750d0fce8971fc0684ac1215f9e2cf3014c2); /* assertPost */ \n\r\n        }else { coverage_0xed03da06(0x76bde3103d82afb07209329ddd2c035d6827eb71f896b498222b6ec18f906d3e); /* branch */ \n}\r\n\r\ncoverage_0xed03da06(0xc6429b24051a42bddae0b47995a92484eaa6dce569dc9606158d2bb096398483); /* line */ \n        coverage_0xed03da06(0x477ca2e9f9837f36f95c33a692c4ef45a8d3f3ef8e82da4c63ee07743ad4b518); /* statement */ \nreturn isActive;\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/test_only/BuddyERC20.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"arbos-contracts/contracts/ArbERC20.sol\";\r\nimport \"../inbox/IGlobalInbox.sol\";\r\nimport \"../interfaces/IPairedErc20.sol\";\r\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\r\n\r\ncontract BaseDetails is ERC20Detailed {\r\n    constructor() public ERC20Detailed(\"Token Buddy\", \"TB\", 18) {}\r\n}\r\n\r\ncontract ArbBuddyERC20 is ArbERC20, BaseDetails {}\r\n\r\ncontract EthBuddyERC20 is IPairedErc20, Ownable, ERC20, BaseDetails {\r\n    address public inbox;\r\n\r\n    constructor(address _globalInbox) public {\r\n        inbox = _globalInbox;\r\n        _mint(msg.sender, 1000000000000);\r\n    }\r\n\r\n    function connectToChain(address _chain) public onlyOwner {\r\n        IGlobalInbox inboxCon = IGlobalInbox(inbox);\r\n        inboxCon.deployL2ContractPair(_chain, 10000000000, 0, 0, type(ArbERC20).creationCode);\r\n    }\r\n\r\n    function mint(address account, uint256 amount) public {\r\n        require(inbox == msg.sender, \"only callable by global inbox\");\r\n        _mint(account, amount);\r\n    }\r\n\r\n    function burn(address account, uint256 amount) public {\r\n        require(inbox == msg.sender, \"only callable by global inbox\");\r\n        _burn(account, amount);\r\n    }\r\n}\r\n"
    },
    "arbos-contracts/contracts/ArbERC20.sol": {
      "content": "/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\nimport \"./ArbSys.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract ArbERC20 is ERC20 {\r\n    function adminMint(address account, uint256 amount) public {\r\n        // This function is only callable through admin logic since address 1 cannot make calls\r\n        require(msg.sender == address(1));\r\n        _mint(account, amount);\r\n    }\r\n\r\n    function withdraw(address account, uint256 amount) public {\r\n        _burn(msg.sender, amount);\r\n        ArbSys(100).withdrawERC20(account, amount);\r\n    }\r\n}\r\n"
    },
    "arbos-contracts/contracts/ArbSys.sol": {
      "content": "/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\ninterface ArbSys {\r\n    // Send given amount of ERC-20 tokens to dest with token contract sender.\r\n    // This is safe to freely call since the sender is authenticated and thus\r\n    // you can only send fake tokens, not steal real ones\r\n    function withdrawERC20(address dest, uint256 amount) external;\r\n\r\n    // Send given ERC-721 token to dest with token contract sender.\r\n    // This is safe by the above arguement\r\n    function withdrawERC721(address dest, uint256 id) external;\r\n\r\n    // Send given amount of Eth to dest with from sender.\r\n    function withdrawEth(address dest) external payable;\r\n\r\n    // Return the number of transactions issued by the given external account\r\n    // or the account sequence number of the given contract\r\n    function getTransactionCount(address account) external view returns (uint256);\r\n\r\n    // Return the value of the storage slot for the given account at the given index\r\n    // This function is only callable from address 0 to prevent contracts from being\r\n    // able to call it\r\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\r\n\r\n    // Register an address in the address table\r\n    // Return index of the address (existing index, or newly created index if not already registered)\r\n    function addressTable_register(address addr) external returns (uint256);\r\n\r\n    // Return index of an address in the address table (revert if address isn't in the table)\r\n    function addressTable_lookup(address addr) external view returns (uint256);\r\n\r\n    // Check whether an address exists in the address table\r\n    function addressTable_addressExists(address addr) external view returns (bool);\r\n\r\n    // Get size of address table (= first unused index)\r\n    function addressTable_size() external view returns (uint256);\r\n\r\n    // Return address at a given index in address table (revert if index is beyond end of table)\r\n    function addressTable_lookupIndex(uint256 index) external view returns (address);\r\n\r\n    // Read a compressed address from a bytes buffer\r\n    // Return resulting address and updated offset into the buffer (revert if buffer is too short)\r\n    function addressTable_decompress(bytes calldata buf, uint256 offset)\r\n        external\r\n        view\r\n        returns (address, uint256);\r\n\r\n    // Compress an address and return the result\r\n    function addressTable_compress(address addr) external view returns (bytes memory);\r\n\r\n    // Associate a BLS public key with the caller's address\r\n    function registerBlsKey(\r\n        uint256 x0,\r\n        uint256 x1,\r\n        uint256 y0,\r\n        uint256 y1\r\n    ) external;\r\n\r\n    // Get the BLS public key associated with an address (revert if there isn't one)\r\n    function getBlsPublicKey(address addr)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    // Upload a serialized function table and associate it with the caller's address\r\n    // If caller already had a function table, this will overwrite the old one\r\n    // Revert if buf is mal-formatted\r\n    // (Caller will typically be an aggregator)\r\n    function uploadFunctionTable(bytes calldata buf) external;\r\n\r\n    // Get the size of addr's function table; revert if addr doesn't have a function table\r\n    function functionTableSize(address addr) external view returns (uint256);\r\n\r\n    // Get the entry from addr's function table, at index; revert if addr has no table or index out of bounds\r\n    // Returns (functionCode, isPayable, gasLimit)\r\n    function functionTableGet(address addr, uint256 index)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            bool,\r\n            uint256\r\n        );\r\n\r\n    event EthWithdrawal(address indexed destAddr, uint256 amount);\r\n    event ERC20Withdrawal(address indexed destAddr, address indexed tokenAddr, uint256 amount);\r\n    event ERC721Withdrawal(address indexed destAddr, address indexed tokenAddr, uint256 indexed id);\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    ".coverage_contracts/test_only/ChallengeTester.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../challenge/IChallengeFactory.sol\";\r\nimport \"../rollup/IStaking.sol\";\r\n\r\ncontract ChallengeTester is IStaking {\r\n    IChallengeFactory private challengeFactory;\r\n\r\n    constructor(address challengeFactory_) public {\r\n        challengeFactory = IChallengeFactory(challengeFactory_);\r\n    }\r\n\r\n    function resolveChallenge(address payable, address) external {\r\n        return;\r\n    }\r\n\r\n    function startChallenge(\r\n        address payable asserterAddress,\r\n        address payable challengerAddress,\r\n        uint128 challengerPeriodTicks,\r\n        bytes32 challengerDataHash,\r\n        uint256 challengeType\r\n    ) public {\r\n        challengeFactory.createChallenge(\r\n            asserterAddress,\r\n            challengerAddress,\r\n            challengerPeriodTicks,\r\n            challengerDataHash,\r\n            challengeType\r\n        );\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/test_only/MachineTester.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2012, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../arch/Machine.sol\";\r\nimport \"../arch/Marshaling.sol\";\r\nimport \"../arch/Value.sol\";\r\n\r\ncontract MachineTester {\r\n    using Hashing for Value.Data;\r\n    using Machine for Machine.Data;\r\n\r\n    function deserializeMachine(bytes memory data) public pure returns (uint256, bytes32) {\r\n        uint256 offset;\r\n        Machine.Data memory machine;\r\n        (offset, machine) = Machine.deserializeMachine(data, 0);\r\n        return (offset, machine.hash());\r\n    }\r\n\r\n    function addStackVal(bytes memory data1, bytes memory data2) public pure returns (bytes32) {\r\n        uint256 offset;\r\n        Value.Data memory val1;\r\n        Value.Data memory val2;\r\n\r\n        (offset, val1) = Marshaling.deserialize(data1, 0);\r\n\r\n        (offset, val2) = Marshaling.deserialize(data2, 0);\r\n\r\n        return Machine.addStackVal(val1, val2).hash();\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/test_only/MessageTester.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../inbox/Messages.sol\";\r\n\r\ncontract MessageTester {\r\n    using Hashing for Value.Data;\r\n\r\n    function messageHash(\r\n        uint8 messageType,\r\n        address sender,\r\n        uint256 blockNumber,\r\n        uint256 timestamp,\r\n        uint256 inboxSeqNum,\r\n        bytes32 messageDataHash\r\n    ) public pure returns (bytes32) {\r\n        return\r\n            Messages.messageHash(\r\n                messageType,\r\n                sender,\r\n                blockNumber,\r\n                timestamp,\r\n                inboxSeqNum,\r\n                messageDataHash\r\n            );\r\n    }\r\n\r\n    function messageValueHash(\r\n        uint8 messageType,\r\n        uint256 blockNumber,\r\n        uint256 timestamp,\r\n        address sender,\r\n        uint256 inboxSeqNum,\r\n        bytes memory messageData\r\n    ) public pure returns (bytes32) {\r\n        return\r\n            Messages\r\n                .messageValue(messageType, blockNumber, timestamp, sender, inboxSeqNum, messageData)\r\n                .hash();\r\n    }\r\n\r\n    function addMessageToInbox(bytes32 inbox, bytes32 message) public pure returns (bytes32) {\r\n        return Messages.addMessageToInbox(inbox, message);\r\n    }\r\n\r\n    function unmarshalOutgoingMessage(bytes memory data, uint256 startOffset)\r\n        public\r\n        pure\r\n        returns (\r\n            bool, // valid\r\n            uint256, // offset\r\n            uint8, // kind\r\n            address, // sender\r\n            bytes memory // data\r\n        )\r\n    {\r\n        (bool valid, uint256 offset, Messages.OutgoingMessage memory message) = Messages\r\n            .unmarshalOutgoingMessage(data, startOffset);\r\n        return (valid, offset, message.kind, message.sender, message.data);\r\n    }\r\n\r\n    function parseEthMessage(bytes memory data)\r\n        public\r\n        pure\r\n        returns (\r\n            bool valid,\r\n            address dest,\r\n            uint256 value\r\n        )\r\n    {\r\n        (bool isValid, Messages.EthMessage memory message) = Messages.parseEthMessage(data);\r\n        return (isValid, message.dest, message.value);\r\n    }\r\n\r\n    function parseERC20Message(bytes memory data)\r\n        public\r\n        pure\r\n        returns (\r\n            bool valid,\r\n            address token,\r\n            address dest,\r\n            uint256 value\r\n        )\r\n    {\r\n        (bool isValid, Messages.ERC20Message memory message) = Messages.parseERC20Message(data);\r\n        return (isValid, message.token, message.dest, message.value);\r\n    }\r\n\r\n    function parseERC721Message(bytes memory data)\r\n        public\r\n        pure\r\n        returns (\r\n            bool valid,\r\n            address token,\r\n            address dest,\r\n            uint256 id\r\n        )\r\n    {\r\n        (bool isValid, Messages.ERC721Message memory message) = Messages.parseERC721Message(data);\r\n        return (isValid, message.token, message.dest, message.id);\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/test_only/OneStepProofTester.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2019-2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../arch/OneStepProof.sol\";\r\n\r\ncontract OneStepProofTester is OneStepProof {\r\n    event OneStepProofTestEvent();\r\n\r\n    function executeStepTest(\r\n        bytes32 inboxAcc,\r\n        bytes32 messagesAcc,\r\n        bytes32 logsAcc,\r\n        bytes calldata proof\r\n    ) external {\r\n        AssertionContext memory context = initializeExecutionContext(\r\n            inboxAcc,\r\n            messagesAcc,\r\n            logsAcc,\r\n            proof\r\n        );\r\n\r\n        executeOp(context);\r\n        emit OneStepProofTestEvent();\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/test_only/PrecompilesTester.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../libraries/Precompiles.sol\";\r\n\r\nlibrary PrecompilesTester {\r\n    function keccakF(uint256[25] memory input) public pure returns (uint256[25] memory) {\r\n        return Precompiles.keccakF(input);\r\n    }\r\n\r\n    function sha256Block(uint256[2] memory inputChunk, uint256 hashState)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return Precompiles.sha256Block(inputChunk, hashState);\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/test_only/RollupTester.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../rollup/RollupUtils.sol\";\r\nimport \"../rollup/NodeGraphUtils.sol\";\r\n\r\ncontract RollupTester {\r\n    function confirm(\r\n        bytes32 confNode,\r\n        bytes32 initalProtoStateHash,\r\n        uint256 beforeSendCount,\r\n        uint256[] memory branches,\r\n        uint256[] memory deadlineTicks,\r\n        bytes32[] memory challengeNodeData,\r\n        bytes32[] memory logsAcc,\r\n        bytes32[] memory vmProtoStateHashes,\r\n        uint256[] memory messageCounts,\r\n        bytes memory messages\r\n    )\r\n        public\r\n        pure\r\n        returns (\r\n            bytes32[] memory validNodeHashes,\r\n            bytes32 vmProtoStateHash,\r\n            bytes32 lastNodeHash\r\n        )\r\n    {\r\n        RollupUtils.NodeData memory finalNodeData;\r\n        (validNodeHashes, finalNodeData) = RollupUtils.confirm(\r\n            RollupUtils.ConfirmData(\r\n                initalProtoStateHash,\r\n                beforeSendCount,\r\n                branches,\r\n                deadlineTicks,\r\n                challengeNodeData,\r\n                logsAcc,\r\n                vmProtoStateHashes,\r\n                messageCounts,\r\n                messages\r\n            ),\r\n            confNode\r\n        );\r\n        return (validNodeHashes, finalNodeData.vmProtoStateHash, finalNodeData.nodeHash);\r\n    }\r\n\r\n    function generateLastMessageHash(\r\n        bytes memory messages,\r\n        uint256 startOffset,\r\n        uint256 length\r\n    ) public pure returns (bytes32, uint256) {\r\n        return RollupUtils.generateLastMessageHash(messages, startOffset, length);\r\n    }\r\n\r\n    function processValidNode(\r\n        bytes32[] memory logsAcc,\r\n        bytes32[] memory vmProtoStateHashes,\r\n        uint256[] memory messageCounts,\r\n        bytes memory messages,\r\n        uint256 validNum,\r\n        uint256 beforeSendCount,\r\n        uint256 startOffset\r\n    )\r\n        public\r\n        pure\r\n        returns (\r\n            uint256 afterSendCount,\r\n            uint256 afterOffset,\r\n            bytes32 nodeDataHash,\r\n            bytes32 vmProtoStateHash\r\n        )\r\n    {\r\n        return\r\n            RollupUtils.processValidNode(\r\n                RollupUtils.ConfirmData(\r\n                    0,\r\n                    0,\r\n                    new uint256[](0),\r\n                    new uint256[](0),\r\n                    new bytes32[](0),\r\n                    logsAcc,\r\n                    vmProtoStateHashes,\r\n                    messageCounts,\r\n                    messages\r\n                ),\r\n                validNum,\r\n                beforeSendCount,\r\n                startOffset\r\n            );\r\n    }\r\n\r\n    function calculateLeafFromPath(bytes32 from, bytes32[] memory proof)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return RollupUtils.calculateLeafFromPath(from, proof);\r\n    }\r\n\r\n    function childNodeHash(\r\n        bytes32 prevNodeHash,\r\n        uint256 deadlineTicks,\r\n        bytes32 nodeDataHash,\r\n        uint256 childType,\r\n        bytes32 vmProtoStateHash\r\n    ) public pure returns (bytes32) {\r\n        return\r\n            RollupUtils.childNodeHash(\r\n                prevNodeHash,\r\n                deadlineTicks,\r\n                nodeDataHash,\r\n                childType,\r\n                vmProtoStateHash\r\n            );\r\n    }\r\n\r\n    function computeProtoHashBefore(\r\n        bytes32 machineHash,\r\n        bytes32 inboxTop,\r\n        uint256 inboxCount,\r\n        uint256 messageCount,\r\n        uint256 logCount\r\n    ) public pure returns (bytes32) {\r\n        return\r\n            RollupUtils.protoStateHash(machineHash, inboxTop, inboxCount, messageCount, logCount);\r\n    }\r\n\r\n    function computePrevLeaf(\r\n        bytes32[8] memory fields,\r\n        uint256[5] memory fields2,\r\n        uint32 prevChildType,\r\n        uint64 numSteps,\r\n        uint64 numArbGas,\r\n        uint64 messageCount,\r\n        uint64 logCount\r\n    ) public pure returns (bytes32 prevLeaf, bytes32 vmProtoHashBefore) {\r\n        NodeGraphUtils.AssertionData memory assertData = NodeGraphUtils.makeAssertion(\r\n            fields,\r\n            fields2,\r\n            prevChildType,\r\n            numSteps,\r\n            numArbGas,\r\n            messageCount,\r\n            logCount\r\n        );\r\n\r\n        return NodeGraphUtils.computePrevLeaf(assertData);\r\n    }\r\n\r\n    function generateInvalidInboxTopLeaf(\r\n        uint256[4] memory invalidInboxData,\r\n        bytes32[8] memory fields,\r\n        uint256[5] memory fields2,\r\n        uint32 prevChildType,\r\n        uint64 numSteps,\r\n        uint64 numArbGas,\r\n        uint64 messageCount,\r\n        uint64 logCount\r\n    ) public pure returns (bytes32) {\r\n        NodeGraphUtils.AssertionData memory assertData = NodeGraphUtils.makeAssertion(\r\n            fields,\r\n            fields2,\r\n            prevChildType,\r\n            numSteps,\r\n            numArbGas,\r\n            messageCount,\r\n            logCount\r\n        );\r\n\r\n        return _generateInvalidInboxTopLeaf(assertData, invalidInboxData);\r\n    }\r\n\r\n    function _generateInvalidInboxTopLeaf(\r\n        NodeGraphUtils.AssertionData memory assertData,\r\n        uint256[4] memory invalidInboxData\r\n    ) private pure returns (bytes32) {\r\n        (bytes32 prevLeaf, bytes32 vmProtoHashBefore) = NodeGraphUtils.computePrevLeaf(assertData);\r\n\r\n        return\r\n            NodeGraphUtils.generateInvalidInboxTopLeaf(\r\n                assertData,\r\n                prevLeaf,\r\n                invalidInboxData[3],\r\n                bytes32(invalidInboxData[0]),\r\n                invalidInboxData[1],\r\n                vmProtoHashBefore,\r\n                invalidInboxData[2]\r\n            );\r\n    }\r\n\r\n    function generateInvalidExecutionLeaf(\r\n        uint256 gracePeriodTicks,\r\n        uint256 checkTimeTicks,\r\n        uint256 deadlineTicks,\r\n        bytes32[8] memory fields,\r\n        uint256[5] memory fields2,\r\n        uint32 prevChildType,\r\n        uint64 numSteps,\r\n        uint64 numArbGas,\r\n        uint64 messageCount,\r\n        uint64 logCount\r\n    ) public pure returns (bytes32) {\r\n        NodeGraphUtils.AssertionData memory assertData = NodeGraphUtils.makeAssertion(\r\n            fields,\r\n            fields2,\r\n            prevChildType,\r\n            numSteps,\r\n            numArbGas,\r\n            messageCount,\r\n            logCount\r\n        );\r\n\r\n        return\r\n            _generateInvalidExecutionLeaf(\r\n                assertData,\r\n                gracePeriodTicks,\r\n                checkTimeTicks,\r\n                deadlineTicks\r\n            );\r\n    }\r\n\r\n    function _generateInvalidExecutionLeaf(\r\n        NodeGraphUtils.AssertionData memory assertData,\r\n        uint256 gracePeriodTicks,\r\n        uint256 checkTimeTicks,\r\n        uint256 deadlineTicks\r\n    ) private pure returns (bytes32) {\r\n        (bytes32 prevLeaf, bytes32 vmProtoHashBefore) = NodeGraphUtils.computePrevLeaf(assertData);\r\n\r\n        return\r\n            NodeGraphUtils.generateInvalidExecutionLeaf(\r\n                assertData,\r\n                prevLeaf,\r\n                deadlineTicks,\r\n                vmProtoHashBefore,\r\n                gracePeriodTicks,\r\n                checkTimeTicks\r\n            );\r\n    }\r\n\r\n    function generateValidLeaf(\r\n        uint256 deadlineTicks,\r\n        bytes32[8] memory fields,\r\n        uint256[5] memory fields2,\r\n        uint32 prevChildType,\r\n        uint64 numSteps,\r\n        uint64 numArbGas,\r\n        uint64 messageCount,\r\n        uint64 logCount\r\n    ) public pure returns (bytes32) {\r\n        NodeGraphUtils.AssertionData memory assertData = NodeGraphUtils.makeAssertion(\r\n            fields,\r\n            fields2,\r\n            prevChildType,\r\n            numSteps,\r\n            numArbGas,\r\n            messageCount,\r\n            logCount\r\n        );\r\n\r\n        return _generateValidLeaf(assertData, deadlineTicks);\r\n    }\r\n\r\n    function _generateValidLeaf(\r\n        NodeGraphUtils.AssertionData memory assertData,\r\n        uint256 deadlineTicks\r\n    ) private pure returns (bytes32) {\r\n        (bytes32 prevLeaf, ) = NodeGraphUtils.computePrevLeaf(assertData);\r\n\r\n        return NodeGraphUtils.generateValidLeaf(assertData, prevLeaf, deadlineTicks);\r\n    }\r\n}\r\n"
    },
    ".coverage_contracts/test_only/ValueTester.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2020, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nimport \"../arch/Value.sol\";\r\nimport \"../arch/Marshaling.sol\";\r\n\r\ncontract ValueTester {\r\n    using Hashing for Value.Data;\r\n\r\n    function deserializeHash(bytes memory data, uint256 startOffset)\r\n        public\r\n        pure\r\n        returns (\r\n            uint256, // offset\r\n            bytes32 // valHash\r\n        )\r\n    {\r\n        (uint256 offset, Value.Data memory value) = Marshaling.deserialize(data, startOffset);\r\n        return (offset, value.hash());\r\n    }\r\n\r\n    function bytesToBytestackHash(\r\n        bytes memory data,\r\n        uint256 startOffset,\r\n        uint256 dataLength\r\n    ) public pure returns (bytes32) {\r\n        return Marshaling.bytesToBytestack(data, startOffset, dataLength).hash();\r\n    }\r\n\r\n    function bytestackToBytes(bytes memory data, uint256 offset)\r\n        public\r\n        pure\r\n        returns (\r\n            bool,\r\n            uint256,\r\n            bytes memory\r\n        )\r\n    {\r\n        return Marshaling.bytestackToBytes(data, offset);\r\n    }\r\n\r\n    function hashTuplePreImage(bytes32 innerHash, uint256 valueSize) public pure returns (bytes32) {\r\n        return Hashing.hashTuplePreImage(innerHash, valueSize);\r\n    }\r\n\r\n    function hashTestTuple() public pure returns (bytes32) {\r\n        Value.Data[] memory tupVals = new Value.Data[](2);\r\n        tupVals[0] = Value.newInt(uint256(111));\r\n        tupVals[1] = Value.newTuple(new Value.Data[](0));\r\n        return Value.newTuple(tupVals).hash();\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}